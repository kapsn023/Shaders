{
  "version": 3,
  "sources": ["../../gophergfx/src/math/Color.ts", "../../gophergfx/src/math/Vector2.ts", "../../gophergfx/src/math/MathUtils.ts", "../../gophergfx/src/core/Renderer.ts", "../../gophergfx/src/math/Vector3.ts", "../../gophergfx/src/math/Quaternion.ts", "../../gophergfx/src/math/Matrix4.ts", "../../gophergfx/src/math/BoundingBox3.ts", "../../gophergfx/src/math/BoundingSphere.ts", "../../gophergfx/src/core/Node3.ts", "../../gophergfx/src/core/Camera.ts", "../../gophergfx/src/math/Matrix3.ts", "../../gophergfx/src/math/BoundingBox2.ts", "../../gophergfx/src/math/BoundingCircle.ts", "../../gophergfx/src/core/Node2.ts", "../../gophergfx/src/lights/LightManager.ts", "../../gophergfx/src/core/Scene.ts", "../../gophergfx/src/loaders/AssetManager.ts", "../../gophergfx/src/core/GfxApp.ts", "../../gophergfx/src/materials/ShaderProgram.ts", "../../gophergfx/src/materials/Material2.ts", "../../gophergfx/src/geometry/2d/Mesh2.ts", "../../gophergfx/src/geometry/2d/Line2.ts", "../../gophergfx/src/geometry/Geometry2Factory.ts", "../../gophergfx/src/materials/Material3.ts", "../../gophergfx/src/materials/GouraudMaterial.ts", "../../gophergfx/src/geometry/3d/Mesh3.ts", "../../gophergfx/src/materials/UnlitMaterial.ts", "../../gophergfx/src/geometry/3d/Line3.ts", "../../gophergfx/src/geometry/Geometry3Factory.ts", "../../gophergfx/src/materials/MorphMaterial.ts", "../../gophergfx/src/geometry/3d/MorphMesh3.ts", "../../gophergfx/src/geometry/2d/Particles2.ts", "../../gophergfx/src/interaction/OrbitControls.ts", "../../gophergfx/src/interaction/FirstPersonControls.ts", "../../gophergfx/src/math/Plane3.ts", "../../gophergfx/src/math/Ray3.ts", "../../gophergfx/src/interaction/TransformWidget.ts", "../../gophergfx/src/lights/Light.ts", "../../gophergfx/src/lights/AmbientLight.ts", "../../gophergfx/src/lights/DirectionalLight.ts", "../../gophergfx/src/lights/PointLight.ts", "../../gophergfx/src/loaders/TextFileLoader.ts", "../../gophergfx/src/loaders/StringParser.ts", "../../gophergfx/src/loaders/FileWriter.ts", "../../gophergfx/src/loaders/MeshParser.ts", "../../property-graph/src/event-dispatcher.ts", "../../property-graph/src/graph-edge.ts", "../../property-graph/src/graph.ts", "../../property-graph/src/utils.ts", "../../property-graph/src/graph-node.ts", "../../@gltf-transform/core/src/constants.ts", "../../node_modules/gl-matrix/esm/common.js", "../../node_modules/gl-matrix/esm/vec3.js", "../../@gltf-transform/core/src/utils/get-bounds.ts", "../../@gltf-transform/core/src/utils/buffer-utils.ts", "../../@gltf-transform/core/src/utils/color-utils.ts", "../../@gltf-transform/core/src/utils/image-utils.ts", "../../@gltf-transform/core/src/utils/file-utils.ts", "../../@gltf-transform/core/src/utils/is-plain-object.ts", "../../@gltf-transform/core/src/utils/logger.ts", "../../node_modules/gl-matrix/esm/mat4.js", "../../@gltf-transform/core/src/utils/math-utils.ts", "../../@gltf-transform/core/src/utils/property-utils.ts", "../../@gltf-transform/core/src/utils/uuid.ts", "../../@gltf-transform/core/src/utils/http-utils.ts", "../../@gltf-transform/core/src/properties/property.ts", "../../@gltf-transform/core/src/properties/extensible-property.ts", "../../@gltf-transform/core/src/properties/accessor.ts", "../../@gltf-transform/core/src/properties/animation.ts", "../../@gltf-transform/core/src/properties/animation-channel.ts", "../../@gltf-transform/core/src/properties/animation-sampler.ts", "../../@gltf-transform/core/src/properties/buffer.ts", "../../@gltf-transform/core/src/properties/camera.ts", "../../@gltf-transform/core/src/properties/extension-property.ts", "../../@gltf-transform/core/src/properties/texture-info.ts", "../../@gltf-transform/core/src/properties/material.ts", "../../@gltf-transform/core/src/properties/mesh.ts", "../../@gltf-transform/core/src/properties/node.ts", "../../@gltf-transform/core/src/properties/primitive.ts", "../../@gltf-transform/core/src/properties/primitive-target.ts", "../../@gltf-transform/core/src/properties/scene.ts", "../../@gltf-transform/core/src/properties/skin.ts", "../../@gltf-transform/core/src/properties/texture.ts", "../../@gltf-transform/core/src/properties/root.ts", "../../@gltf-transform/core/src/document.ts", "../../@gltf-transform/core/src/extension.ts", "../../@gltf-transform/core/src/io/reader-context.ts", "../../@gltf-transform/core/src/io/reader.ts", "../../@gltf-transform/core/src/io/writer-context.ts", "../../@gltf-transform/core/src/io/writer.ts", "../../@gltf-transform/core/src/io/platform-io.ts", "../../@gltf-transform/core/src/io/node-io.ts", "../../@gltf-transform/core/src/io/deno-io.ts", "../../@gltf-transform/core/src/io/web-io.ts", "../../gophergfx/src/loaders/MeshLoader.ts", "../../gophergfx/src/loaders/MeshWriter.ts", "../../gophergfx/src/materials/PhongMaterial.ts", "../../gophergfx/src/materials/WireframeMaterial.ts", "../../gophergfx/src/materials/BoundingVolumeMaterial.ts", "../../gophergfx/src/materials/Texture.ts", "../../gophergfx/src/materials/Text.ts", "../../gophergfx/src/math/LinearPath3.ts", "../../gophergfx/src/math/CurvePath3.ts", "../../gophergfx/src/math/LinearPath2.ts", "../../gophergfx/src/math/CurvePath2.ts"],
  "sourcesContent": ["\n/**\n * This class holds a color for computer graphics defined via four components (Red, Green, Blue, Alpha).\n * Alpha is opacity (0.0 = completely transparent, 1.0 = completely opaque).  All components range from\n * 0.0 to 1.0 in floating point.  \n */\nexport class Color\n{\n\n/**\n * Static properties representing standard colors\n */\n    public static readonly WHITE = new Color(1, 1, 1);\n    public static readonly BLACK = new Color(0, 0, 0);\n    public static readonly RED = new Color(1, 0 ,0);\n    public static readonly GREEN = new Color(0, 1 ,0);\n    public static readonly BLUE = new Color(0, 0, 1);\n    public static readonly YELLOW = new Color(1, 1, 0);\n    public static readonly PURPLE = new Color(1, 0, 1);\n    public static readonly CYAN = new Color(0, 1, 1);\n\n/**\n * Static method to create a copy of the given Color object\n * \n * @param color - The Color object to copy\n * @returns A copy of the given Color object\n */\n    public static copy(color: Color): Color\n    {\n        const newColor = new Color();\n        newColor.r = color.r;\n        newColor.g = color.g;\n        newColor.b = color.b;\n        newColor.a = color.a;\n        return newColor;\n    }\n\n/**\n * Static method to create a Color object from a hex string\n * \n * @param color - The hex string to convert to a Color object\n * @returns A new Color object created from the given hex string\n */\n    public static createFromString(color: string): Color\n    {\n        return new Color(\n            parseInt(color.substring(1,3), 16) / 255,\n            parseInt(color.substring(3,5), 16) / 255,\n            parseInt(color.substring(5,7), 16) / 255\n        );\n    }\n\n/**\n * Static method to interpolate between two Color objects\n * \n * @param c1 - The first Color object\n * @param c2 - The second Color object\n * @param alpha - The interpolation factor between the two objects\n * @returns The interpolated Color object\n */\n    public static lerp(c1: Color, c2: Color, alpha: number): Color\n    {\n        return new Color(\n            c1.r * (1-alpha) + c2.r * alpha,\n            c1.g * (1-alpha) + c2.g * alpha,\n            c1.b * (1-alpha) + c2.b * alpha,\n            c1.a * (1-alpha) + c2.a * alpha,\n        );\n    }\n\n/**\n * Static method to add two Color objects\n * \n * @param c1 - The first Color object\n * @param c2 - The second Color object\n * @returns The sum of the two Color objects\n */\n    public static add(c1: Color, c2: Color): Color\n    {\n        return new Color(c1.r + c2.r, c1.g + c2.g, c1.b + c2.b);\n    }\n\n/**\n * Static method to subtract two Color objects\n * \n * @param c1 - The first Color object\n * @param c2 - The second Color object\n * @returns The difference between the two Color objects\n */\n    public static subtract(c1: Color, c2: Color): Color\n    {\n        return new Color(c1.r - c2.r, c1.g - c2.g, c1.b - c2.b);\n    }\n\n/**\n * Static method to multiply two Color objects\n * \n * @param c1 - The first Color object\n * @param c2 - The second Color object\n * @returns The product of the two Color objects\n */\n    public static multiply(c1: Color, c2: Color): Color\n    {\n        return new Color(c1.r * c2.r, c1.g * c2.g, c1.b * c2.b);\n    }\n\n/**\n * Static method to divide two Color objects\n * \n * @param c1 - The first Color object\n * @param c2 - The second Color object\n * @returns The quotient of the two Color objects\n */\n    public static divide(c1: Color, c2: Color): Color\n    {\n        return new Color(c1.r / c2.r, c1.g / c2.g, c1.b / c2.b);\n    }\n\n/**\n * Static method to multiply a Color object by a scalar\n * \n * @param v - The Color object to multiply\n * @param n - The scalar to multiply by\n * @returns The product of the Color object and the scalar\n */\n    public static multiplyScalar(v: Color, n: number): Color\n    {\n        return new Color(v.r * n, v.g * n, v.b * n);\n    }\n\n/**\n * Static method that calculates the result of dividing a Color by a scalar\n * \n * @param v - The Color object to be divided\n * @param n - The scalar to divide the Color by\n * @returns The result of the division\n */\n    public static divideScalar(v: Color, n: number): Color\n    {\n        return new Color(v.r / n, v.g / n, v.b / n);\n    }\n\n    public r: number;\n    public g: number;\n    public b: number;\n    public a: number;\n\n/**\n * Constructor for creating a Color object\n * \n * @param r - The red component of the Color object\n * @param g - The green component of the Color object\n * @param b - The blue component of the Color object\n * @param a - The alpha component of the Color object\n */\n    constructor(r = 0, g = 0, b = 0, a = 1)\n    {\n        this.r = r;\n        this.g = g;\n        this.b = b;\n        this.a = a;\n    }\n\n/**\n * Set the components of the Color object\n * \n * @param r - The red component\n * @param g - The green component\n * @param b - The blue component\n * @param a - The alpha component (optional, defaults to 1)\n */\n    set(r = 0, g = 0, b = 0, a = 1): void\n    {\n        this.r = r;\n        this.g = g;\n        this.b = b;\n        this.a = a;\n    }\n\n/**\n * Set the components of the Color object from a hex string\n * \n * @param color - The hex string to convert to a Color object\n */\n    setFromString(color: string): void\n    {\n        this.r = parseInt(color.substring(1,3), 16) / 255;\n        this.g = parseInt(color.substring(3,5), 16) / 255;\n        this.b = parseInt(color.substring(5,7), 16) / 255;\n    }\n\n/**\n * Copy the components of a given Color object\n * \n * @param color - The Color object to copy\n */\n    copy(color: Color)\n    {\n        this.r = color.r;\n        this.g = color.g;\n        this.b = color.b;\n        this.a = color.a;\n    }\n\n/**\n * Create a clone of the Color object\n * \n * @returns A new Color object that is an exact copy of the original\n */\n    clone(): Color\n    {\n        return new Color(this.r, this.g, this.b, this.a);\n    }\n\n/**\n * Interpolate between two Color objects\n * \n * @param c1 - The first Color object\n * @param c2 - The second Color object\n * @param alpha - The interpolation factor between the two objects\n */\n    lerp(c1: Color, c2: Color, alpha: number): void\n    {\n        this.r = c1.r * (1-alpha) + c2.r * alpha;\n        this.g = c1.g * (1-alpha) + c2.g * alpha;\n        this.b = c1.b * (1-alpha) + c2.b * alpha;\n        this.a = c1.b * (1-alpha) + c2.a * alpha;\n    }\n\n/**\n * Add another Color object to the current one\n * \n * @param c - The Color object to add\n */\n    add(c: Color): void\n    {\n        this.r += c.r;\n        this.g += c.g;\n        this.b += c.b;\n    }\n\n/**\n * Subtract another Color object from the current one\n * \n * @param c - The Color object to subtract\n */\n    subtract(c: Color): void\n    {\n        this.r -= c.r;\n        this.g -= c.g;\n        this.b -= c.b;\n    }\n\n/**\n * Multiply the current Color object by another one\n * \n * @param c - The Color object to multiply by\n */\n    multiply(c: Color): void\n    {\n        this.r *= c.r;\n        this.g *= c.g;\n        this.b *= c.b;\n    }\n\n/**\n * Divide the current Color object by another one\n * \n * @param c - The Color object to divide by\n */\n    divide(c: Color): void\n    {\n        this.r /= c.r;\n        this.g /= c.g;\n        this.b /= c.b;\n    }\n\n/**\n * Multiply the current Color object by a scalar\n * \n * @param n - The scalar to multiply by\n */\n    multiplyScalar(n: number): void\n    {\n        this.r *= n;\n        this.g *= n;\n        this.b *= n;\n    }\n\n/**\n * Method that divides a Color object by a scalar\n * \n * @param n - The scalar to divide the Color object by\n */\n    divideScalar(n: number): void\n    {\n        this.r /= n;\n        this.g /= n;\n        this.b /= n;\n    }\n}", "import { Matrix3 } from './Matrix3'\n\nexport class Vector2\n{\n    public static readonly ZERO = new Vector2(0, 0);\n    public static readonly ONE = new Vector2(1, 1);\n    public static readonly UP = new Vector2(0, 1);\n    public static readonly DOWN = new Vector2(0, -1);\n    public static readonly LEFT = new Vector2(-1, 0);\n    public static readonly RIGHT = new Vector2(1, 0);\n    public static readonly X_AXIS = Vector2.RIGHT;\n    public static readonly Y_AXIS = Vector2.UP;\n\n    /**\n     * Copies the values of v into a new Vector2 object\n     * \n     * @param v - The Vector2 object to copy\n     * @returns A new Vector2 object with the same values as v\n     */\n    public static copy(v: Vector2): Vector2\n    {\n        return new Vector2(v.x, v.y);\n    }\n\n    /**\n     * Inverts the values of the Vector2 object \n     * \n     * @param v - The Vector2 object to invert\n     * @returns A new Vector2 object with the inverted values of v\n     */\n    public static inverse(v: Vector2): Vector2\n    {\n        return new Vector2(-v.x, -v.y);\n    }\n\n    /**\n     * Adds two Vector2 objects and returns the result in a new Vector2\n     * \n     * @param v1 - The first Vector2 object\n     * @param v2 - The second Vector2 object\n     * @returns A new Vector2 object with the result of the addition\n     */\n    public static add(v1: Vector2, v2: Vector2): Vector2\n    {\n        return new Vector2(v1.x + v2.x, v1.y + v2.y);\n    }\n\n    /**\n     * Subtracts two Vector2 objects and returns the result in a new Vector2\n     * \n     * @param v1 - The first Vector2 object\n     * @param v2 - The second Vector2 object\n     * @returns A new Vector2 object with the result of the subtraction\n     */\n    public static subtract(v1: Vector2, v2: Vector2): Vector2\n    {\n        return new Vector2(v1.x - v2.x, v1.y - v2.y);\n    }\n\n    /**\n     * Multiplies two Vector2 objects and returns the result in a new Vector2\n     * \n     * @param v1 - The first Vector2 object\n     * @param v2 - The second Vector2 object\n     * @returns A new Vector2 object with the result of the multiplication\n     */\n    public static multiply(v1: Vector2, v2: Vector2): Vector2\n    {\n        return new Vector2(v1.x * v2.x, v1.y * v2.y);\n    }\n\n    /**\n     * Divides two Vector2 objects and returns the result in a new Vector2\n     * \n     * @param v1 - The first Vector2 object\n     * @param v2 - The second Vector2 object\n     * @returns A new Vector2 object with the result of the division\n     */\n    public static divide(v1: Vector2, v2: Vector2): Vector2\n    {\n        return new Vector2(v1.x / v2.x, v1.y / v2.y);\n    }\n\n    /**\n     * Multiplies a Vector2 object by a scalar and returns the result in a new Vector2\n     * \n     * @param v - The Vector2 object\n     * @param n - The scalar\n     * @returns A new Vector2 object with the result of the multiplication\n     */\n    public static multiplyScalar(v: Vector2, n: number): Vector2\n    {\n        return new Vector2(v.x * n, v.y * n);\n    }\n\n    /**\n     * Divides a Vector2 object by a scalar and returns the result in a new Vector2\n     * \n     * @param v - The Vector2 object\n     * @param n - The scalar\n     * @returns A new Vector2 object with the result of the division\n     */\n    public static divideScalar(v: Vector2, n: number): Vector2\n    {\n        return new Vector2(v.x / n, v.y / n);\n    }\n\n    /**\n     * Computes the distance between two Vector2 objects\n     * \n     * @param v1 - The first Vector2 object\n     * @param v2 - The second Vector2 object\n     * @returns The distance between the two input vectors\n     */\n    public static distanceBetween(v1: Vector2, v2: Vector2): number\n    {\n        return v1.distanceTo(v2);\n    }\n\n    /**\n     * Computes the angle between two Vector2 objects\n     * \n     * @param v1 - The first Vector2 object\n     * @param v2 - The second Vector2 object\n     * @returns The angle between the two input vectors\n     */\n    public static angleBetween(v1: Vector2, v2: Vector2): number\n    {\n        return v1.angleBetween(v2);\n    }\n\n    /**\n     * Computes the angle between two Vector2 objects with sign \n     * \n     * @param v1 - The first Vector2 object\n     * @param v2 - The second Vector2 object\n     * @returns The signed angle between the two input vectors\n     */\n    public static angleBetweenSigned(v1: Vector2, v2: Vector2): number\n    {\n        return v1.angleBetweenSigned(v2);\n    }\n\n    /**\n     * Computes the dot product of two Vector2 objects\n     * \n     * @param v1 - The first Vector2 object\n     * @param v2 - The second Vector2 object\n     * @returns The dot product of the two input vectors\n     */\n    public static dot(v1: Vector2, v2: Vector2): number\n    {\n        return v1.x*v2.x + v1.y*v2.y;\n    }\n\n    /**\n     * Returns the normalized Vector2 of an input Vector2\n     * \n     * @param v - The Vector2 object to be normalized\n     * @returns The normalized Vector2\n     */\n    public static normalize(v: Vector2): Vector2\n    {\n        const sizeSquared = v.x*v.x + v.y*v.y;\n        \n        // zero vectors\n        if(sizeSquared < 1e-8)\n            return new Vector2();\n\n        const scaleFactor = 1 / Math.sqrt(sizeSquared);\n        return new Vector2(v.x * scaleFactor, v.y * scaleFactor);\n    }\n\n    /**\n     * Rotates an input Vector2 by a given angle\n     * \n     * @param v - The Vector2 object to be rotated\n     * @param angle - The angle to rotate the Vector2 by\n     * @returns The rotated Vector2 \n     */\n    public static rotate(v: Vector2, angle: number): Vector2\n    {\n        return new Vector2(Math.cos(angle)*v.x - Math.sin(angle)*v.y, Math.sin(angle)*v.x + Math.cos(angle)*v.y); \n    }\n\n    /**\n     * Transforms an input Vector2 as a point by a given Matrix3\n     * \n     * @param v - The Vector2 object to be transformed\n     * @param m - The Matrix3 to transform the Vector2 by\n     * @returns The transformed Vector2\n     */\n    public static transformPoint(v: Vector2, m: Matrix3): Vector2\n    {\n        const result = new Vector2();\n        const w = 1 / (m.mat[2]*v.x + m.mat[5]*v.y + m.mat[8]);\n        result.x = w * (m.mat[0]*v.x + m.mat[3]*v.y + m.mat[6]);\n        result.y = w * (m.mat[1]*v.x + m.mat[4]*v.y + m.mat[7]);\n        return result;\n    }\n\n    /**\n     * Transforms an input Vector2 as a direction by a given Matrix3, ignoring the translation component\n     * \n     * @param v - The Vector2 object to be transformed\n     * @param m - The Matrix3 to transform the Vector2 by\n     * @returns The transformed Vector2\n     */\n    public static transformVector(v: Vector2, m: Matrix3): Vector2\n    {\n        const result = new Vector2();\n        const w = 1 / (m.mat[2]*v.x + m.mat[5]*v.y + m.mat[8]);\n        result.x = w * (m.mat[0]*v.x + m.mat[3]*v.y);\n        result.y = w * (m.mat[1]*v.x + m.mat[4]*v.y);\n        return result;\n    }\n\n    /**\n     * Linearly interpolates between two Vector2 objects\n     * \n     * @param v1 - The first Vector2 object\n     * @param v2 - The second Vector2 object\n     * @param alpha - The interpolation value between 0 and 1\n     * @returns The interpolated Vector2\n     */\n    public static lerp(v1: Vector2, v2: Vector2, alpha: number): Vector2\n    {\n        return new Vector2(\n            v1.x * (1-alpha) + v2.x * alpha,\n            v1.y * (1-alpha) + v2.y * alpha\n        );\n    }\n\n    public x: number;\n    public y: number;\n    \n    /**\n     * Constructor for Vector2 class\n     * \n     * @param x - The initial x coordinate of the Vector2\n     * @param y - The initial y coordinate of the Vector2\n     */\n    constructor(x = 0, y = 0)\n    {\n        this.x = x;\n        this.y = y;\n    }\n\n    /**\n     * Sets the coordinates of the Vector2\n     * \n     * @param x - The new x coordinate of the Vector2\n     * @param y - The new y coordinate of the Vector2\n     */\n    set(x: number, y: number): void\n    {\n        this.x = x;\n        this.y = y;\n    }\n\n    /**\n     * Copies the coordinates of a Vector2 object\n     * \n     * @param v - The Vector2 object to copy\n     */\n    copy(v: Vector2): void\n    {\n        this.x = v.x;\n        this.y = v.y;\n    }\n\n    /**\n     * Clones the Vector2 object\n     * \n     * @returns A new Vector2 object with the same coordinates as the original\n     */\n    clone(): Vector2\n    {\n        return new Vector2(this.x, this.y);\n    }\n\n    /**\n     * Checks if two Vector2 objects have the same coordinates\n     * \n     * @param v - The Vector2 object to compare\n     * @returns true if the coordinates of both Vector2 objects are the same, false otherwise\n     */\n    equals(v: Vector2): boolean\n    {\n        return this.x == v.x && this.y == v.y;\n    }\n\n    /**\n     * Adds the components of a given Vector2 to this Vector2\n     * \n     * @param v - The Vector2 to add to this Vector2\n     */\n    add(v: Vector2): void\n    {\n        this.x += v.x;\n        this.y += v.y;\n    }\n\n    /**\n     * Subtracts the components of a given Vector2 from this Vector2\n     * \n     * @param v - The Vector2 to subtract from this Vector2\n     */\n    subtract(v: Vector2): void\n    {\n        this.x -= v.x;\n        this.y -= v.y;\n    }\n\n    /**\n     * Multiplies the components of a given Vector2 by this Vector2\n     * \n     * @param v - The Vector2 to multiply this Vector2 by\n     */\n    multiply(v: Vector2): void\n    {\n        this.x *= v.x;\n        this.y *= v.y;\n    }\n\n    /**\n     * Divides the components of this Vector2 by a given Vector2\n     * \n     * @param v - The Vector2 to divide this Vector2 by\n     */\n    divide(v: Vector2): void\n    {\n        this.x /= v.x;\n        this.y /= v.y;\n    }\n\n    /**\n     * Multiplies the Vector2 by a scalar value\n     * \n     * @param n - The scalar value to multiply by\n     */\n    multiplyScalar(n: number): void\n    {\n        this.x *= n;\n        this.y *= n;\n    }\n\n    /**\n     * Divides the Vector2 by a scalar value\n     * \n     * @param n - The scalar value to divide by\n     */\n    divideScalar(n: number): void\n    {\n        this.x /= n;\n        this.y /= n;\n    }\n\n    /**\n     * Calculates the distance between this Vector2 and another Vector2\n     * \n     * @param v - The Vector2 to calculate the distance to\n     * @returns The distance between the two Vector2 objects\n     */\n    distanceTo(v: Vector2): number\n    {\n        return Math.sqrt(\n            (this.x - v.x) * (this.x - v.x) + \n            (this.y - v.y) * (this.y - v.y) \n        );\n    }\n\n    /**\n     * Sets the position of this Vector2 from a Matrix3\n     * \n     * @param m - The Matrix3 to get the position from\n     */\n    setPositionFromMatrix(m: Matrix3): void\n    {\n        this.x = m.mat[6];\n        this.y = m.mat[7];\n    }\n\n    /**\n     * Sets the scale of this Vector2 from a Matrix3\n     * \n     * @param m - The Matrix3 to get the scale from\n     */\n    setScaleFromMatrix(m: Matrix3): void\n    {\n        this.x = Math.sqrt(m.mat[0]*m.mat[0] + m.mat[1]*m.mat[1]);\n        this.y = Math.sqrt(m.mat[3]*m.mat[3] + m.mat[4]*m.mat[4]);\n    }\n\n    /**\n     * Transforms this Vector2 object with a Matrix3\n     * \n     * @param m - The Matrix3 to transform this Vector2 with\n     */\n    transformPoint(m: Matrix3): void\n    {\n        const v = this.clone();\n        const w = 1 / (m.mat[2]*v.x + m.mat[5]*v.y + m.mat[8]);\n        this.x = w * (m.mat[0]*v.x + m.mat[3]*v.y + m.mat[6]);\n        this.y = w * (m.mat[1]*v.x + m.mat[4]*v.y + m.mat[7]);\n    }\n\n    /**\n     * Transforms this Vector2 object with a Matrix3, ignoring the translation component\n     * \n     * @param m - The Matrix3 to transform this Vector2 with\n     */\n    transformVector(m: Matrix3): void\n    {\n        const v = this.clone();\n        const w = 1 / (m.mat[2]*v.x + m.mat[5]*v.y + m.mat[8]);\n        this.x = w * (m.mat[0]*v.x + m.mat[3]*v.y);\n        this.y = w * (m.mat[1]*v.x + m.mat[4]*v.y);\n    }\n\n    /**\n     * Calculates the dot product of this Vector2 and another Vector2\n     * \n     * @param v - The Vector2 to calculate the dot product with\n     * @returns The dot product of the two Vector2 objects\n     */\n    dot(v: Vector2): number\n    {\n        return this.x*v.x + this.y*v.y;\n    }\n    \n    /**\n     * Calculates the length of this Vector2\n     * \n     * @returns The length of this Vector2\n     */\n    length(): number\n    {\n        return Math.sqrt(this.x*this.x + this.y*this.y);\n    }\n    \n    /**\n     * Normalizes this Vector2\n     */\n    normalize(): void\n    {\n        const sizeSquared = this.x*this.x + this.y*this.y;\n        \n        // zero vectors\n        if(sizeSquared < 1e-8)\n            return;\n\n        const scaleFactor = 1 / Math.sqrt(sizeSquared);\n        this.x *= scaleFactor;\n        this.y *= scaleFactor;\n    }\n\n    /**\n     * Inverts this Vector2\n     */\n    invert(): void\n    {\n        this.x = -this.x;\n        this.y = -this.y;\n    }\n\n    /**\n     * Calculates the angle between this Vector2 and another Vector2\n     * \n     * @param v - The Vector2 to calculate the angle between\n     * @returns The angle between the two Vector2 objects\n     */\n    angleBetween(v: Vector2): number\n    {\n        const v1Norm = Vector2.normalize(this);\n        const v2Norm = Vector2.normalize(v);\n\n        return Math.acos(v1Norm.dot(v2Norm));\n    }\n    \n    /**\n     * Calculates the signed angle between this Vector2 and another Vector2\n     * \n     * @param v - The Vector2 to calculate the angle between\n     * @returns The signed angle between the two Vector2 objects\n     */\n    angleBetweenSigned(v: Vector2): number\n    {\n        const v1Norm = Vector2.normalize(this);\n        const v2Norm = Vector2.normalize(v);\n\n        return Math.atan2(v2Norm.y,v2Norm.x) - Math.atan2(v1Norm.y, v1Norm.x)\n    }\n\n    /**\n     * Rotates this Vector2 by a given angle\n     * \n     * @param angle - The angle to rotate by in radians\n     */\n    rotate(angle: number): void\n    {\n        const x = this.x;\n        const y = this.y;\n        this.x = Math.cos(angle)*x - Math.sin(angle)*y;\n        this.y = Math.sin(angle)*x + Math.cos(angle)*y; \n    }\n\n    /**\n     * Calculates the linear interpolation between two Vector2 objects\n     * \n     * @param v1 - The first Vector2 object\n     * @param v2 - The second Vector2 object\n     * @param alpha - The interpolation value between 0 and 1\n     */\n    lerp(v1: Vector2, v2: Vector2, alpha: number): void\n    {\n        this.x = v1.x * (1-alpha) + v2.x * alpha;\n        this.y = v1.y * (1-alpha) + v2.y * alpha;\n    }\n}", "export class MathUtils\n{\n\n    /**\n     * Default small value used to account for numerical instabilities when testing for equality, etc. \n     */\n    public static readonly EPSILON = 0.0000001;\n\n    /**\n     * Converts degrees to radians\n     * \n     * @param degrees - The degrees value to be converted\n     * @returns The converted radians value\n     */\n    public static degreesToRadians(degrees: number)\n    {\n        return degrees * Math.PI / 180;\n    }\n\n    /**\n     * Converts radians to degrees\n     * \n     * @param radians - The radians value to be converted\n     * @returns The converted degrees value\n     */\n    public static radiansToDegrees(radians: number)\n    {\n        return radians * 180 / Math.PI;\n    }\n\n    /**\n     * Rescales a value from one range to another\n     * \n     * @param value - The value to be rescaled\n     * @param min - The minimum value of the original range\n     * @param max - The maximum value of the original range\n     * @param scaledMin - The minimum value of the scaled range\n     * @param scaledMax - The maximum value of the scaled range\n     * @returns The rescaled value\n     */\n    public static rescale(value: number, min: number, max: number, scaledMin: number, scaledMax: number): number\n    {\n        return scaledMin + (scaledMax - scaledMin) * (value - min) / (max - min);\n    }\n\n    /**\n     * Clamps a value between a minimum and maximum value\n     * \n     * @param value - The value to be clamped\n     * @param min - The minimum value\n     * @param max - The maximum value\n     * @returns The clamped value\n     */\n    public static clamp(value: number, min: number, max: number): number\n    {\n        return Math.max(min, Math.min(max, value));\n    }\n\n    /**\n     * Performs linear interpolation between two values\n     * \n     * @param x - The first value\n     * @param y - The second value\n     * @param alpha - The interpolation factor\n     * @returns The interpolated value\n     */\n    public static lerp(x: number, y: number, alpha: number): number\n    {\n        return x * (1-alpha) + y * alpha;\n    }\n}", "import { Scene } from \"./Scene\";\nimport { Camera } from \"./Camera\";\nimport { Color } from \"../math/Color\";\nimport { Vector2 } from \"../math/Vector2\";\nimport { MathUtils } from \"../math/MathUtils\";\n\nexport enum Viewport\n{\n    FIT,\n    CROP,\n    STRETCH\n}\n\n/**\n * Creates a renderer object to use for drawing to a WebGL2 canvas\n */\nexport class Renderer\n{\n    /**\n     * The background color of the viewport\n     */\n    public background: Color;\n\n    /**\n     * The viewport of the renderer\n     */\n    public viewport: Viewport;\n\n    /**\n     * The canvas element that the renderer draws to\n     */\n    public readonly gfxCanvas: HTMLCanvasElement;\n\n    /**\n     * The WebGL2 context used by the renderer\n     */\n    public readonly gl: WebGL2RenderingContext;\n\n    /**\n     * Creates a WebGL context for the given canvas element\n     *\n     * @param enableStencilBuffer - Whether to enable the stencil buffer for the WebGL context\n     */\n    constructor(enableStencilBuffer = false)\n    {\n        this.gfxCanvas = document.getElementById(\"gfxCanvas\") as HTMLCanvasElement;\n        if(!this.gfxCanvas)\n        {\n            alert(\"Unable to find gfxCanvas.\");\n        }\n\n        this.gfxCanvas.width = window.innerWidth;\n        this.gfxCanvas.height = window.innerHeight;\n\n        // Initialize the GL context\n        // Disabling alpha in the back buffer prevents texture blending issues\n        // due to the way WebGL composites the canvas with the body background\n        const gl = this.gfxCanvas.getContext(\"webgl2\", {alpha: false, stencil: enableStencilBuffer})!;\n        if(!gl) \n        {\n            alert(\"Unable to initialize WebGL. Your browser or machine may not support it.\");\n        }\n        this.gl = gl!;\n\n        // depth testing\n        gl.enable(gl.DEPTH_TEST);\n        gl.depthFunc(gl.LEQUAL);\n\n        // back face culling\n        gl.enable(gl.CULL_FACE);\n        gl.cullFace(gl.BACK);\n        \n        // texturing with transparency\n        gl.enable(this.gl.BLEND) ;\n        gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n\n        this.background = new Color();\n        this.viewport = Viewport.FIT;\n    }\n\n    /**\n     * Resizes the graphics canvas and adjusts the viewport to maintain the provided aspect ratio.\n     * @param width - The width of the graphics canvas in pixels.\n     * @param height - The height of the graphics canvas in pixels.\n     * @param aspectRatio - The aspect ratio of the graphics canvas.\n     */\n    resize(width: number, height: number, aspectRatio: number): void\n    {\n        this.gfxCanvas.width = width;\n        this.gfxCanvas.height = height;\n\n        if(this.viewport == Viewport.FIT)\n        {\n            // Resize and center the viewport to preserve the aspect ratio\n            if(aspectRatio > window.innerWidth / window.innerHeight)\n            {\n                this.gl.viewport(\n                    0, \n                    (window.innerHeight - window.innerWidth / aspectRatio) / 2, \n                    window.innerWidth, \n                    window.innerWidth / aspectRatio\n                );\n            }\n            else\n            {\n                this.gl.viewport(\n                    (window.innerWidth - window.innerHeight * aspectRatio) / 2, \n                    0, \n                    window.innerHeight * aspectRatio, \n                    window.innerHeight\n                );\n            }\n        }\n        else if(this.viewport == Viewport.CROP)\n        {\n            // Resize and center the viewport to crop within the window\n            if(aspectRatio > window.innerWidth / window.innerHeight)\n            {\n                this.gl.viewport(\n                    (window.innerWidth - window.innerHeight * aspectRatio) / 2, \n                    0, \n                    window.innerHeight * aspectRatio, \n                    window.innerHeight\n                );\n            }\n            else\n            {\n                this.gl.viewport(\n                    0, \n                    (window.innerHeight - window.innerWidth / aspectRatio) / 2, \n                    window.innerWidth, \n                    window.innerWidth / aspectRatio\n                );\n            }\n        }\n        else\n        {\n            // Resize the viewport fill the entire entire window\n            // This does not preserve the aspect ratio\n            this.gl.viewport(\n                0,\n                0, \n                window.innerWidth, \n                window.innerHeight\n            );\n        }\n    }\n\n    /**\n     * Draws the scene using the provided camera.\n     * @param scene - The scene to draw.\n     * @param camera - The camera used to draw the scene.\n     */\n    render(scene: Scene, camera: Camera): void\n    {\n        if(camera.projectionMatrixDirty)\n        {\n            this.resize(this.gfxCanvas.width, this.gfxCanvas.height, camera.getAspectRatio());\n            camera.projectionMatrixDirty = false;\n        }\n\n        this.gl.clearColor(this.background.r, this.background.g, this.background.b, this.background.a);\n        this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT); \n        \n        scene.draw(camera);\n    }\n\n    /**\n     * Gets the normalized device coordinates from the provided mouse coordinates. \n     * @param mouseX - The x coordinate of the mouse.\n     * @param mouseY - The y coordinate of the mouse.\n     * @returns The normalized device coordinates.\n     */\n    getNormalizedDeviceCoordinates(mouseX: number, mouseY: number): Vector2\n    {\n        const viewport = this.gl.getParameter(this.gl.VIEWPORT) as Int32Array;\n        return new Vector2(\n            MathUtils.clamp((mouseX - viewport[0]) / viewport[2] * 2 - 1, -1, 1),\n            MathUtils.clamp((mouseY - viewport[1]) / viewport[3] * -2 + 1, -1, 1)\n        );\n    }\n}", "import { MathUtils } from './MathUtils';\nimport { Matrix4 } from './Matrix4'\nimport { Quaternion } from './Quaternion';\n\n/**\n * This class holds the x,y,z components of a 3D point or vector.  It includes linear algebra routines for\n * working with vectors (e.g., dot product, cross product).\n * \n * Most of the functions in the class are defined both as member functions that can be called on a specific\n * instance of Vector3 *and* as static functions.  The static functions return a *new* result, leaving the\n * original inputs unchanged, whereas, in general, member functions save the result in this vector itself\n * and return void:\n * ```\n * const v = new Vector3(1, 2, 3);\n * const w = new Vector3(4, 5, 6);\n * \n * // saves the result in n, v and w are unchanged.\n * const n = Vector3.cross(v, w);\n * \n * // saves the result in v and returns null.  v now becomes v crossed-with w.\n * v.cross(w);\n * ```\n */\nexport class Vector3\n{\n    /**\n     * A static property to provide quick access to a Vector3 with all of its x,y,z components equal to zero.\n     * (Note: Be careful not to change the value of this field!  It is marked readonly, but typescipt do not completely\n     * enforce this!)\n     * ```\n     * // Good use of ZERO:\n     * const p = new Vector3();\n     * if (p.equals(Vector3.ZERO)) {\n     *   console.log(\"p is (0,0,0)\")\n     * }\n     * \n     * // Dangerous use of ZERO!!!!\n     * const p = Vector3.ZERO;  // makes p a reference to Vector3.ZERO\n     * p.add(new Vector3(1, 0, 0)); // changes Vector3.ZERO!\n     * \n     * // Do this instead:\n     * const p = Vector3.copy(Vector3.ZERO); // or \"new Vector3();\" or another function that returns a NEW Vector3 object\n     * p.add(new Vector3(1, 0, 0));\n     */\n    public static readonly ZERO = new Vector3(0, 0, 0);\n\n    /**\n     * A Vector3 object with all one values.  (See note in the Vector3.ZERO docs for important usage info.)\n     */\n    public static readonly ONE = new Vector3(1, 1, 1);\n\n    /**\n     * A Vector3 object that points up.  (See note in the Vector3.ZERO docs for important usage info.)\n     */\n    public static readonly UP = new Vector3(0, 1, 0);\n\n    /**\n     * A Vector3 object that points down.  (See note in the Vector3.ZERO docs for important usage info.)\n     */\n    public static readonly DOWN = new Vector3(0, -1, 0);\n\n    /**\n     * A Vector3 object that points left.  (See note in the Vector3.ZERO docs for important usage info.)\n     */\n    public static readonly LEFT = new Vector3(-1, 0, 0);\n\n    /**\n     * A Vector3 object that points right.  (See note in the Vector3.ZERO docs for important usage info.)\n     */\n    public static readonly RIGHT = new Vector3(1, 0, 0);\n\n    /**\n     * A Vector3 object that points forward.  (See note in the Vector3.ZERO docs for important usage info.)\n     */\n    public static readonly FORWARD = new Vector3(0, 0, -1);\n\n    /**\n     * A Vector3 object that points backward.  (See note in the Vector3.ZERO docs for important usage info.)\n     */\n    public static readonly BACK = new Vector3(0, 0, 1);\n\n    /**\n     * A Vector3 object that points along the x-axis.  (See note in the Vector3.ZERO docs for important usage info.)\n     */\n    public static readonly X_AXIS = Vector3.RIGHT;\n\n    /**\n     * A Vector3 object that points along the y-axis.  (See note in the Vector3.ZERO docs for important usage info.)\n     */\n    public static readonly Y_AXIS = Vector3.UP;\n\n    /**\n     * A Vector3 object that points along the z-axis.  (See note in the Vector3.ZERO docs for important usage info.)\n     */\n    public static readonly Z_AXIS = Vector3.FORWARD;\n\n\n    \n    /**\n     * Copies the values of a Vector3 object\n     * \n     * @param v - The Vector3 object to copy\n     * @returns A new Vector3 object with the same x, y, and z values as the original\n     */\n    public static copy(v: Vector3): Vector3\n    {\n        return new Vector3(v.x, v.y, v.z);\n    }\n\n    /**\n     * Inverts the direction of a Vector3 object\n     * \n     * @param v - The Vector3 object to invert\n     * @returns A new Vector3 object with the opposite direction of the original\n     */\n    public static inverse(v: Vector3): Vector3\n    {\n        return new Vector3(-v.x, -v.y, -v.z);\n    }\n\n    /**\n     * Adds two Vector3 objects together\n     * \n     * @param v1 - The first Vector3 object\n     * @param v2 - The second Vector3 object\n     * @returns A new Vector3 object with the x, y, and z values equal to the sum of the corresponding values of the input vectors\n     */\n    public static add(v1: Vector3, v2: Vector3): Vector3\n    {\n        return new Vector3(v1.x + v2.x, v1.y + v2.y, v1.z + v2.z);\n    }\n\n    /**\n     * Subtracts two Vector3 objects\n     * \n     * @param v1 - The Vector3 object to subtract from\n     * @param v2 - The Vector3 object to subtract\n     * @returns A new Vector3 object with the x, y, and z values equal to the difference of the corresponding values of the input vectors\n     */\n    public static subtract(v1: Vector3, v2: Vector3): Vector3\n    {\n        return new Vector3(v1.x - v2.x, v1.y - v2.y, v1.z - v2.z);\n    }\n\n    /**\n     * Multiply two Vector3 objects\n     * \n     * @param v1 - The first Vector3 object\n     * @param v2 - The second Vector3 object\n     * @returns A new Vector3 object with the x, y, and z values equal to the product of the corresponding values of the input vectors\n     */\n    public static multiply(v1: Vector3, v2: Vector3): Vector3\n    {\n        return new Vector3(v1.x * v2.x, v1.y * v2.y, v1.z * v2.z);\n    }\n\n    /**\n     * Divide two Vector3 objects\n     * \n     * @param v1 - The Vector3 object to divide\n     * @param v2 - The Vector3 object to divide by\n     * @returns A new Vector3 object with the x, y, and z values equal to the quotient of the corresponding values of the input vectors\n     */\n    public static divide(v1: Vector3, v2: Vector3): Vector3\n    {\n        return new Vector3(v1.x / v2.x, v1.y / v2.y, v1.z / v2.z);\n    }\n\n    /**\n     * Computes the dot product of two Vector3 objects\n     * \n     * @param v1 - The first Vector3 object\n     * @param v2 - The second Vector3 object\n     * @returns The dot product of the two input vectors\n     */\n    public static dot(v1: Vector3, v2: Vector3): number\n    {\n        return v1.x*v2.x + v1.y*v2.y + v1.z*v2.z;\n    }\n\n    /**\n     * Computes the cross product of two Vector3 objects\n     * \n     * @param v1 - The first Vector3 object\n     * @param v2 - The second Vector3 object\n     * @returns A new Vector3 object representing the cross product of the two input vectors\n     */\n    public static cross(v1: Vector3, v2: Vector3): Vector3\n    {\n        return new Vector3(\n            v1.y * v2.z - v1.z * v2.y,\n            v1.z * v2.x - v1.x * v2.z,\n            v1.x * v2.y - v1.y * v2.x\n        );\n    }\n\n    /**\n     * Multiplies a Vector3 object with a scalar value\n     * \n     * @param v - The Vector3 object\n     * @param n - The scalar value\n     * @returns A new Vector3 object with the x, y, and z values multiplied by the scalar value\n     */\n    public static multiplyScalar(v: Vector3, n: number): Vector3\n    {\n        return new Vector3(v.x * n, v.y * n, v.z * n);\n    }\n\n    /**\n     * Divides a Vector3 object by a scalar value\n     * \n     * @param v - The Vector3 object\n     * @param n - The scalar value\n     * @returns A new Vector3 object with the x, y, and z values divided by the scalar value\n     */\n    public static divideScalar(v: Vector3, n: number): Vector3\n    {\n        return new Vector3(v.x / n, v.y / n, v.z / n);\n    }\n\n    /**\n     * Normalizes a Vector3 object\n     * \n     * @param v - The Vector3 object\n     * @returns A new Vector3 object with a magnitude of 1, pointing in the same direction as the original vector\n     *          If the original vector is a zero vector, returns a new zero vector\n     */\n    public static normalize(v: Vector3): Vector3\n    {\n        const sizeSquared = v.x*v.x + v.y*v.y + v.z*v.z;\n        \n        // zero vectors\n        if(sizeSquared < 1e-8)\n            return new Vector3();\n\n        const scaleFactor = 1 / Math.sqrt(sizeSquared);\n        return new Vector3(v.x * scaleFactor, v.y * scaleFactor, v.z * scaleFactor);\n    }\n\n    /**\n     * Computes the angle in radians between two Vector3 objects\n     * \n     * @param v1 - The first Vector3 object\n     * @param v2 - The second Vector3 object\n     * @returns The angle in radians between the two input vectors\n     */\n    public static angleBetween(v1: Vector3, v2: Vector3): number\n    {\n        return v1.angleBetween(v2);\n    }\n\n    /**\n     * Computes the distance between two Vector3 objects\n     * \n     * @param v1 - The first Vector3 object\n     * @param v2 - The second Vector3 object\n     * @returns The distance between the two input vectors\n     */\n    public static distanceBetween(v1: Vector3, v2: Vector3): number\n    {\n        return v1.distanceTo(v2);\n    }\n\n    /**\n     * Rotates a Vector3 object by a Quaternion\n     *\n     * @param v - The Vector3 object to rotate\n     * @param q - The Quaternion object to rotate the Vector3 by\n     * @returns A new Vector3 object that represents the result of rotating v by q\n     */\n    public static rotate(v: Vector3, q: Quaternion): Vector3\n    {\n        // Extract the vector part of the quaternion\n        const u = new Vector3(q.x, q.y, q.z);\n\n        // vprime = 2.0f * dot(u, v) * u\n        const result = Vector3.multiplyScalar(u, 2 * u.dot(v));\n\n        // + (s*s - dot(u, u)) * v\n        result.add(Vector3.multiplyScalar(v, q.w * q.w - u.dot(u)));\n\n        const crossUV = Vector3.cross(u, v);\n        crossUV.multiplyScalar(2 * q.w);\n        result.add(crossUV);\n\n        return result;\n    }\n\n    /**\n     * Linearly interpolates between two Vector3 objects\n     *\n     * @param v1 - The first Vector3 object\n     * @param v2 - The second Vector3 object\n     * @param alpha - The interpolation value between 0 and 1\n     * @returns A new Vector3 object that represents the result of interpolating between v1 and v2\n     */\n    public static lerp(v1: Vector3, v2: Vector3, alpha: number): Vector3\n    {\n        return new Vector3(\n            v1.x * (1-alpha) + v2.x * alpha,\n            v1.y * (1-alpha) + v2.y * alpha,\n            v1.z * (1-alpha) + v2.z * alpha\n        );\n    }\n\n    /**\n     * Transforms a Vector3 object representing a point by a Matrix4\n     *\n     * @param v - The Vector3 object to transform\n     * @param m - The Matrix4 object to transform the Vector3 by\n     * @returns A new Vector3 object that represents the result of transforming point v by m\n     */\n    public static transformPoint(v: Vector3, m: Matrix4): Vector3\n    {\n        const result = new Vector3();\n        const w = 1 / (m.mat[3]*v.x + m.mat[7]*v.y + m.mat[11]*v.z + m.mat[15]);\n        result.x = w * (m.mat[0]*v.x + m.mat[4]*v.y + m.mat[8]*v.z + m.mat[12]);\n        result.y = w * (m.mat[1]*v.x + m.mat[5]*v.y + m.mat[9]*v.z + m.mat[13]);\n        result.z = w * (m.mat[2]*v.x + m.mat[6]*v.y + m.mat[10]*v.z + m.mat[14]);\n        return result;\n    }\n\n    /**\n     * Transforms a Vector3 object representing a direction by a Matrix4, ignoring the translation component\n     *\n     * @param v - The Vector3 object to transform\n     * @param m - The Matrix4 object to transform the Vector3 by\n     * @returns A new Vector3 object that represents the result of transforming direction v by m\n     */\n    public static transformVector(v: Vector3, m: Matrix4): Vector3\n    {\n        const result = new Vector3();\n        const w = 1 / (m.mat[3]*v.x + m.mat[7]*v.y + m.mat[11]*v.z + m.mat[15]);\n        result.x = w * (m.mat[0]*v.x + m.mat[4]*v.y + m.mat[8]*v.z);\n        result.y = w * (m.mat[1]*v.x + m.mat[5]*v.y + m.mat[9]*v.z);\n        result.z = w * (m.mat[2]*v.x + m.mat[6]*v.y + m.mat[10]*v.z);\n        return result;\n    }\n\n    /**\n     * Reflects a vector about a normal\n     *\n     * @param v - The vector to reflect\n     * @param n - The normal to reflect about\n     * @returns A new Vector3 object that represents the result of reflecting v about n\n     */\n    public static reflect(v: Vector3, n: Vector3): Vector3\n    {\n        const result = n.clone();\n        result.multiplyScalar(v.dot(n) * -2);\n        result.add(v);\n        return result;\n    }\n\n    /**\n     * Checks if the x,y,z components of two Vector3 objects are exactly equal.\n     *\n     * @param v1 - The first Vector3 object\n     * @param v2 - The second Vector3 object\n     * @returns A boolean value indicating if the Vector3 objects are equal\n     */\n    public static equals(v1: Vector3, v2: Vector3): boolean\n    {\n        return v1.x == v2.x && v1.y == v2.y && v1.z == v2.z;\n    }\n\n    /**\n     * Checks if the x,y,z components of two Vector3 objects are equal within a small value of epsilon.\n     *\n     * @param v1 - The first Vector3 object\n     * @param v2 - The second Vector3 object\n     * @param epsilon - A small value of acceptable variance to account for numerical instability\n     * @returns A boolean value indicating if the Vector3 objects are equal\n     */\n    public static fuzzyEquals(v1: Vector3, v2: Vector3, epsilon: number = MathUtils.EPSILON): boolean\n    {\n        return Math.abs(v1.x - v2.x) < epsilon && Math.abs(v1.y - v2.y) < epsilon && Math.abs(v1.z - v2.z) < epsilon;\n    }\n\n\n\n    public x: number;\n    public y: number;\n    public z: number;\n\n\n\n\n    /**\n     * Constructs a Vector3 object from x, y, and z values\n     *\n     * @param x - The x value for the Vector3\n     * @param y - The y value for the Vector3\n     * @param z - The z value for the Vector3\n     */\n    constructor(x = 0, y = 0, z = 0)\n    {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n\n    /**\n     * Sets the x, y, and z values of a Vector3 object\n     *\n     * @param x - The x value to set\n     * @param y - The y value to set\n     * @param z - The z value to set\n     */\n    set(x: number, y: number, z: number): void\n    {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n\n    /**\n     * Copies a Vector3 object\n     *\n     * @param v - The Vector3 object to copy\n     */\n    copy(v: Vector3): void\n    {\n        this.x = v.x;\n        this.y = v.y;\n        this.z = v.z;\n    }\n\n    /**\n     * Creates a new Vector3 object with the same x, y, and z values as this Vector3\n     *\n     * @returns The cloned Vector3 object\n     */\n    clone(): Vector3\n    {\n        return new Vector3(this.x, this.y, this.z);\n    }\n\n    /**\n     * Checks if the x,y,z components of this Vector3 are exactly equal to those of the given Vector3\n     *\n     * @param v - The Vector3 object to compare to\n     * @returns A boolean value indicating if the Vector3 objects are equal\n     */\n    equals(v: Vector3): boolean\n    {\n        return this.x == v.x && this.y == v.y && this.z == v.z;\n    }\n\n    /**\n     * Checks if the x,y,z components of this Vector3 are equal (within a small value of epsilon) \n     * to those of the given Vector3.\n     *\n     * @param v - The Vector3 object to compare to\n     * @param epsilon - A small value of acceptable variance to account for numerical instability\n     * @returns A boolean value indicating if the Vector3 objects are equal\n     */\n    fuzzyEquals(v: Vector3, epsilon: number = MathUtils.EPSILON): boolean\n    {\n        return Math.abs(this.x - v.x) < epsilon && Math.abs(this.y - v.y) < epsilon && Math.abs(this.z - v.z) < epsilon;\n    }\n\n    /**\n     * Adds the given Vector3 to this Vector3\n     *\n     * @param v - The Vector3 object to add\n     */\n    add(v: Vector3): void\n    {\n        this.x += v.x;\n        this.y += v.y;\n        this.z += v.z;\n    }\n\n    /**\n     * Subtracts the given Vector3 from this Vector3\n     *\n     * @param v - The Vector3 object to subtract\n     */\n    subtract(v: Vector3): void\n    {\n        this.x -= v.x;\n        this.y -= v.y;\n        this.z -= v.z;\n    }\n\n    /**\n     * Multiplies this Vector3 by the given Vector3\n     *\n     * @param v - The Vector3 object to multiply\n     */\n    multiply(v: Vector3): void\n    {\n        this.x *= v.x;\n        this.y *= v.y;\n        this.z *= v.z;\n    }\n\n    /**\n     * Divides each component of the vector with that of another vector\n     *\n     * @param v - Vector to divide with\n     */\n    divide(v: Vector3): void\n    {\n        this.x /= v.x;\n        this.y /= v.y;\n        this.z /= v.z;\n    }\n\n    /**\n     * Compute the dot product of two Vector3 objects\n     * \n     * @param v - The other Vector3 object\n     * @returns The dot product of the two Vector3 objects\n     */\n    dot(v: Vector3): number\n    {\n        return this.x*v.x + this.y*v.y + this.z*v.z;\n    }\n\n    /**\n     * Computes the cross product of two Vector3s and stores the result in the original Vector3.\n     *\n     * @param v The Vector3 to compute the cross product with.\n     */\n    cross(v: Vector3): void\n    {\n        const crossProduct =  new Vector3(\n            this.y * v.z - this.z * v.y,\n            this.z * v.x - this.x * v.z,\n            this.x * v.y - this.y * v.x\n        );\n        this.copy(crossProduct);\n    }\n\n    /**\n     * Multiplies each component of the vector with a scalar value\n     *\n     * @param n - Scalar value to multiply with\n     */\n    multiplyScalar(n: number): void\n    {\n        this.x *= n;\n        this.y *= n;\n        this.z *= n;\n    }\n\n    /**\n     * Divides each component of the vector with a scalar value\n     *\n     * @param n - Scalar value to divide with\n     */\n    divideScalar(n: number): void\n    {\n        this.x /= n;\n        this.y /= n;\n        this.z /= n;\n    }\n\n    /**\n     * Calculates the length of a Vector3 object\n     *\n     * @returns The length of the Vector3 object\n     */\n    length(): number\n    {\n        return Math.sqrt(this.x*this.x + this.y*this.y + this.z*this.z);\n    }\n\n    /**\n     * Normalizes a Vector3 object\n     *\n     */\n    normalize(): void\n    {\n        const sizeSquared = this.x*this.x + this.y*this.y + this.z*this.z;\n        \n        // zero vectors\n        if(sizeSquared < 1e-8)\n            return;\n\n        const scaleFactor = 1 / Math.sqrt(sizeSquared);\n        this.x *= scaleFactor;\n        this.y *= scaleFactor;\n        this.z *= scaleFactor;\n    }\n\n    /**\n     * Inverts a Vector3 object\n     *\n     */\n    invert(): void\n    {\n        this.x = -this.x;\n        this.y = -this.y;\n        this.z = -this.z;\n    }\n\n    /**\n     * Inverts a Vector3 object and returns the result as a new Vector3 object\n     *\n     */\n    inverse(): Vector3\n    {\n        return new Vector3(-this.x, -this.y, -this.z);\n    }\n\n\n    /**\n     * Transforms this Vector3 instance as a point with a given Matrix4\n     *\n     * @param m - The Matrix4 to transform this Vector3\n     */\n    transformPoint(m: Matrix4): void\n    {\n        const v = this.clone();\n        const w = 1 / (m.mat[3]*v.x + m.mat[7]*v.y + m.mat[11]*v.z + m.mat[15]);\n        this.x = w * (m.mat[0]*v.x + m.mat[4]*v.y + m.mat[8]*v.z + m.mat[12]);\n        this.y = w * (m.mat[1]*v.x + m.mat[5]*v.y + m.mat[9]*v.z + m.mat[13]);\n        this.z = w * (m.mat[2]*v.x + m.mat[6]*v.y + m.mat[10]*v.z + m.mat[14]);\n    }\n\n    /**\n     * Transforms this Vector3 instance as a direction with a given Matrix4, ignoring the translation component\n     *\n     * @param m - The Matrix4 to transform this Vector3\n     */\n    transformVector(m: Matrix4): void\n    {\n        const v = this.clone();\n        const w = 1 / (m.mat[3]*v.x + m.mat[7]*v.y + m.mat[11]*v.z + m.mat[15]);\n        this.x = w * (m.mat[0]*v.x + m.mat[4]*v.y + m.mat[8]*v.z);\n        this.y = w * (m.mat[1]*v.x + m.mat[5]*v.y + m.mat[9]*v.z);\n        this.z = w * (m.mat[2]*v.x + m.mat[6]*v.y + m.mat[10]*v.z);\n    }\n\n    /**\n     * Rotates this Vector3 instance by a given Quaternion\n     *\n     * @param q - The Quaternion to rotate this Vector3\n     */\n    rotate(q: Quaternion): void\n    {\n        // Extract the vector part of the quaternion\n        const u = new Vector3(q.x, q.y, q.z);\n\n        // vprime = 2.0f * dot(u, v) * u\n        const result = Vector3.multiplyScalar(u, 2 * u.dot(this));\n\n        // + (s*s - dot(u, u)) * v\n        result.add(Vector3.multiplyScalar(this, q.w * q.w - u.dot(u)));\n\n        const crossUV = Vector3.cross(u, this);\n        crossUV.multiplyScalar(2 * q.w);\n        result.add(crossUV);\n\n        this.copy(result);\n    }\n\n    /**\n     * Computes the angle between this Vector3 and another Vector3\n     *\n     * @param v - The second Vector3\n     * @returns The angle between the two Vectors\n     */\n    angleBetween(v: Vector3): number\n    {\n        const v1Norm = Vector3.normalize(this);\n        const v2Norm = Vector3.normalize(v);\n\n        return Math.acos(v1Norm.dot(v2Norm));\n    }\n\n    /**\n     * Computes the distance between this Vector3 and another Vector3\n     *\n     * @param v - The second Vector3\n     * @returns The distance between the two Vectors\n     */\n    distanceTo(v: Vector3): number\n    {\n        return Math.sqrt(\n            (this.x - v.x) * (this.x - v.x) + \n            (this.y - v.y) * (this.y - v.y) +\n            (this.z - v.z) * (this.z - v.z) \n        );\n    }\n\n    /**\n     * Sets this Vector3's position to the provided Matrix4's position\n     *\n     * @param m - The Matrix4 to get the position from\n     */\n    setPositionFromMatrix(m: Matrix4): void\n    {\n        this.x = m.mat[12];\n        this.y = m.mat[13];\n        this.z = m.mat[14];\n    }\n\n    /**\n     * Sets this Vector3's scale to the provided Matrix4's scale\n     *\n     * @param m - The Matrix4 to get the scale from\n     */\n    setScaleFromMatrix(m: Matrix4): void\n    {\n        this.x = Math.sqrt(m.mat[0]*m.mat[0] + m.mat[1]*m.mat[1] + m.mat[2]*m.mat[2]);\n        this.y = Math.sqrt(m.mat[4]*m.mat[4] + m.mat[5]*m.mat[5] + m.mat[6]*m.mat[6]);\n        this.z = Math.sqrt(m.mat[8]*m.mat[8] + m.mat[9]*m.mat[9] + m.mat[10]*m.mat[10]);\n    }\n\n    /**\n     * Linearly interpolates between two Vector3s\n     *\n     * @param v1 - The starting Vector3\n     * @param v2 - The ending Vector3\n     * @param alpha - The interpolation amount (should be in the range [0, 1])\n     */\n    lerp(v1: Vector3, v2: Vector3, alpha: number): void\n    {\n        this.x = v1.x * (1-alpha) + v2.x * alpha;\n        this.y = v1.y * (1-alpha) + v2.y * alpha;\n        this.z = v1.z * (1-alpha) + v2.z * alpha;\n    }\n\n    /**\n     * Reflects this vector about a normal\n     *\n     * @param n - The normal to reflect about\n     */\n    reflect(normal: Vector3): void\n    {\n        const reflection = normal.clone();\n        reflection.multiplyScalar(this.dot(normal) * -2);\n        reflection.add(this);\n        this.copy(reflection);\n    }\n}", "import { Vector3 } from \"./Vector3\";\nimport { Matrix4 } from \"./Matrix4\";\n\n/**\n * This class holds a quaternion rotation.  It includes routines for using the quaternion to \n * rotate points and vectors.  It includes routines for constructing many common rotations and inverting\n * the rotation as well as accessing the underlying x,y,z,w components of the quaterion.\n * \n * Most of the functions in the class are defined both as member functions that can be called on a specific\n * instance of Quaternion *and* as static functions.  The static functions return a *new* result, leaving the\n * original inputs unchanged, whereas, in general, member functions save the result in the quaternion itself\n * and return void:\n * ```\n * const Q1 = Quaternion.makeRotationX(Math.PI);\n * const Q2 = Quaternion.makeRotationY(Math.PI);\n * \n * // save the result in Q3, leaving Q1 and Q2 unchanged\n * const Q3 = Quaternion.multiply(Q1, Q2);\n * \n * // each call to multiply overwrites the previous contents of Q4 with the result of the multiplication\n * const Q4 = Quaternion.makeRotationZ(Math.PI);\n * Q4.multiply(Q1);\n * Q4.multiply(Q2);\n * ```\n */\nexport class Quaternion\n{\n    /**\n     * A static property to provide quick access to the identity quaternion (0, 0, 0, 1).\n     * (Note: Be careful not to change the value of this field!  It is marked readonly, but typescipt do not completely\n     * enforce this!)\n     * ```\n     * // Good use of IDENTITY:\n     * const q = Quaternion();\n     * if (q.equals(Quaternion.IDENTITY)) {\n     *   console.log(\"q equals the identity quaternion\")\n     * }\n     * \n     * // Dangerous use of IDENTITY!!!!\n     * const q = Quaternion.IDENTITY;  // makes q a reference to Quaternion.IDENTITY\n     * q.makeRotationZ(Math.PI); // changes Quaternion.IDENTITY!\n     * \n     * // Do this instead:\n     * const q = Quaternion.makeIdentity(); // create a new identity matrix M\n     * q.makeRotationZ(Math.PI);\n     */\n    public static readonly IDENTITY: Quaternion = new Quaternion();\n\n    /**\n     * Creates a new quaternion and copies the x,y,z,w values of the input into it.\n     * \n     * @param q - The Quaternion object to copy\n     * @returns A new Quaternion object with the same values as q\n     */\n    public static copy(q: Quaternion): Quaternion\n    {\n        return new Quaternion(q.x, q.y, q.z, q.w);\n    }\n\n    /**\n     * Multiplies two Quaternion objects together and returns a new quaternion = q1 * q2\n     * Note: multiplication of quaternions is not commutative, so order matters.  See\n     * premultiply() to do the opposite order, or just switch the order of the arguments.\n     * \n     * @param q1 - The first Quaternion object\n     * @param q2 - The second Quaternion object\n     * @returns A new Quaternion object representing the product of q1 and q2\n     */\n    public static multiply(q1: Quaternion, q2: Quaternion): Quaternion\n    {\n        const dest = new Quaternion();\n\n        dest.w = q1.w*q2.w - q1.x*q2.x - q1.y*q2.y - q1.z*q2.z;\n        dest.x = q1.w*q2.x + q1.x*q2.w + q1.y*q2.z - q1.z*q2.y;\n        dest.y = q1.w*q2.y + q1.y*q2.w + q1.z*q2.x - q1.x*q2.z;\n        dest.z = q1.w*q2.z + q1.z*q2.w + q1.x*q2.y - q1.y*q2.x;\n\n        return dest;\n    }\n\n    /**\n     * Premultiplies two Quaternion objects and returns a new quaternion = q2 * q1\n     * Note: multiplication of quaternions is not commutative, so order matters.  See\n     * multiply() to do the opposite order, or just switch the order of the arguments.\n     * \n     * @param q1 - The first Quaternion object\n     * @param q2 - The second Quaternion object\n     * @returns A new Quaternion object which is the result of the premultiplication of the two input Quaternion objects\n     */\n    public static premultiply(q1: Quaternion, q2: Quaternion): Quaternion\n    {\n        const dest = new Quaternion();\n\n        dest.w = q2.w*q1.w - q2.x*q1.x - q2.y*q1.y - q2.z*q1.z;\n        dest.x = q2.w*q1.x + q2.x*q1.w + q2.y*q1.z - q2.z*q1.y;\n        dest.y = q2.w*q1.y + q2.y*q1.w + q2.z*q1.x - q2.x*q1.z;\n        dest.z = q2.w*q1.z + q2.z*q1.w + q2.x*q1.y - q2.y*q1.x;\n\n        return dest;\n    }\n\n    /**\n     * Returns a new quaternion that is a normalized version of the input quaternion.\n     * \n     * @param q - The Quaternion object to normalize\n     * @returns A new Quaternion object with normalized values\n     */\n    public static normalize(q: Quaternion): Quaternion\n    {\n        const dest = q.clone();\n        dest.normalize();\n        return dest;\n    }\n\n    /**\n     * Returns a new quaternion that is the inverse (opposite rotation) of the input quaternion.\n     * \n     * @param q - The Quaternion object to invert\n     * @returns A new Quaternion object representing the inverse of q\n     */\n    public static inverse(q: Quaternion): Quaternion\n    {\n        const dest = q.clone();\n        dest.invert();\n        return dest;\n    }\n\n    /**\n     * Creates a new identity Quaternion object\n     * \n     * @returns A new Quaternion object representing the identity Quaternion (0, 0, 0, 1)\n     */\n    makeIdentity(): Quaternion\n    {\n        return new Quaternion(0, 0, 0, 1);\n    }\n\n    /**\n     * Creates a new Quaternion object representing a rotation around the x-axis\n     * \n     * @param angle - The angle to rotate by around the x-axis (in radians)\n     * @returns A new Quaternion object representing a rotation around the x-axis\n     */\n    public static makeRotationX(angle: number): Quaternion\n    {\n        const dest = new Quaternion();\n        dest.setRotationX(angle);\n        return dest;\n    }\n\n    /**\n     * Creates a new Quaternion object representing a rotation around the y-axis\n     * \n     * @param angle - The angle to rotate by around the y-axis (in radians)\n     * @returns A new Quaternion object representing a rotation around the y-axis\n     */\n    public static makeRotationY(angle: number): Quaternion\n    {\n        const dest = new Quaternion();\n        dest.setRotationY(angle);\n        return dest;\n    }\n\n    /**\n     * Creates a new Quaternion object representing a rotation around the z-axis\n     * \n     * @param angle - The angle to rotate by around the z-axis (in radians)\n     * @returns A new Quaternion object representing a rotation around the z-axis\n     */\n    public static makeRotationZ(angle: number): Quaternion\n    {\n        const dest = new Quaternion();\n        dest.setRotationZ(angle);\n        return dest;\n    }\n\n    /**\n     * Creates a new quaternion to represent a rotation of angle radians around axis.\n     * \n     * @param axis - The axis to rotate around\n     * @param angle - The angle of rotation\n     * @returns A new Quaternion\n     */\n    public static makeAxisAngle(axis: Vector3, angle: number): Quaternion\n    {\n        const dest = new Quaternion();\n        dest.setAxisAngle(axis, angle);\n        return dest;\n    }\n\n    /**\n     * Creates a new quaternion from given Euler angles\n     * \n     * @param x - The x-axis rotation angle\n     * @param y - The y-axis rotation angle\n     * @param z - The z-axis rotation angle\n     * @param order - The order of the rotations (defaults to 'YZX')\n     * @returns A new Quaternion\n     */\n    public static makeEulerAngles(x: number, y: number, z: number, order = 'YZX'): Quaternion\n    {\n        const dest = new Quaternion();\n        dest.setEulerAngles(x, y, z, order);\n        return dest;\n    }\n\n    /**\n     * Creates a new quaternion with a rotation like that used to orient a camera.  The quaternion will rotate the \n     * -Z direction (typically, the \"forward\" direction for objects and the default \"look\" direction for cameras)\n     * to point in the new \"look\" direction defined by the vector (targetPoint - eyePoint).  The up vector is used\n     * to further constrain the rotation.  The original Y direction will rotate to point, as much as possible,\n     * toward the upVector.\n     * \n     * @param eyePoint - The position of the camera or other object being oriented\n     * @param targetPoint - The point to look at\n     * @param up - The direction that the original +Y direction should rotate into (as closely as possible).\n     * @returns A new Quaternion that performs the specified rotation\n     */\n    public static lookAt(eyePoint: Vector3, targetPoint: Vector3, upVector = Vector3.UP): Quaternion\n    {\n        const z = Vector3.subtract(eyePoint, targetPoint);\n        z.normalize();\n\n        const x = Vector3.cross(upVector, z);\n        x.normalize();\n\n        const y = Vector3.cross(z, x);\n        y.normalize();\n\n        const m = new Matrix4();\n        m.setRowMajor(\n            x.x, y.x, z.x, 0,\n            x.y, y.y, z.y, 0,\n            x.z, y.z, z.z, 0,\n            0, 0, 0, 1\n        );\n        return Quaternion.makeMatrix(m);\n    }\n\n    /**\n     * Creates a new quaternion with the same rotation as in the provided 4x4 transformation matrix.\n     * \n     * @param matrix - A 4x4 transformation matrix that includes a rotation.\n     * @returns A new Quaternion that specifies the same rotation\n     */\n    public static makeMatrix(matrix: Matrix4): Quaternion\n    {\n        const dest = new Quaternion();\n        dest.setMatrix(matrix);\n        return dest;\n    }\n\n    /**\n     * Returns a Quaternion from two input Quaternions using spherical linear interpolation.\n     * \n     * @param q1 - The first Quaternion\n     * @param q2 - The second Quaternion\n     * @param alpha - The interpolation factor\n     * @returns A new Quaternion representing the slerp between q1 and q2\n     */\n    public static slerp(q1: Quaternion, q2: Quaternion, alpha: number): Quaternion\n    {\n        const q = new Quaternion();\n        q.slerp(q1, q2, alpha);\n        return q;\n    }\n\n    /**\n     * Rotates a 3D point or 3D vector by the specified quaternion and returns the result in a new Vector3\n     * \n     * @param v The original 3D point or 3D vector\n     * @param q The rotation to apply\n     * @returns A new 3D point or 3D vector\n     */\n    public static rotate(v: Vector3, q: Quaternion): Vector3\n    {\n        // Extract the vector part of the quaternion\n        const u = new Vector3(q.x, q.y, q.z);\n\n        // vprime = 2.0f * dot(u, v) * u\n        const result = Vector3.multiplyScalar(u, 2 * u.dot(v));\n\n        // + (s*s - dot(u, u)) * v\n        result.add(Vector3.multiplyScalar(v, q.w * q.w - u.dot(u)));\n\n        const crossUV = Vector3.cross(u, v);\n        crossUV.multiplyScalar(2 * q.w);\n        result.add(crossUV);\n\n        return result;\n    }\n    \n    public x: number;\n    public y: number;\n    public z: number;\n    public w: number;\n\n\n    /**\n     * Creates a new Quaternion object with zero rotation (i.e., the identity quaternion)\n     * \n     * @param x - The x component of the Quaternion\n     * @param y - The y component of the Quaternion\n     * @param z - The z component of the Quaternion\n     * @param w - The w component of the Quaternion\n     */\n    constructor(x = 0, y = 0, z = 0, w = 1)\n    {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n        this.w = w;\n    }\n\n    /**\n     * Sets the x,y,z,w components of the quaternion to the given x, y, z, and w values\n     * \n     * @param x - The x value\n     * @param y - The y value\n     * @param z - The z value\n     * @param w - The w value\n     */\n    set(x: number, y: number, z: number, w: number): void\n    {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n        this.w = w;\n    }\n\n    \n    /**\n     * Sets the quaternion to the identity quaternion\n     */\n    setIdentity(): void\n    {\n        this.x = 0;\n        this.y = 0;\n        this.z = 0;\n        this.w  = 1;\n    }\n\n    /**\n     * Sets the quaternion to a rotation around the x axis\n     * \n     * @param angle - The angle of rotation in radians\n     */\n    setRotationX(angle: number): void\n    {\n        this.w = Math.cos(angle / 2);\n        this.x = Math.sin(angle / 2);\n        this.y = 0;\n        this.z = 0;\n    }\n\n    /**\n     * Sets the quaternion to a rotation around the y axis\n     * \n     * @param angle - The angle of rotation in radians\n     */\n    setRotationY(angle: number): void\n    {\n        this.w = Math.cos(angle / 2);\n        this.x = 0;\n        this.y = Math.sin(angle / 2);\n        this.z = 0;\n    }\n\n    /**\n     * Sets the quaternion to a rotation around the z axis\n     * \n     * @param angle - The angle of rotation in radians\n     */\n    setRotationZ(angle: number): void\n    {\n        this.w = Math.cos(angle / 2);\n        this.x = 0;\n        this.y = 0;\n        this.z = Math.sin(angle / 2);\n    }\n\n    /**\n     * Sets the quaternion to a rotation around axis by angle radians.  Note, the axis parameter must be a unit vector.\n     * \n     * @param axis - A unit vector that describes the axis of rotation\n     * @param angle - The angle of rotation in radians\n     */\n    setAxisAngle(axis: Vector3, angle: number): void\n    {\n        // Based on the approached described here\n        // http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm\n\n        const sinAngle = Math.sin(angle / 2);\n\n        this.w = Math.cos(angle / 2);\n        this.x = sinAngle * axis.x;\n        this.y = sinAngle * axis.y;\n        this.z = sinAngle * axis.z;\n    }\n\n    /**\n     * Sets the quaternion to the rotation specified by the provied Euler angles and order of rotation\n     * \n     * @param x - The x-axis rotation angle in radians\n     * @param y - The y-axis rotation angle in radians\n     * @param z - The z-axis rotation angle in radians\n     * @param order - The order in which the rotation angles are applied (defaults to 'YZX')\n     */\n    setEulerAngles(x: number, y: number, z: number, order = 'YZX'): void\n    {\n        // Based on the implementation in three.js\n\n\t\tconst cos = Math.cos;\n\t\tconst sin = Math.sin;\n\n\t\tconst c1 = cos( x / 2 );\n\t\tconst c2 = cos( y / 2 );\n\t\tconst c3 = cos( z / 2 );\n\n\t\tconst s1 = sin( x / 2 );\n\t\tconst s2 = sin( y / 2 );\n\t\tconst s3 = sin( z / 2 );\n\n\t\tswitch ( order ) \n        {\n\t\t\tcase 'XYZ':\n\t\t\t\tthis.x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\t\tthis.y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\t\tthis.z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\t\tthis.w = c1 * c2 * c3 - s1 * s2 * s3;\n\t\t\t\tbreak;\n\n\t\t\tcase 'YXZ':\n\t\t\t\tthis.x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\t\tthis.y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\t\tthis.z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\t\tthis.w = c1 * c2 * c3 + s1 * s2 * s3;\n\t\t\t\tbreak;\n\n\t\t\tcase 'ZXY':\n\t\t\t\tthis.x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\t\tthis.y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\t\tthis.z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\t\tthis.w = c1 * c2 * c3 - s1 * s2 * s3;\n\t\t\t\tbreak;\n\n\t\t\tcase 'ZYX':\n\t\t\t\tthis.x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\t\tthis.y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\t\tthis.z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\t\tthis.w = c1 * c2 * c3 + s1 * s2 * s3;\n\t\t\t\tbreak;\n\n\t\t\tcase 'YZX':\n\t\t\t\tthis.x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\t\tthis.y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\t\tthis.z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\t\tthis.w = c1 * c2 * c3 - s1 * s2 * s3;\n\t\t\t\tbreak;\n\n\t\t\tcase 'XZY':\n\t\t\t\tthis.x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\t\tthis.y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\t\tthis.z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\t\tthis.w = c1 * c2 * c3 + s1 * s2 * s3;\n\t\t\t\tbreak;\n\t\t}\n    }\n\n    /**\n     * Sets the quaternion to a rotation equal to the one in the provided 4x4 rotation matrix\n     * \n     * @param matrix - A 4x4 rotation matrix\n     */\n    setMatrix(matrix: Matrix4): void\n    {\n        // Based on implementation described here:\n        // https://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/\n\n        const trace = matrix.mat[0] + matrix.mat[5] + matrix.mat[10]\n\n        if (trace > 0) \n        { \n            const s = Math.sqrt(trace + 1.0) * 2;  \n            this.w = 0.25 * s;\n            this.x = (matrix.mat[6] - matrix.mat[9]) / s;\n            this.y = (matrix.mat[8] - matrix.mat[2]) / s; \n            this.z = (matrix.mat[1] - matrix.mat[4]) / s; \n        } \n        else if ((matrix.mat[0] > matrix.mat[5]) && (matrix.mat[0] > matrix.mat[10]))\n        { \n            const s = Math.sqrt(1.0 + matrix.mat[0] - matrix.mat[5] - matrix.mat[10]) * 2; \n            this.w = (matrix.mat[6] - matrix.mat[9]) / s;\n            this.x = 0.25 * s;\n            this.y = (matrix.mat[4] + matrix.mat[1]) / s; \n            this.z = (matrix.mat[8] + matrix.mat[2]) / s; \n        } \n        else if (matrix.mat[5] > matrix.mat[10]) \n        { \n            const s = Math.sqrt(1.0 + matrix.mat[5] - matrix.mat[0] - matrix.mat[10]) * 2; \n            this.w = (matrix.mat[8] - matrix.mat[2]) / s;\n            this.x = (matrix.mat[4] + matrix.mat[1]) / s; \n            this.y = 0.25 * s;\n            this.z = (matrix.mat[9] + matrix.mat[6]) / s; \n        } \n        else \n        { \n            const s = Math.sqrt(1.0 + matrix.mat[10] - matrix.mat[0] - matrix.mat[5]) * 2; \n            this.w = (matrix.mat[1] - matrix.mat[4]) / s;\n            this.x = (matrix.mat[8] + matrix.mat[2]) / s;\n            this.y = (matrix.mat[9] + matrix.mat[6]) / s;\n            this.z = 0.25 * s;\n        }\n    }\n\n    /**\n     * Copies the x,y,z,w components of another quaternion into this one\n     * \n     * @param q - The quaternion to copy\n     */\n    copy(q: Quaternion): void\n    {\n        this.x = q.x;\n        this.y = q.y;\n        this.z = q.z;\n        this.w = q.w;\n    }\n\n    /**\n     * Creates a new quaternion with the same values as this one\n     * \n     * @returns A new quaternion with the same values as this one\n     */\n    clone(): Quaternion\n    {\n        return new Quaternion(this.x, this.y, this.z, this.w);\n    }\n\n    /**\n     * Multiply this quaternion with the input quaternion and save the result in this quaternion.\n     * i.e., this = this * q  Quaternion multiplication is not commutative, so order matters.\n     * See premultiply() to do the multiplication in the opposite order.\n     * \n     * @param q - The quaternion to multiply with\n     */\n    multiply(q: Quaternion): void\n    {\n        this.copy(Quaternion.multiply(this, q));\n    }\n\n    /**\n     * Premultiply this quaternion with the input quaternion and save the result in this quaternion.\n     * i.e., this = q * this.  This operation is not commutative, so order matters;  See multiply()\n     * to do the multiplication in the opposite order.\n     * \n     * @param q - The quaternion to premultiply with\n     */\n    premultiply(q: Quaternion): void\n    {\n        this.copy(Quaternion.multiply(q, this));\n    }\n\n    /**\n     * Normalize this quaternion and save the result in this quaternion.\n     */\n    normalize(): void\n    {\n        const normalizeFactor = 1 / Math.sqrt(this.x * this.x + this.y * this.y +\n            this.z * this.z + this.w * this.w);\n\n        this.x *= normalizeFactor;\n        this.y *= normalizeFactor;\n        this.z *= normalizeFactor;\n        this.w *= normalizeFactor;\n    }\n\n    /**\n     * Inverts the quaternion and save the result in this quaternion.\n     */\n    invert(): void\n    {\n        const normalizeFactor = 1 / Math.sqrt(this.x * this.x + this.y * this.y +\n            this.z * this.z + this.w * this.w);\n\n        this.x *= -normalizeFactor;\n        this.y *= -normalizeFactor;\n        this.z *= -normalizeFactor;\n        this.w *= normalizeFactor;\n    }\n\n    /**\n     * Computes the inverse of this quaternion and returns the result in a new quaternion.\n     * \n     * @returns The inverse of this Quaternion\n     */\n    inverse(): Quaternion\n    {\n        return Quaternion.inverse(this);\n    }\n\n    /**\n     * Converts this quaternion into an equivalent 4x4 rotation matrix and returns the result.\n     * \n     * @returns A 4x4 rotation matrix representation of this Quaternion\n     */\n    getMatrix(): Matrix4\n    {\n        // Based on implementation described at\n        // http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToMatrix/index.htm\n        const sqw = this.w*this.w;\n        const sqx = this.x*this.x;\n        const sqy = this.y*this.y;\n        const sqz = this.z*this.z;\n\n        // invs (inverse square length) is only required if quaternion is not already normalised\n        const invs = 1 / (sqx + sqy + sqz + sqw);\n\n        const tmp1 = this.x*this.y;\n        const tmp2 = this.z*this.w;\n        const tmp3 = this.x*this.z;\n        const tmp4 = this.y*this.w;\n        const tmp5 = this.y*this.z;\n        const tmp6 = this.x*this.w;\n        \n        return Matrix4.fromRowMajor(\n            ( sqx - sqy - sqz + sqw)*invs, 2 * (tmp1 - tmp2)*invs, 2 * (tmp3 + tmp4)*invs, 0,\n            2 * (tmp1 + tmp2)*invs, (-sqx + sqy - sqz + sqw)*invs, 2 * (tmp5 - tmp6)*invs, 0,\n            2 * (tmp3 - tmp4)*invs, 2 * (tmp5 + tmp6)*invs, (-sqx - sqy + sqz + sqw), 0,\n            0, 0, 0, 1\n        );\n    }\n\n    /**\n     * Sets the quaternion to rotate the vector `eye` to point towards `target`\n     * \n     * @param eye - The vector representing the starting point\n     * @param target - The vector representing the target point\n     * @param up - The vector representing the up direction (defaults to Vector3.UP)\n     */\n\n    /**\n     * Sets this quaternion to a rotation like that used to orient a camera.  The quaternion will rotate the \n     * -Z direction (typically, the \"forward\" direction for objects and the default \"look\" direction for cameras)\n     * to point in the new \"look\" direction defined by the vector (targetPoint - eyePoint).  The up vector is used\n     * to further constrain the rotation.  The original Y direction will rotate to point, as much as possible,\n     * toward the upVector.\n     * \n     * @param eyePoint - The position of the camera or other object being oriented\n     * @param targetPoint - The point to look at\n     * @param upVector - The direction that the original +Y direction should rotate into (as closely as possible).\n     */\n    lookAt(eyePoint: Vector3, targetPoint: Vector3, upVector = Vector3.UP): void\n    {\n        const z = Vector3.subtract(eyePoint, targetPoint);\n        z.normalize();\n\n        const x = Vector3.cross(upVector, z);\n        x.normalize();\n\n        const y = Vector3.cross(z, x);\n        y.normalize();\n\n        const m = new Matrix4();\n        m.setRowMajor(\n            x.x, y.x, z.x, 0,\n            x.y, y.y, z.y, 0,\n            x.z, y.z, z.z, 0,\n            0, 0, 0, 1\n        );\n        this.setMatrix(m);\n    }\n\n    /**\n     * Sets this quaternion to an interpolation between two quaternions, q1 and q2, based on the given `alpha` value\n     * \n     * @param q1 - The starting quaternion\n     * @param q2 - The ending quaternion\n     * @param alpha - The interpolation value (0-1)\n     */\n    slerp(q1: Quaternion, q2: Quaternion, alpha: number): void\n    {\n        // based on VRPN implementation\n        // https://github.com/vrpn/vrpn/blob/master/quat/quat.c\n        const temp = q1.clone();\n\n        let cosOmega = q1.x*q2.x + q1.y*q2.y + q1.z*q2.z + q1.w*q2.w;\n        let omega, sinOmega, startScale, endScale;\n\n        // If the above dot product is negative, it would be better to\n        // go between the negative of the initial and the final, so that\n        // we take the shorter path.  \n        if(cosOmega < 0)\n        {\n            cosOmega *= -1;\n            temp.x *= -1;\n            temp.y *= -1;\n            temp.z *= -1;\n            temp.w *= -1;\n        }\n\n        if((1 + cosOmega) > 0.00001)\n        {\n            // usual case\n            if((1 - cosOmega) > 0.00001)\n            {\n                omega = Math.acos(cosOmega);\n                sinOmega = Math.sin(omega);\n                startScale = Math.sin((1 - alpha) * omega) / sinOmega;\n                endScale = Math.sin(alpha * omega) / sinOmega;\n            }\n            // ends very close\n            else\n            {\n                startScale = 1 - alpha;\n                endScale = alpha;\n            }\n\n            this.x = startScale * temp.x + endScale * q2.x;\n            this.y = startScale * temp.y + endScale * q2.y;\n            this.z = startScale * temp.z + endScale * q2.z;\n            this.w = startScale * temp.w + endScale * q2.w;\n        }\n        // ends nearly opposite\n        else\n        {\n            this.x = -temp.y;\n            this.y = temp.x;\n            this.z = -temp.w;\n            this.w = temp.z;\n\n            startScale = Math.sin((0.5 - alpha) * Math.PI);\n            endScale = Math.sin(alpha * Math.PI);\n\n            this.x = startScale * temp.x + endScale * this.x;\n            this.y = startScale * temp.y + endScale * this.y;\n            this.z = startScale * temp.y + endScale * this.z;\n        }\n    }\n\n    /**\n     * Rotates a 3D point or 3D vector by this quaternion and returns the result in a new Vector3\n     * \n     * @param v The original 3D point or 3D vector\n     * @returns A new 3D point or 3D vector\n     */\n    public rotate(v: Vector3): Vector3\n    {\n        // Extract the vector part of the quaternion\n        const u = new Vector3(this.x, this.y, this.z);\n\n        // vprime = 2.0f * dot(u, v) * u\n        const result = Vector3.multiplyScalar(u, 2 * u.dot(v));\n\n        // + (s*s - dot(u, u)) * v\n        result.add(Vector3.multiplyScalar(v, this.w * this.w - u.dot(u)));\n\n        const crossUV = Vector3.cross(u, v);\n        crossUV.multiplyScalar(2 * this.w);\n        result.add(crossUV);\n\n        return result;\n    }\n}", "import { Vector3 } from \"./Vector3\";\nimport { Quaternion } from \"./Quaternion\";\nimport { MathUtils } from \"./MathUtils\";\n\n/**\n * This class holds a 4x4 transformation matrix.  It includes routines for using the matrix to \n * transform points and vectors.  It includes routines for constructing many common types of matrices\n * (see make*), for inverting the matrix, and for accessing the underlying 16-elements by row, column.\n * \n * Most of the functions in the class are defined both as member functions that can be called on a specific\n * instance of Vector3 *and* as static functions.  The static functions return a *new* result, leaving the\n * original inputs unchanged, whereas, in general, member functions save the result in the matrix itself\n * and return void:\n * ```\n * const T = Matrix4.makeTranslation(new Vector3(1, 2, 3));\n * const R = Matrix4.makeRotationX(Math.PI);\n * const S = Matrix4.makeScale(new Vector3(2, 2, 2));\n * \n * // saves the result in M, leaving T, R, and S unchanged.\n * const M = Matrix4.multiplyAll(T, R, S);\n * \n * // each call to multiply overwrites the previous contents of M2 with the result of the multiplication\n * const M2 = Matrix4.makeIdentity();\n * M2.multiply(T);\n * M2.multiply(R);\n * M2.multiply(S); \n * ```\n */\nexport class Matrix4\n{\n    /**\n     * Static field to provide quick access to the identity matrix.\n     * (Note: Be careful not to change the value of this field!  It is marked readonly, but typescipt do not completely\n     * enforce this!)\n     * ```\n     * // Good use of IDENTITY:\n     * const M = gfx.Matrix4();\n     * if (M.equals(gfx.Matrix4.IDENTITY)) {\n     *   console.log(\"We have an identity matrix.\")\n     * }\n     * \n     * // Dangerous use of IDENTITY!!!!\n     * const M = gfx.Matrix4.IDENTITY;  // makes M a reference to gfx.Matrix4.IDENTITY\n     * M.set(3.0, 3, 3); // changes the underlying matrix in gfx.Matrix4.IDENTITY!\n     * \n     * // Do this instead:\n     * const M = gfx.Matrix4.makeIdentity(); // create a new identity matrix M\n     * M.set(3.0, 3, 3);\n     */\n    public static readonly IDENTITY = new Matrix4();\n\n    /**\n     * Array of 16 numbers representing the elements in the Matrix4\n     */\n    public mat: Array<number>;\n\n    /**\n     * Multiplies two Matrix4 objects and returns the result in a new matrix.\n     * \n     * @param lhs - The first Matrix4 object\n     * @param rhs - The second Matrix4 object\n     * @returns A new matrix = lhs * rhs\n     */\n    static multiply(lhs: Matrix4, rhs: Matrix4): Matrix4\n    {\n         // This implementation is several orders of magnitude faster than using nested loops\n         const m = new Matrix4();\n        \n        // Column 0\n        m.mat[0] = rhs.mat[0] * lhs.mat[0] + rhs.mat[1] * lhs.mat[4] + rhs.mat[2] * lhs.mat[8] + rhs.mat[3] * lhs.mat[12];\n        m.mat[1] = rhs.mat[0] * lhs.mat[1] + rhs.mat[1] * lhs.mat[5] + rhs.mat[2] * lhs.mat[9] + rhs.mat[3] * lhs.mat[13];\n        m.mat[2] = rhs.mat[0] * lhs.mat[2] + rhs.mat[1] * lhs.mat[6] + rhs.mat[2] * lhs.mat[10] + rhs.mat[3] * lhs.mat[14];\n        m.mat[3] = rhs.mat[0] * lhs.mat[3] + rhs.mat[1] * lhs.mat[7] + rhs.mat[2] * lhs.mat[11] + rhs.mat[3] * lhs.mat[15];\n\n        // Column 1\n        m.mat[4] = rhs.mat[4] * lhs.mat[0] + rhs.mat[5] * lhs.mat[4] + rhs.mat[6] * lhs.mat[8] + rhs.mat[7] * lhs.mat[12];\n        m.mat[5] = rhs.mat[4] * lhs.mat[1] + rhs.mat[5] * lhs.mat[5] + rhs.mat[6] * lhs.mat[9] + rhs.mat[7] * lhs.mat[13];\n        m.mat[6] = rhs.mat[4] * lhs.mat[2] + rhs.mat[5] * lhs.mat[6] + rhs.mat[6] * lhs.mat[10] + rhs.mat[7] * lhs.mat[14];\n        m.mat[7] = rhs.mat[4] * lhs.mat[3] + rhs.mat[5] * lhs.mat[7] + rhs.mat[6] * lhs.mat[11] + rhs.mat[7] * lhs.mat[15];\n\n        // Column 2\n        m.mat[8] = rhs.mat[8] * lhs.mat[0] + rhs.mat[9] * lhs.mat[4] + rhs.mat[10] * lhs.mat[8] + rhs.mat[11] * lhs.mat[12];\n        m.mat[9] = rhs.mat[8] * lhs.mat[1] + rhs.mat[9] * lhs.mat[5] + rhs.mat[10] * lhs.mat[9] + rhs.mat[11] * lhs.mat[13];\n        m.mat[10] = rhs.mat[8] * lhs.mat[2] + rhs.mat[9] * lhs.mat[6] + rhs.mat[10] * lhs.mat[10] + rhs.mat[11] * lhs.mat[14];\n        m.mat[11] = rhs.mat[8] * lhs.mat[3] + rhs.mat[9] * lhs.mat[7] + rhs.mat[10] * lhs.mat[11] + rhs.mat[11] * lhs.mat[15];\n\n        // Column 3\n        m.mat[12] = rhs.mat[12] * lhs.mat[0] + rhs.mat[13] * lhs.mat[4] + rhs.mat[14] * lhs.mat[8] + rhs.mat[15] * lhs.mat[12];\n        m.mat[13] = rhs.mat[12] * lhs.mat[1] + rhs.mat[13] * lhs.mat[5] + rhs.mat[14] * lhs.mat[9] + rhs.mat[15] * lhs.mat[13];\n        m.mat[14] = rhs.mat[12] * lhs.mat[2] + rhs.mat[13] * lhs.mat[6] + rhs.mat[14] * lhs.mat[10] + rhs.mat[15] * lhs.mat[14];\n        m.mat[15] = rhs.mat[12] * lhs.mat[3] + rhs.mat[13] * lhs.mat[7] + rhs.mat[14] * lhs.mat[11] + rhs.mat[15] * lhs.mat[15];\n \n        return m;\n    }\n\n    /**\n     * Mn = M1 * M2 * M3 * ... * M(n-1):  Composes (i.e., multiplies) two or more 4x4 matrices together\n     * and returns the result in a new matrix.\n     * \n     * (Remember, matrix multiplication is not commutitive; so, the order of the matrices is important!\n     * The order that transformations are applied to points and vectors is right-to-left.  To transform\n     * point p into p', as in the equation below, think of M(n-1) as being the first transformation to\n     * be applied to p and M1 as being the last transformation to be applied in order to produce p'.)\n     *  ```\n     *    p' = M1 * M2 * M3 * ... * M(n-1) * p\n     * ``` \n     * @param m1 - The first (leftmost) Matrix4 object\n     * @param m2 - The next Matrix4 object\n     * @param mAdditional - Zero or more additional Matrix4 objects\n     * @returns A new Matrix4 object = m1 * m2 * ...\n     */\n    static multiplyAll(m1: Matrix4, m2: Matrix4, ...mAdditional: Matrix4[]): Matrix4\n    {\n        const result = m1.clone();\n        result.multiply(m2);\n        for (let i=0; i<mAdditional.length; i++) {\n            result.multiply(mAdditional[i])\n        }\n        return result;\n    }\n\n    /**\n     * Creates a new Matrix4 object with the same values as the input matrix\n     * \n     * @param m - The input Matrix4 object\n     * @returns A new Matrix4 object with the same values as the input matrix\n     */\n    static copy(m: Matrix4): Matrix4\n    {\n        const mat = new Matrix4();\n        mat.copy(m);\n        return mat;\n    }\n\n    /**\n     * Creates a new Matrix4 object from the given values in row-major order\n     * \n     * @param n1 - Element [0,0] in the matrix\n     * @param n2 - Element [0,1] in the matrix\n     * @param n3 - Element [0,2] in the matrix\n     * @param n4 - Element [0,3] in the matrix\n     * @param n5 - Element [1,0] in the matrix\n     * @param n6 - Element [1,1] in the matrix\n     * @param n7 - Element [1,2] in the matrix\n     * @param n8 - Element [1,3] in the matrix\n     * @param n9 - Element [2,0] in the matrix\n     * @param n10 - Element [2,1] in the matrix\n     * @param n11 - Element [2,2] in the matrix\n     * @param n12 - Element [2,3] in the matrix\n     * @param n13 - Element [3,0] in the matrix\n     * @param n14 - Element [3,1] in the matrix\n     * @param n15 - Element [3,2] in the matrix\n     * @param n16 - Element [3,3] in the matrix\n     * @returns A new Matrix4 object created from the given values\n     */\n    public static fromRowMajor(n1: number, n2: number, n3: number, n4: number, \n        n5: number, n6: number, n7: number, n8: number, \n        n9: number, n10: number, n11: number, n12: number, \n        n13: number, n14: number, n15: number, n16: number): Matrix4\n    {\n        const matrix = new Matrix4();\n        matrix.setRowMajor(n1, n2, n3, n4, n5, n6, n7, n8, n9, n10, n11, n12, n13, n14, n15, n16);\n        return matrix;\n    }\n\n    /**\n     * Creates a new Matrix4 object from the given values in column-major order\n     * \n     * @param n1 - Element [0,0] in the matrix\n     * @param n2 - Element [1,0] in the matrix\n     * @param n3 - Element [2,0] in the matrix\n     * @param n4 - Element [3,0] in the matrix\n     * @param n5 - Element [0,1] in the matrix\n     * @param n6 - Element [1,1] in the matrix\n     * @param n7 - Element [2,1] in the matrix\n     * @param n8 - Element [3,1] in the matrix\n     * @param n9 - Element [0,2] in the matrix\n     * @param n10 - Element [1,2] in the matrix\n     * @param n11 - Element [2,2] in the matrix\n     * @param n12 - Element [3,2] in the matrix\n     * @param n13 - Element [0,3] in the matrix\n     * @param n14 - Element [1,3] in the matrix\n     * @param n15 - Element [2,3] in the matrix\n     * @param n16 - Element [3,3] in the matrix\n     * @returns A new Matrix4 object created from the given values\n     */\n    public static fromColumnMajor(n1: number, n2: number, n3: number, n4: number, \n        n5: number, n6: number, n7: number, n8: number, \n        n9: number, n10: number, n11: number, n12: number, \n        n13: number, n14: number, n15: number, n16: number): Matrix4\n    {\n        const matrix = new Matrix4();\n        matrix.setColumnMajor(n1, n2, n3, n4, n5, n6, n7, n8, n9, n10, n11, n12, n13, n14, n15, n16);\n        return matrix;\n    }\n\n    /**\n     * Creates a new Matrix4 object with the identity matrix\n     * \n     * @returns A new Matrix4 object with the identity matrix\n     */    \n    public static makeIdentity(): Matrix4\n    {\n        return Matrix4.fromRowMajor(\n            1, 0, 0, 0,\n            0, 1, 0, 0,\n            0, 0, 1, 0,\n            0, 0, 0, 1\n        );\n    }\n\n    /**\n     * Creates a new Matrix4 object for translation\n     * \n     * @param v - The Vector3 object representing the translation vector\n     * @returns A new Matrix4 object for translation\n     */    \n    public static makeTranslation(v: Vector3): Matrix4\n    {\n        return Matrix4.fromRowMajor(\n            1, 0, 0, v.x,\n            0, 1, 0, v.y,\n            0, 0, 1, v.z,\n            0, 0, 0, 1\n        );\n    }\n\n    /**\n     * Creates a new Matrix4 object for rotation\n     * \n     * @param rotation - The Quaternion object representing the rotation vector\n     * @returns A new Matrix4 object for rotation\n     */    \n    public static makeRotation(rotation: Quaternion): Matrix4\n    {\n        const matrix = new Matrix4();\n        matrix.setRotation(rotation);\n        return matrix;\n    }\n\n    /**\n     * Creates a new Matrix4 object for rotation around the X axis\n     * \n     * @param angle - The angle of rotation around the X axis\n     * @returns A new Matrix4 object for rotation around the X axis\n     */    \n    public static makeRotationX(angle: number): Matrix4\n    {\n        const matrix = new Matrix4();\n        matrix.setRotationX(angle);\n        return matrix;\n    }\n\n    /**\n     * Creates a new Matrix4 object for rotation around the Y axis\n     * \n     * @param angle - The angle of rotation around the Y axis\n     * @returns A new Matrix4 object for rotation around the Y axis\n     */\n    public static makeRotationY(angle: number): Matrix4\n    {\n        const matrix = new Matrix4();\n        matrix.setRotationY(angle);\n        return matrix;\n    }\n\n    /**\n     * Creates a new Matrix4 object for rotation around the Z axis\n     * \n     * @param angle - The angle of rotation around the Z axis\n     * @returns A new Matrix4 object for rotation around the Z axis\n     */\n    public static makeRotationZ(angle: number): Matrix4\n    {\n        const matrix = new Matrix4();\n        matrix.setRotationZ(angle);\n        return matrix;\n    }\n\n\n    /**\n     * Creates a new Matrix4 object for rotation around an arbitrary axis\n     * \n     * @param axis - The Vector3 object representing the axis of rotation\n     * @param angle - The angle of rotation around the axis\n     * @returns A new Matrix4 object for rotation around an arbitrary axis\n     */\n    public static makeAxisAngle(axis: Vector3, angle: number): Matrix4\n    {\n        const matrix = new Matrix4();\n        matrix.setAxisAngle(axis, angle);\n        return matrix;\n    }\n\n\n    /**\n     * Creates a new Matrix4 object for rotation using Euler angles\n     * \n     * @param x - The angle of rotation around the x axis\n     * @param y - The angle of rotation around the y axis\n     * @param z - The angle of rotation around the z axis\n     * @param order - The order of the rotations (default is 'YZX')\n     * @returns A new Matrix4 object for rotation using Euler angles\n     */\n    public static makeEulerAngles(x: number, y: number, z: number, order = 'YZX'): Matrix4\n    {\n        const dest = new Matrix4();\n        dest.setEulerAngles(x, y, z, order);\n        return dest;\n    }\n\n    /**\n     * Creates a new Matrix4 object for scaling\n     * \n     * @param scale - The Vector3 object representing the scale vector\n     * @returns A new Matrix4 object for scaling\n     */\n    public static makeScale(scale: Vector3): Matrix4\n    {\n        const matrix = new Matrix4();\n        matrix.setScale(scale);\n        return matrix;\n    }\n\n    /**\n     * Creates a new Matrix4 object representing the combined transform of position, rotation and scale\n     * \n     * @param position - The Vector3 object representing the position\n     * @param rotation - The Quaternion object representing the rotation\n     * @param scale - The Vector3 object representing the scale\n     * @returns A new Matrix4 object representing the combined transform of position, rotation and scale\n     */\n    public static compose(position = Vector3.ZERO, rotation = Quaternion.IDENTITY, scale = Vector3.UP): Matrix4\n    {\n        const m = Matrix4.makeScale(scale);\n        m.premultiply(Matrix4.makeRotation(rotation));\n        m.mat[12] = position.x;\n        m.mat[13] = position.y;\n        m.mat[14] = position.z;\n        return m;\n    }\n\n    /**\n     * Creates a new Matrix4 object for the view matrix of a camera.  The matrix will position the camera\n     * at eyePoint and orient it to look directly toward the targetPoint so that the camera's look vector\n     * will be (targetPoint - eyePoint).  The camera's rotation around the look vector is controlled by \n     * the upVector, which only needs to point roughly in the Up direction, i.e., it does not need to\n     * be completely perpendicular to the look vector.\n     * \n     * @param eyePoint - The position of the camera\n     * @param targetPoint - A point that the camera should look directly toward\n     * @param upVector - The \"up\" direction for the camera\n     * @returns A new Matrix4 object for the view matrix of a camera\n     */\n    public static lookAt(eyePoint: Vector3, targetPoint: Vector3, upVector: Vector3): Matrix4\n    {\n        const z = Vector3.subtract(eyePoint, targetPoint);\n        z.normalize();\n\n        const x = Vector3.cross(upVector, z);\n        x.normalize();\n\n        const y = Vector3.cross(z, x);\n        y.normalize();\n\n        const rotation = Matrix4.fromColumnMajor(\n            x.x, x.y, x.z, 0.0,\n            y.x, y.y, y.z, 0.0,\n            z.x, z.y, z.z, 0.0,\n            0.0, 0.0, 0.0, 1.0,\n        );\n\n        const translation = Matrix4.fromColumnMajor(\n            1.0, 0.0, 0.0, 0.0,\n            0.0, 1.0, 0.0, 0.0,\n            0.0, 0.0, 1.0, 0.0,\n            eyePoint.x, eyePoint.y, eyePoint.z, 1.0 \n        );\n\n        return Matrix4.multiply(translation, rotation);\n    }\n\n    /**\n     * Create an orthographic projection Matrix4 \n     * \n     * @param left - Left coordinate of the viewing volume\n     * @param right - Right coordinate of the viewing volume\n     * @param bottom - Bottom coordinate of the viewing volume\n     * @param top - Top coordinate of the viewing volume\n     * @param near - Near clipping plane of the viewing volume\n     * @param far - Far clipping plane of the viewing volume\n     * @returns A Matrix4 representing an orthographic projection\n     */\n    public static makeOrthographic(left: number, right: number, bottom: number, top: number, near: number, far: number): Matrix4\n    {\n        const matrix = new Matrix4();\n        matrix.setOrthographic(left, right, bottom, top, near, far);\n        return matrix;\n    }\n\n    /**\n     * Create a perspective projection Matrix4 \n     * \n     * @param fov - Field of view of the projection in radians\n     * @param aspectRatio - Aspect ratio of the viewport (width / height)\n     * @param near - Near clipping plane of the viewing volume\n     * @param far - Far clipping plane of the viewing volume\n     * @returns A Matrix4 representing a perspective projection\n     */\n    public static makePerspective(fov: number, aspectRatio: number, near: number, far: number): Matrix4\n    {\n        const matrix = new Matrix4();\n        matrix.setPerspective(fov, aspectRatio, near, far);\n        return matrix;\n    }\n\n    /**\n     * Create a frustum projection Matrix4 \n     * \n     * @param left - Left coordinate of the viewing volume\n     * @param right - Right coordinate of the viewing volume\n     * @param bottom - Bottom coordinate of the viewing volume\n     * @param top - Top coordinate of the viewing volume\n     * @param near - Near clipping plane of the viewing volume\n     * @param far - Far clipping plane of the viewing volume\n     * @returns A Matrix4 representing a frustum projection\n     */\n    public static makeFrustum(left: number, right: number, bottom: number, top: number, near: number, far: number): Matrix4\n    {\n        const matrix = new Matrix4();\n        matrix.setFrustum(left, right, bottom, top, near, far);\n        return matrix;\n    }\n\n    /**\n     * Multiplies point p by a 4x4 transformation matrix and returns the result as a new point.  This has the effect of\n     * transforming p from m's local coordinate system to m's parent coordinate system.  The multiplication is done\n     * using homogeneous coordinates (p is treated as having a w=1 coordinate).\n     * \n     * @param m A 4x4 transformation matrix\n     * @param p The original point\n     * @returns A new point transformed by m\n     */\n    public static transformPoint(m: Matrix4, p: Vector3): Vector3\n    {\n        const result = new Vector3();\n        const w = 1 / (m.mat[3]*p.x + m.mat[7]*p.y + m.mat[11]*p.z + m.mat[15]);\n        result.x = w * (m.mat[0]*p.x + m.mat[4]*p.y + m.mat[8]*p.z + m.mat[12]);\n        result.y = w * (m.mat[1]*p.x + m.mat[5]*p.y + m.mat[9]*p.z + m.mat[13]);\n        result.z = w * (m.mat[2]*p.x + m.mat[6]*p.y + m.mat[10]*p.z + m.mat[14]);\n        return result;\n    }\n\n    /**\n     * Multiplies vector v by a 4x4 transformation matrix and returns the result as a new vector.  This has the effect of\n     * transforming v from m's local coordinate system to m's parent coordinate system.  The multiplication is done\n     * using homogeneous coordinates (p is treated as having a w=0 coordinate).\n     * \n     * @param m A 4x4 transformation matrix\n     * @param v The original vector\n     * @returns A new vector transformed by m\n     */\n    public static transformVector(m: Matrix4, v: Vector3): Vector3\n    {\n        const result = new Vector3();\n        const w = 1 / (m.mat[3]*v.x + m.mat[7]*v.y + m.mat[11]*v.z + m.mat[15]);\n        result.x = w * (m.mat[0]*v.x + m.mat[4]*v.y + m.mat[8]*v.z);\n        result.y = w * (m.mat[1]*v.x + m.mat[5]*v.y + m.mat[9]*v.z);\n        result.z = w * (m.mat[2]*v.x + m.mat[6]*v.y + m.mat[10]*v.z);\n        return result;\n    }\n\n\n    /**\n     * Checks if all elements of two Matrix4 objects are exactly equal.\n     *\n     * @param m1 - The first matrix.\n     * @param m2 - The second matrix.\n     * @returns A boolean value indicating if the two matrices are equal\n     */\n    public static equals(m1: Matrix4, m2: Matrix4): boolean\n    {\n        for (let i=0; i<16; i++) {\n            if (m1.mat[i] != m2.mat[i]) \n                return false;\n        }\n        return true;\n    }\n\n    /**\n     * Checks if all elements of two Matrix4 objects are equal within a small value of epsilon.\n     *\n     * @param m1 - The first matrix.\n     * @param m2 - The second matrix.\n     * @param epsilon - A small value of acceptable variance to account for numerical instability\n     * @returns A boolean value indicating if the two matrices are equal\n     */\n    public static fuzzyEquals(m1: Matrix4, m2: Matrix4, epsilon: number = MathUtils.EPSILON): boolean\n    {\n        for (let i=0; i<16; i++) {\n            if (Math.abs(m1.mat[i] - m2.mat[i]) < epsilon) \n                return false;\n        }\n        return true;\n    }\n\n\n    /**\n     * Constructs a Matrix4 object with a 4x4 identity matrix\n     */    \n    constructor()\n    {\n        this.mat = [ \n            1, 0, 0, 0,\n            0, 1, 0, 0,\n            0, 0, 1, 0,\n            0, 0, 0, 1\n        ];\n    }\n\n    /**\n     * Set the values of the Matrix4 in column-major order\n     * \n     * @param n1 - Column 1, Row 1 value\n     * @param n2 - Column 1, Row 2 value\n     * @param n3 - Column 1, Row 3 value\n     * @param n4 - Column 1, Row 4 value\n     * @param n5 - Column 2, Row 1 value\n     * @param n6 - Column 2, Row 2 value\n     * @param n7 - Column 2, Row 3 value\n     * @param n8 - Column 2, Row 4 value\n     * @param n9 - Column 3, Row 1 value\n     * @param n10 - Column 3, Row 2 value\n     * @param n11 - Column 3, Row 3 value\n     * @param n12 - Column 3, Row 4 value\n     * @param n13 - Column 4, Row 1 value\n     * @param n14 - Column 4, Row 2 value\n     * @param n15 - Column 4, Row 3 value\n     * @param n16 - Column 4, Row 4 value\n     */\n    setColumnMajor(n1: number, n2: number, n3: number, n4: number, \n        n5: number, n6: number, n7: number, n8: number, \n        n9: number, n10: number, n11: number, n12: number, \n        n13: number, n14: number, n15: number, n16: number): void\n    {\n        this.mat[0] = n1;\n        this.mat[1] = n2;\n        this.mat[2] = n3;\n        this.mat[3] = n4;\n        this.mat[4] = n5;\n        this.mat[5] = n6;\n        this.mat[6] = n7;\n        this.mat[7] = n8;\n        this.mat[8] = n9;\n        this.mat[9] = n10;\n        this.mat[10] = n11;\n        this.mat[11] = n12;\n        this.mat[12] = n13;\n        this.mat[13] = n14;\n        this.mat[14] = n15;\n        this.mat[15] = n16;\n    }\n\n    /**\n     * Set the values of the Matrix4 in row-major order\n     * \n     * @param n1 - Column 1, Row 1 value\n     * @param n2 - Column 1, Row 2 value\n     * @param n3 - Column 1, Row 3 value\n     * @param n4 - Column 1, Row 4 value\n     * @param n5 - Column 2, Row 1 value\n     * @param n6 - Column 2, Row 2 value\n     * @param n7 - Column 2, Row 3 value\n     * @param n8 - Column 2, Row 4 value\n     * @param n9 - Column 3, Row 1 value\n     * @param n10 - Column 3, Row 2 value\n     * @param n11 - Column 3, Row 3 value\n     * @param n12 - Column 3, Row 4 value\n     * @param n13 - Column 4, Row 1 value\n     * @param n14 - Column 4, Row 2 value\n     * @param n15 - Column 4, Row 3 value\n     * @param n16 - Column 4, Row 4 value\n     */\n    setRowMajor(n1: number, n2: number, n3: number, n4: number, \n        n5: number, n6: number, n7: number, n8: number, \n        n9: number, n10: number, n11: number, n12: number, \n        n13: number, n14: number, n15: number, n16: number): void\n    {\n        this.mat[0] = n1;\n        this.mat[1] = n5;\n        this.mat[2] = n9;\n        this.mat[3] = n13;\n        this.mat[4] = n2;\n        this.mat[5] = n6;\n        this.mat[6] = n10;\n        this.mat[7] = n14;\n        this.mat[8] = n3;\n        this.mat[9] = n7;\n        this.mat[10] = n11;\n        this.mat[11] = n15;\n        this.mat[12] = n4;\n        this.mat[13] = n8;\n        this.mat[14] = n12;\n        this.mat[15] = n16;\n    }\n\n\n    /**\n     * Copy the values of another Matrix4 into this one\n     * \n     * @param m - The Matrix4 object to copy from\n     */\n    copy(m: Matrix4): void\n    {\n        for(let i=0; i < 16; i++)\n            this.mat[i] = m.mat[i];\n    }\n\n\n    /**\n     * Creates a new Matrix4 object with the same values as this Matrix4.\n     * \n     * @returns A new Matrix4 object with the same values as this Matrix4.\n     */\n    clone(): Matrix4\n    {\n        const matrix = new Matrix4();\n        \n        for(let i=0; i < 16; i++)\n            matrix.mat[i] = this.mat[i];\n\n        return matrix;\n    }\n\n    /** \n     * Returns the element at the given row and column in this Matrix4.\n     * \n     * @param row - The row of the element to return.\n     * @param col - The column of the element to return.\n     * @returns The element at the given row and column.\n     */   \n    element(row: number, col: number): number\n    {\n        return this.mat[col*4 + row];\n    }\n\n    /**\n     * Sets the element at the given row and column in this Matrix4.\n     * \n     * @param value - The value to set at the given row and column.\n     * @param row - The row of the element to set.\n     * @param col - The column of the element to set.\n     */    \n    set(value: number, row: number, col: number): void\n    {\n       this.mat[col*4 + row] = value;\n    }\n\n    /**\n     * Multiplies this Matrix4 with another Matrix4 on the right hand side (i.e., this = this * rhs) and sets this\n     * Matrix4 to the result.\n     * \n     * @param rhs - The Matrix4 to multiply with.\n     */\n    multiply(rhs: Matrix4): void\n    {\n        const lhs = this.clone();\n\n        // Column 0\n        this.mat[0] = rhs.mat[0] * lhs.mat[0] + rhs.mat[1] * lhs.mat[4] + rhs.mat[2] * lhs.mat[8] + rhs.mat[3] * lhs.mat[12];\n        this.mat[1] = rhs.mat[0] * lhs.mat[1] + rhs.mat[1] * lhs.mat[5] + rhs.mat[2] * lhs.mat[9] + rhs.mat[3] * lhs.mat[13];\n        this.mat[2] = rhs.mat[0] * lhs.mat[2] + rhs.mat[1] * lhs.mat[6] + rhs.mat[2] * lhs.mat[10] + rhs.mat[3] * lhs.mat[14];\n        this.mat[3] = rhs.mat[0] * lhs.mat[3] + rhs.mat[1] * lhs.mat[7] + rhs.mat[2] * lhs.mat[11] + rhs.mat[3] * lhs.mat[15];\n        \n        // Column 1\n        this.mat[4] = rhs.mat[4] * lhs.mat[0] + rhs.mat[5] * lhs.mat[4] + rhs.mat[6] * lhs.mat[8] + rhs.mat[7] * lhs.mat[12];\n        this.mat[5] = rhs.mat[4] * lhs.mat[1] + rhs.mat[5] * lhs.mat[5] + rhs.mat[6] * lhs.mat[9] + rhs.mat[7] * lhs.mat[13];\n        this.mat[6] = rhs.mat[4] * lhs.mat[2] + rhs.mat[5] * lhs.mat[6] + rhs.mat[6] * lhs.mat[10] + rhs.mat[7] * lhs.mat[14];\n        this.mat[7] = rhs.mat[4] * lhs.mat[3] + rhs.mat[5] * lhs.mat[7] + rhs.mat[6] * lhs.mat[11] + rhs.mat[7] * lhs.mat[15];\n\n        // Column 2\n        this.mat[8] = rhs.mat[8] * lhs.mat[0] + rhs.mat[9] * lhs.mat[4] + rhs.mat[10] * lhs.mat[8] + rhs.mat[11] * lhs.mat[12];\n        this.mat[9] = rhs.mat[8] * lhs.mat[1] + rhs.mat[9] * lhs.mat[5] + rhs.mat[10] * lhs.mat[9] + rhs.mat[11] * lhs.mat[13];\n        this.mat[10] = rhs.mat[8] * lhs.mat[2] + rhs.mat[9] * lhs.mat[6] + rhs.mat[10] * lhs.mat[10] + rhs.mat[11] * lhs.mat[14];\n        this.mat[11] = rhs.mat[8] * lhs.mat[3] + rhs.mat[9] * lhs.mat[7] + rhs.mat[10] * lhs.mat[11] + rhs.mat[11] * lhs.mat[15];\n\n        // Column 3\n        this.mat[12] = rhs.mat[12] * lhs.mat[0] + rhs.mat[13] * lhs.mat[4] + rhs.mat[14] * lhs.mat[8] + rhs.mat[15] * lhs.mat[12];\n        this.mat[13] = rhs.mat[12] * lhs.mat[1] + rhs.mat[13] * lhs.mat[5] + rhs.mat[14] * lhs.mat[9] + rhs.mat[15] * lhs.mat[13];\n        this.mat[14] = rhs.mat[12] * lhs.mat[2] + rhs.mat[13] * lhs.mat[6] + rhs.mat[14] * lhs.mat[10] + rhs.mat[15] * lhs.mat[14];\n        this.mat[15] = rhs.mat[12] * lhs.mat[3] + rhs.mat[13] * lhs.mat[7] + rhs.mat[14] * lhs.mat[11] + rhs.mat[15] * lhs.mat[15];\n    }\n\n    /**\n     * this.mat = this.mat * M1 * M2 * ... * M(n-1):  Multiplies this matrix with one or more additional \\\n     * 4x4 matrices.\n     * \n     * (Remember, matrix multiplication is not commutitive; so, the order of the matrices is important!\n     * The order that transformations are applied to points and vectors is right-to-left.  To transform\n     * point p into p', as in the equation below, think of M(n-1) as being the first transformation to\n     * be applied to p and the current value of this.mat as being the last transformation to be applied\n     * in order to produce p'.)\n     *  ```\n     *    p' = this.mat * M1 * M2 * ... * M(n-1) * p\n     * ``` \n     */\n    multiplyAll(m1: Matrix4, ...mAdditional: Matrix4[]): void\n    {\n        this.multiply(m1);\n        for (let i=0; i<mAdditional.length; i++) {\n            this.multiply(mAdditional[i])\n        }\n    }\n\n    /**\n     * Multiplies the given Matrix4 with another Matrix4 on the left hand side (i.e., this = lhs * this) and sets this Matrix4\n     *  to the result.\n     * \n     * @param lhs - The Matrix4 to multiply with.\n     */    \n    premultiply(lhs: Matrix4): void\n    {\n        const rhs = this.clone();\n\n        // Column 0\n        this.mat[0] = rhs.mat[0] * lhs.mat[0] + rhs.mat[1] * lhs.mat[4] + rhs.mat[2] * lhs.mat[8] + rhs.mat[3] * lhs.mat[12];\n        this.mat[1] = rhs.mat[0] * lhs.mat[1] + rhs.mat[1] * lhs.mat[5] + rhs.mat[2] * lhs.mat[9] + rhs.mat[3] * lhs.mat[13];\n        this.mat[2] = rhs.mat[0] * lhs.mat[2] + rhs.mat[1] * lhs.mat[6] + rhs.mat[2] * lhs.mat[10] + rhs.mat[3] * lhs.mat[14];\n        this.mat[3] = rhs.mat[0] * lhs.mat[3] + rhs.mat[1] * lhs.mat[7] + rhs.mat[2] * lhs.mat[11] + rhs.mat[3] * lhs.mat[15];\n        \n        // Column 1\n        this.mat[4] = rhs.mat[4] * lhs.mat[0] + rhs.mat[5] * lhs.mat[4] + rhs.mat[6] * lhs.mat[8] + rhs.mat[7] * lhs.mat[12];\n        this.mat[5] = rhs.mat[4] * lhs.mat[1] + rhs.mat[5] * lhs.mat[5] + rhs.mat[6] * lhs.mat[9] + rhs.mat[7] * lhs.mat[13];\n        this.mat[6] = rhs.mat[4] * lhs.mat[2] + rhs.mat[5] * lhs.mat[6] + rhs.mat[6] * lhs.mat[10] + rhs.mat[7] * lhs.mat[14];\n        this.mat[7] = rhs.mat[4] * lhs.mat[3] + rhs.mat[5] * lhs.mat[7] + rhs.mat[6] * lhs.mat[11] + rhs.mat[7] * lhs.mat[15];\n\n        // Column 2\n        this.mat[8] = rhs.mat[8] * lhs.mat[0] + rhs.mat[9] * lhs.mat[4] + rhs.mat[10] * lhs.mat[8] + rhs.mat[11] * lhs.mat[12];\n        this.mat[9] = rhs.mat[8] * lhs.mat[1] + rhs.mat[9] * lhs.mat[5] + rhs.mat[10] * lhs.mat[9] + rhs.mat[11] * lhs.mat[13];\n        this.mat[10] = rhs.mat[8] * lhs.mat[2] + rhs.mat[9] * lhs.mat[6] + rhs.mat[10] * lhs.mat[10] + rhs.mat[11] * lhs.mat[14];\n        this.mat[11] = rhs.mat[8] * lhs.mat[3] + rhs.mat[9] * lhs.mat[7] + rhs.mat[10] * lhs.mat[11] + rhs.mat[11] * lhs.mat[15];\n\n        // Column 3\n        this.mat[12] = rhs.mat[12] * lhs.mat[0] + rhs.mat[13] * lhs.mat[4] + rhs.mat[14] * lhs.mat[8] + rhs.mat[15] * lhs.mat[12];\n        this.mat[13] = rhs.mat[12] * lhs.mat[1] + rhs.mat[13] * lhs.mat[5] + rhs.mat[14] * lhs.mat[9] + rhs.mat[15] * lhs.mat[13];\n        this.mat[14] = rhs.mat[12] * lhs.mat[2] + rhs.mat[13] * lhs.mat[6] + rhs.mat[14] * lhs.mat[10] + rhs.mat[15] * lhs.mat[14];\n        this.mat[15] = rhs.mat[12] * lhs.mat[3] + rhs.mat[13] * lhs.mat[7] + rhs.mat[14] * lhs.mat[11] + rhs.mat[15] * lhs.mat[15];\n    }\n\n    /**\n     * Sets this Matrix4 to the identity matrix.\n     */    \n    setIdentity(): void\n    {\n        this.setRowMajor(\n            1, 0, 0, 0,\n            0, 1, 0, 0,\n            0, 0, 1, 0,\n            0, 0, 0, 1\n        );\n    }\n\n    /**\n     * Sets this Matrix4 to a translation matrix given a translation Vector3.\n     * \n     * @param v - The translation Vector3.\n     */    \n    setTranslation(v: Vector3): void\n    {\n        this.setRowMajor(\n            1, 0, 0, v.x,\n            0, 1, 0, v.y,\n            0, 0, 1, v.z,\n            0, 0, 0, 1\n        );\n    }\n\n    /**\n     * Sets this Matrix4 to a rotation matrix given a Quaternion.\n     * \n     * @param rotation - The Quaternion to construct the rotation matrix with.\n     */\n    // based on http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToMatrix/index.htm\n    setRotation(rotation: Quaternion): void\n    {\n        const sqw = rotation.w*rotation.w;\n        const sqx = rotation.x*rotation.x;\n        const sqy = rotation.y*rotation.y;\n        const sqz = rotation.z*rotation.z;\n\n        // invs (inverse square length) is only required if quaternion is not already normalised\n        const invs = 1 / (sqx + sqy + sqz + sqw);\n\n        const tmp1 = rotation.x*rotation.y;\n        const tmp2 = rotation.z*rotation.w;\n        const tmp3 = rotation.x*rotation.z;\n        const tmp4 = rotation.y*rotation.w;\n        const tmp5 = rotation.y*rotation.z;\n        const tmp6 = rotation.x*rotation.w;\n        \n        this.setRowMajor(\n            ( sqx - sqy - sqz + sqw)*invs, 2 * (tmp1 - tmp2)*invs, 2 * (tmp3 + tmp4)*invs, 0,\n            2 * (tmp1 + tmp2)*invs, (-sqx + sqy - sqz + sqw)*invs, 2 * (tmp5 - tmp6)*invs, 0,\n            2 * (tmp3 - tmp4)*invs, 2 * (tmp5 + tmp6)*invs, (-sqx - sqy + sqz + sqw), 0,\n            0, 0, 0, 1\n        );\n    }\n\n    /**\n     * Sets this Matrix4 to a rotation matrix around the X axis with the given angle in radians.\n     * \n     * @param angle - The angle in radians.\n     */\n    setRotationX(angle: number): void\n    {\n        const cosTheta = Math.cos(angle);\n        const sinTheta = Math.sin(angle);\n        \n        this.setRowMajor(\n            1, 0, 0, 0,\n            0, cosTheta, -sinTheta, 0,\n            0, sinTheta, cosTheta, 0,\n            0, 0, 0, 1\n        );\n    }\n\n    /**\n     * Sets this Matrix4 to a rotation matrix around the Y axis with the given angle in radians.\n     * \n     * @param angle - The angle in radians.\n     */\n    setRotationY(angle: number): void\n    {\n        const cosTheta = Math.cos(angle);\n        const sinTheta = Math.sin(angle);\n   \n        this.setRowMajor(\n            cosTheta, 0, sinTheta, 0,\n            0, 1, 0, 0,\n            -sinTheta, 0, cosTheta, 0,\n            0, 0, 0, 1\n        );\n    }\n\n    /**\n     * Sets this Matrix4 to a rotation matrix around the Z axis with the given angle in radians.\n     * \n     * @param angle - The angle in radians.\n     */    \n    setRotationZ(angle: number): void\n    {\n        const cosTheta = Math.cos(angle);\n        const sinTheta = Math.sin(angle);\n        this.setRowMajor(\n            cosTheta, -sinTheta, 0, 0,\n            sinTheta, cosTheta, 0, 0,\n            0, 0, 1, 0,\n            0, 0, 0, 1\n        );\n    }\n\n    /**\n     * Set the axis angle for this Matrix4 object\n     * \n     * @param axis - The Vector3 representing the axis\n     * @param angle - The angle to set the axis to\n     */    \n    setAxisAngle(axis: Vector3, angle: number): void\n    {\n        const c = Math.cos(angle);\n\t\tconst s = Math.sin(angle);\n\t\tconst t = 1 - c;\n\t\tconst x = axis.x, y = axis.y, z = axis.z;\n\t\tconst tx = t * x, ty = t * y;\n\t\tthis.setRowMajor(\n\t\t\ttx * x + c, tx * y - s * z, tx * z + s * y, 0,\n\t\t\ttx * y + s * z, ty * y + c, ty * z - s * x, 0,\n\t\t\ttx * z - s * y, ty * z + s * x, t * z * z + c, 0,\n\t\t\t0, 0, 0, 1\n\t\t);\n    }\n\n    /**\n     * Set the scale of this Matrix4 object\n     * \n     * @param scale - The Vector3 representing the scale to set\n     */\n    setScale(scale: Vector3): void\n    {\n        this.setRowMajor(\n            scale.x, 0, 0, 0,\n            0, scale.y, 0, 0,\n            0, 0, scale.z, 0,\n            0, 0, 0, 1    \n        );\n    }\n\n    /**\n     * Gets the translation vector of this Matrix4 object\n     * \n     * @returns The Vector3 representing the translation vector\n     */\n    getTranslation(): Vector3\n    {\n        return new Vector3(this.mat[12], this.mat[13], this.mat[14]);\n    }\n\n    /**\n     * Gets the rotation quaternion of this Matrix4 object\n     * \n     * @returns The Quaternion representing the rotation\n     */\n    getRotation(): Quaternion\n    {\n        return Quaternion.makeMatrix(this);\n    }\n\n    /**\n     * Gets the scale vector of this Matrix4 object\n     * \n     * @returns The Vector3 representing the scale vector\n     */\n    getScale(): Vector3\n    {\n        return new Vector3(\n            Math.sqrt(this.mat[0]*this.mat[0] + this.mat[1]*this.mat[1] + this.mat[2]*this.mat[2]),\n            Math.sqrt(this.mat[4]*this.mat[4] + this.mat[5]*this.mat[5] + this.mat[6]*this.mat[6]),\n            Math.sqrt(this.mat[8]*this.mat[8] + this.mat[9]*this.mat[9] + this.mat[10]*this.mat[10])\n        );\n    }\n\n    /**\n     * Sets an orthographic projection matrix on this Matrix4 object\n     * \n     * @param left - The leftmost coordinate\n     * @param right - The rightmost coordinate\n     * @param bottom - The bottom coordinate\n     * @param top - The top coordinate\n     * @param near - The near coordinate\n     * @param far - The far coordinate\n     */\n    setOrthographic(left: number, right: number, bottom: number, top: number, near: number, far: number): void\n    {\n        this.setRowMajor(\n            2/(right-left), 0, 0, -(right+left)/(right-left),\n            0, 2/(top-bottom), 0, -(top+bottom)/(top-bottom),\n            0, 0, -2/(far-near), -(far+near)/(far-near),\n            0, 0, 0, 1\n        );\n    }\n\n\n    /**\n     * Sets a perspective projection matrix on this Matrix4 object\n     * \n     * @param fov - The field of view angle\n     * @param aspectRatio - The aspect ratio of the view\n     * @param near - The near coordinate\n     * @param far - The far coordinate\n     */\n    setPerspective(fov: number, aspectRatio: number, near: number, far: number): void\n    {\n        const yMax = near * Math.tan(fov * Math.PI / 360);\n        const xMax = yMax * aspectRatio;\n        this.setFrustum(-xMax, xMax, -yMax, yMax, near, far); \n    }\n\n    /**\n     * Sets a frustum projection matrix on this Matrix4 object\n     * \n     * @param left - The leftmost coordinate\n     * @param right - The rightmost coordinate\n     * @param bottom - The bottom coordinate\n     * @param top - The top coordinate\n     * @param near - The near coordinate\n     * @param far - The far coordinate\n     */\n    setFrustum(left: number, right: number, bottom: number, top: number, near: number, far: number): void\n    {\n        this.setRowMajor(\n            2*near/(right-left), 0, (right+left)/(right-left), 0,\n            0, 2*near/(top-bottom), (top+bottom)/(top-bottom), 0,\n            0, 0, -(far+near)/(far-near), -2*far*near/(far-near),\n            0, 0, -1, 0\n        );\n    }\n\n    /**\n     * Sets the Matrix to a view matrix of a camera.  The matrix will position the camera\n     * at eyePoint and orient it to look directly toward the targetPoint so that the camera's look vector\n     * will be (targetPoint - eyePoint).  The camera's rotation around the look vector is controlled by \n     * the upVector, which only needs to point roughly in the Up direction, i.e., it does not need to\n     * be completely perpendicular to the look vector.\n     * \n     * @param eyePoint - The position of the camera\n     * @param targetPoint - A point that the camera should look directly toward\n     * @param upVector - The \"up\" direction for the camera\n     * @returns A new Matrix4 object for the view matrix of a camera\n     */\n    lookAt(eye: Vector3, target: Vector3, up = Vector3.UP): void\n    {\n        const z = Vector3.subtract(eye, target);\n        z.normalize();\n\n        const x = Vector3.cross(up, z);\n        x.normalize();\n\n        const y = Vector3.cross(z, x);\n        y.normalize();\n\n        this.setColumnMajor(\n            x.x, x.y, x.z, 0.0,\n            y.x, y.y, y.z, 0.0,\n            z.x, z.y, z.z, 0.0,\n            0.0, 0.0, 0.0, 1.0,\n        );\n\n        const translation = Matrix4.fromColumnMajor(\n            1.0, 0.0, 0.0, 0.0,\n            0.0, 1.0, 0.0, 0.0,\n            0.0, 0.0, 1.0, 0.0,\n            eye.x, eye.y, eye.z, 1.0 \n        );\n\n        this.premultiply(translation);\n    }\n\n    /**\n     * Multiplies all elements of this Matrix4 object by a scalar\n     * \n     * @param x - The scalar to multiply by\n     */\n    multiplyScalar(x: number): void\n    {\n        for(let i=0; i < 16; i++)\n            this.mat[i] *= x;\n    }\n\n    /**\n     * Computes the determinant of the Matrix4 object \n     * \n     * @returns The determinant of the Matrix4 object\n     */    \n    // Code from http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm\n    determinant(): number\n    {\n        const determinant = \n            this.mat[3] * this.mat[6] * this.mat[9] * this.mat[12]-\n            this.mat[2] * this.mat[7] * this.mat[9] * this.mat[12]-\n            this.mat[3] * this.mat[5] * this.mat[10] * this.mat[12]+\n            this.mat[1] * this.mat[7] * this.mat[10] * this.mat[12]+\n            this.mat[2] * this.mat[5] * this.mat[11] * this.mat[12]-\n            this.mat[1] * this.mat[6] * this.mat[11] * this.mat[12]-\n            this.mat[3] * this.mat[6] * this.mat[8] * this.mat[13]+\n            this.mat[2] * this.mat[7] * this.mat[8] * this.mat[13]+\n            this.mat[3] * this.mat[4] * this.mat[10] * this.mat[13]-\n            this.mat[0] * this.mat[7] * this.mat[10] * this.mat[13]-\n            this.mat[2] * this.mat[4] * this.mat[11] * this.mat[13]+\n            this.mat[0] * this.mat[6] * this.mat[11] * this.mat[13]+\n            this.mat[3] * this.mat[5] * this.mat[8] * this.mat[14]-\n            this.mat[1] * this.mat[7] * this.mat[8] * this.mat[14]-\n            this.mat[3] * this.mat[4] * this.mat[9] * this.mat[14]+\n            this.mat[0] * this.mat[7] * this.mat[9] * this.mat[14]+\n            this.mat[1] * this.mat[4] * this.mat[11] * this.mat[14]-\n            this.mat[0] * this.mat[5] * this.mat[11] * this.mat[14]-\n            this.mat[2] * this.mat[5] * this.mat[8] * this.mat[15]+\n            this.mat[1] * this.mat[6] * this.mat[8] * this.mat[15]+\n            this.mat[2] * this.mat[4] * this.mat[9] * this.mat[15]-\n            this.mat[0] * this.mat[6] * this.mat[9] * this.mat[15]-\n            this.mat[1] * this.mat[4] * this.mat[10] * this.mat[15]+\n            this.mat[0] * this.mat[5] * this.mat[10] * this.mat[15];\n\n        return determinant;\n    }\n\n    /**\n     * Calculates the inverse of a Matrix4 object\n     * \n     * @returns A Matrix4 object that is the inverse of the current Matrix4 object\n     */\n    // Code from http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm\n    inverse(): Matrix4\n    {\n        // Check for singular matrix\n        const determinant = this.determinant();\n        if (Math.abs(determinant) < 1e-8)\n            return new Matrix4();\n\n        const inverse = new Matrix4();\n\n        inverse.mat[0] = (this.mat[6]*this.mat[11]*this.mat[13] -\n            this.mat[7]*this.mat[10]*this.mat[13] +\n            this.mat[7]*this.mat[9]*this.mat[14] -\n            this.mat[5]*this.mat[11]*this.mat[14] -\n            this.mat[6]*this.mat[9]*this.mat[15] +\n            this.mat[5]*this.mat[10]*this.mat[15])/determinant;\n\n        inverse.mat[1] = (this.mat[3]*this.mat[10]*this.mat[13] -\n            this.mat[2]*this.mat[11]*this.mat[13] -\n            this.mat[3]*this.mat[9]*this.mat[14] +\n            this.mat[1]*this.mat[11]*this.mat[14] +\n            this.mat[2]*this.mat[9]*this.mat[15] -\n            this.mat[1]*this.mat[10]*this.mat[15])/determinant;\n        \n        inverse.mat[2] = (this.mat[2]*this.mat[7]*this.mat[13] -\n            this.mat[3]*this.mat[6]*this.mat[13] +\n            this.mat[3]*this.mat[5]*this.mat[14] -\n            this.mat[1]*this.mat[7]*this.mat[14] -\n            this.mat[2]*this.mat[5]*this.mat[15] +\n            this.mat[1]*this.mat[6]*this.mat[15])/determinant;\n        \n        inverse.mat[3] = (this.mat[3]*this.mat[6]*this.mat[9] -\n            this.mat[2]*this.mat[7]*this.mat[9] -\n            this.mat[3]*this.mat[5]*this.mat[10] +\n            this.mat[1]*this.mat[7]*this.mat[10] +\n            this.mat[2]*this.mat[5]*this.mat[11] -\n            this.mat[1]*this.mat[6]*this.mat[11])/determinant;\n\n        inverse.mat[4] = (this.mat[7]*this.mat[10]*this.mat[12] -\n            this.mat[6]*this.mat[11]*this.mat[12] -\n            this.mat[7]*this.mat[8]*this.mat[14] +\n            this.mat[4]*this.mat[11]*this.mat[14] +\n            this.mat[6]*this.mat[8]*this.mat[15] -\n            this.mat[4]*this.mat[10]*this.mat[15])/determinant;\n            \n        inverse.mat[5] = (this.mat[2]*this.mat[11]*this.mat[12] -\n            this.mat[3]*this.mat[10]*this.mat[12] +\n            this.mat[3]*this.mat[8]*this.mat[14] -\n            this.mat[0]*this.mat[11]*this.mat[14] -\n            this.mat[2]*this.mat[8]*this.mat[15] +\n            this.mat[0]*this.mat[10]*this.mat[15])/determinant;\n            \n        inverse.mat[6] = (this.mat[3]*this.mat[6]*this.mat[12] -\n            this.mat[2]*this.mat[7]*this.mat[12] -\n            this.mat[3]*this.mat[4]*this.mat[14] +\n            this.mat[0]*this.mat[7]*this.mat[14] +\n            this.mat[2]*this.mat[4]*this.mat[15] -\n            this.mat[0]*this.mat[6]*this.mat[15])/determinant;\n            \n        inverse.mat[7] = (this.mat[2]*this.mat[7]*this.mat[8] -\n            this.mat[3]*this.mat[6]*this.mat[8] +\n            this.mat[3]*this.mat[4]*this.mat[10] -\n            this.mat[0]*this.mat[7]*this.mat[10] -\n            this.mat[2]*this.mat[4]*this.mat[11] +\n            this.mat[0]*this.mat[6]*this.mat[11])/determinant;\n            \n        inverse.mat[8] = (this.mat[5]*this.mat[11]*this.mat[12] -\n            this.mat[7]*this.mat[9]*this.mat[12] +\n            this.mat[7]*this.mat[8]*this.mat[13] -\n            this.mat[4]*this.mat[11]*this.mat[13] -\n            this.mat[5]*this.mat[8]*this.mat[15] +\n            this.mat[4]*this.mat[9]*this.mat[15])/determinant;\n            \n        inverse.mat[9] = (this.mat[3]*this.mat[9]*this.mat[12] -\n            this.mat[1]*this.mat[11]*this.mat[12] -\n            this.mat[3]*this.mat[8]*this.mat[13] +\n            this.mat[0]*this.mat[11]*this.mat[13] +\n            this.mat[1]*this.mat[8]*this.mat[15] -\n            this.mat[0]*this.mat[9]*this.mat[15])/determinant;\n            \n        inverse.mat[10] = (this.mat[1]*this.mat[7]*this.mat[12] -\n            this.mat[3]*this.mat[5]*this.mat[12] +\n            this.mat[3]*this.mat[4]*this.mat[13] -\n            this.mat[0]*this.mat[7]*this.mat[13] -\n            this.mat[1]*this.mat[4]*this.mat[15] +\n            this.mat[0]*this.mat[5]*this.mat[15])/determinant;\n            \n        inverse.mat[11] = (this.mat[3]*this.mat[5]*this.mat[8] -\n            this.mat[1]*this.mat[7]*this.mat[8] -\n            this.mat[3]*this.mat[4]*this.mat[9] +\n            this.mat[0]*this.mat[7]*this.mat[9] +\n            this.mat[1]*this.mat[4]*this.mat[11] -\n            this.mat[0]*this.mat[5]*this.mat[11])/determinant;\n            \n        inverse.mat[12] = (this.mat[6]*this.mat[9]*this.mat[12] -\n            this.mat[5]*this.mat[10]*this.mat[12] -\n            this.mat[6]*this.mat[8]*this.mat[13] +\n            this.mat[4]*this.mat[10]*this.mat[13] +\n            this.mat[5]*this.mat[8]*this.mat[14] -\n            this.mat[4]*this.mat[9]*this.mat[14])/determinant;\n            \n        inverse.mat[13] = (this.mat[1]*this.mat[10]*this.mat[12] -\n            this.mat[2]*this.mat[9]*this.mat[12] +\n            this.mat[2]*this.mat[8]*this.mat[13] -\n            this.mat[0]*this.mat[10]*this.mat[13] -\n            this.mat[1]*this.mat[8]*this.mat[14] +\n            this.mat[0]*this.mat[9]*this.mat[14])/determinant;\n        \n        inverse.mat[14] = (this.mat[2]*this.mat[5]*this.mat[12] -\n            this.mat[1]*this.mat[6]*this.mat[12] -\n            this.mat[2]*this.mat[4]*this.mat[13] +\n            this.mat[0]*this.mat[6]*this.mat[13] +\n            this.mat[1]*this.mat[4]*this.mat[14] -\n            this.mat[0]*this.mat[5]*this.mat[14])/determinant;\n        \n        inverse.mat[15] = (this.mat[1]*this.mat[6]*this.mat[8] -\n            this.mat[2]*this.mat[5]*this.mat[8] +\n            this.mat[2]*this.mat[4]*this.mat[9] -\n            this.mat[0]*this.mat[6]*this.mat[9] -\n            this.mat[1]*this.mat[4]*this.mat[10] +\n            this.mat[0]*this.mat[5]*this.mat[10])/determinant;\n\n        return inverse;\n    }\n\n    /**\n     * Inverts the matix and writes the result back into this matrix.\n     */\n    invert(): void\n    {\n        const inverseMatrix = this.inverse();\n        this.copy(inverseMatrix);\n    }\n\n    /**\n     * Transposes the Matrix4 object and returns a new Matrix4 object\n     * \n     * @returns A new Matrix4 object which is the transposed version of the current object\n     */\n    transpose(): Matrix4\n    {\n        return Matrix4.fromRowMajor(\n            this.mat[0], this.mat[1], this.mat[2], this.mat[3],\n            this.mat[4], this.mat[5], this.mat[6], this.mat[7],\n            this.mat[8], this.mat[9], this.mat[10], this.mat[11],\n            this.mat[12], this.mat[13], this.mat[14], this.mat[15]\n        );\n    }\n\n    /**\n     * Sets the matrix to a rotation matrix defined by Euler angles.\n     * \n     * @param x - The x-axis euler angle\n     * @param y - The y-axis euler angle\n     * @param z - The z-axis euler angle\n     * @param order - The order in which the euler angles should be applied\n     */\n    // based on the implementation in three.js\n    setEulerAngles(x: number, y: number, z: number, order = 'YZX'): void\n    {\n\t\tconst a = Math.cos(x)\n        const b = Math.sin(x);\n\t\tconst c = Math.cos(y);\n        const d = Math.sin(y);\n\t\tconst e = Math.cos(z);\n        const f = Math.sin(z);\n\n\t\tif (order == 'XYZ')\n        {\n\t\t\tconst ae = a * e, af = a * f, be = b * e, bf = b * f;\n\n\t\t\tthis.mat[ 0 ] = c * e;\n\t\t\tthis.mat[ 4 ] = - c * f;\n\t\t\tthis.mat[ 8 ] = d;\n\n\t\t\tthis.mat[ 1 ] = af + be * d;\n\t\t\tthis.mat[ 5 ] = ae - bf * d;\n\t\t\tthis.mat[ 9 ] = - b * c;\n\n\t\t\tthis.mat[ 2 ] = bf - ae * d;\n\t\t\tthis.mat[ 6 ] = be + af * d;\n\t\t\tthis.mat[ 10 ] = a * c;\n\t\t} \n        else if(order == 'YXZ')\n        {\n\t\t\tconst ce = c * e, cf = c * f, de = d * e, df = d * f;\n\n\t\t\tthis.mat[ 0 ] = ce + df * b;\n\t\t\tthis.mat[ 4 ] = de * b - cf;\n\t\t\tthis.mat[ 8 ] = a * d;\n\n\t\t\tthis.mat[ 1 ] = a * f;\n\t\t\tthis.mat[ 5 ] = a * e;\n\t\t\tthis.mat[ 9 ] = - b;\n\n\t\t\tthis.mat[ 2 ] = cf * b - de;\n\t\t\tthis.mat[ 6 ] = df + ce * b;\n\t\t\tthis.mat[ 10 ] = a * c;\n        }\n        else if(order == 'ZXY')\n        {\n            const ce = c * e, cf = c * f, de = d * e, df = d * f;\n\n            this.mat[ 0 ] = ce - df * b;\n            this.mat[ 4 ] = - a * f;\n            this.mat[ 8 ] = de + cf * b;\n\n            this.mat[ 1 ] = cf + de * b;\n            this.mat[ 5 ] = a * e;\n            this.mat[ 9 ] = df - ce * b;\n\n            this.mat[ 2 ] = - a * d;\n            this.mat[ 6 ] = b;\n            this.mat[ 10 ] = a * c;\n\t\t} \n        else if(order === 'ZYX')\n        {\n\t\t\tconst ae = a * e, af = a * f, be = b * e, bf = b * f;\n\n\t\t\tthis.mat[ 0 ] = c * e;\n\t\t\tthis.mat[ 4 ] = be * d - af;\n\t\t\tthis.mat[ 8 ] = ae * d + bf;\n\n\t\t\tthis.mat[ 1 ] = c * f;\n\t\t\tthis.mat[ 5 ] = bf * d + ae;\n\t\t\tthis.mat[ 9 ] = af * d - be;\n\n\t\t\tthis.mat[ 2 ] = - d;\n\t\t\tthis.mat[ 6 ] = b * c;\n\t\t\tthis.mat[ 10 ] = a * c;\n\t\t}\n        else if(order === 'YZX')\n        {\n\t\t\tconst ac = a * c, ad = a * d, bc = b * c, bd = b * d;\n\n\t\t\tthis.mat[ 0 ] = c * e;\n\t\t\tthis.mat[ 4 ] = bd - ac * f;\n\t\t\tthis.mat[ 8 ] = bc * f + ad;\n\n\t\t\tthis.mat[ 1 ] = f;\n\t\t\tthis.mat[ 5 ] = a * e;\n\t\t\tthis.mat[ 9 ] = - b * e;\n\n\t\t\tthis.mat[ 2 ] = - d * e;\n\t\t\tthis.mat[ 6 ] = ad * f + bc;\n\t\t\tthis.mat[ 10 ] = ac - bd * f;\n\t\t} \n        else if(order === 'XZY') \n        {\n\t\t\tconst ac = a * c, ad = a * d, bc = b * c, bd = b * d;\n\n\t\t\tthis.mat[ 0 ] = c * e;\n\t\t\tthis.mat[ 4 ] = - f;\n\t\t\tthis.mat[ 8 ] = d * e;\n\n\t\t\tthis.mat[ 1 ] = ac * f + bd;\n\t\t\tthis.mat[ 5 ] = a * e;\n\t\t\tthis.mat[ 9 ] = ad * f - bc;\n\n\t\t\tthis.mat[ 2 ] = bc * f - ad;\n\t\t\tthis.mat[ 6 ] = b * e;\n\t\t\tthis.mat[ 10 ] = bd * f + ac;\n\t\t}\n\n\t\t// bottom row\n\t\tthis.mat[ 3 ] = 0;\n\t\tthis.mat[ 7 ] = 0;\n\t\tthis.mat[ 11 ] = 0;\n\n\t\t// last column\n\t\tthis.mat[ 12 ] = 0;\n\t\tthis.mat[ 13 ] = 0;\n\t\tthis.mat[ 14 ] = 0;\n\t\tthis.mat[ 15 ] = 1;\n    }\n\n    \n    /**\n     * Sets the matrix to a composition of three basic transformations (this = T * R * S), where \n     * scale is applied first, then rotation, then translation.\n     * \n     * @param position - The position of the Matrix4 object (default Vector3.ZERO)\n     * @param rotation - The rotation of the Matrix4 object (default Quaternion.IDENTITY)\n     * @param scale - The scale of the Matrix4 object (default Vector3.ONE)\n     */\n    compose(position: Vector3, rotation: Quaternion, scale: Vector3): void\n    {\n        this.setScale(scale);\n        this.premultiply(Matrix4.makeRotation(rotation));\n\n        this.mat[12] = position.x;\n        this.mat[13] = position.y;\n        this.mat[14] = position.z;\n    }\n\n    /**\n     * Multiplies point p by this 4x4 transformation matrix and returns the result as a new point.  This has the effect of\n     * transforming p from the matrix's local coordinate system to its parent coordinate system.  The multiplication is done\n     * using homogeneous coordinates (p is treated as having a w=1 coordinate).\n     * \n     * @param p The original point\n     * @returns A new point transformed by m\n     */\n    transformPoint(p: Vector3): Vector3\n    {\n        const result = new Vector3();\n        const w = 1 / (this.mat[3]*p.x + this.mat[7]*p.y + this.mat[11]*p.z + this.mat[15]);\n        result.x = w * (this.mat[0]*p.x + this.mat[4]*p.y + this.mat[8]*p.z + this.mat[12]);\n        result.y = w * (this.mat[1]*p.x + this.mat[5]*p.y + this.mat[9]*p.z + this.mat[13]);\n        result.z = w * (this.mat[2]*p.x + this.mat[6]*p.y + this.mat[10]*p.z + this.mat[14]);\n        return result;\n    }\n\n    /**\n     * Multiplies vector v by this 4x4 transformation matrix and returns the result as a new vector.  This has the effect of\n     * transforming v from the matrix's local coordinate system to its parent coordinate system.  The multiplication is done\n     * using homogeneous coordinates (v is treated as having a w=0 coordinate).\n     * \n     * @param v The original vector\n     * @returns A new vector transformed by m\n     */\n    transformVector(v: Vector3): Vector3\n    {\n        const result = new Vector3();\n        const w = 1 / (this.mat[3]*v.x + this.mat[7]*v.y + this.mat[11]*v.z + this.mat[15]);\n        result.x = w * (this.mat[0]*v.x + this.mat[4]*v.y + this.mat[8]*v.z);\n        result.y = w * (this.mat[1]*v.x + this.mat[5]*v.y + this.mat[9]*v.z);\n        result.z = w * (this.mat[2]*v.x + this.mat[6]*v.y + this.mat[10]*v.z);\n        return result;\n    }\n\n    /**\n     * Returns the first three elements of column i as a new Vector3.\n     * @param i The zero-based index of the column (0..3)\n     * @returns A new Vector3\n     */\n    getColumn(i: number): Vector3\n    {\n        return new Vector3(this.mat[i], this.mat[i+4], this.mat[i+8]);\n    }\n\n    /**\n     * Returns the first three elements of row i as a new Vector3.\n     * @param i The zero-based index of the row (0..3)\n     * @returns A new Vector3.\n     */\n    getRow(i: number): Vector3\n    {\n        return new Vector3(this.mat[i*4], this.mat[i*4+1], this.mat[i*4+2]);\n    }\n\n    /**\n     * Sets the first three elements of column i using the x, y, z components of the supplied vector.\n     * @param col The zero-based index of the column (0..3)\n     * @param v A vector containing the new values for the column\n     */\n    setColumn(col: number, v: Vector3): void\n    {\n        this.mat[col] = v.x;\n        this.mat[col+4] = v.y;\n        this.mat[col+8] = v.z;\n    }\n\n    /**\n     * Sets the first three elements of row i using the x, y, z components of the supplied vector.\n     * @param row The zero-based index of the row (0..3)\n     * @param v A vector containing the new values for the row\n     */\n    setRow(row: number, v: Vector3): void\n    {\n        this.mat[row*4] = v.x;\n        this.mat[row*4+1] = v.y;\n        this.mat[row*4+2] = v.z;\n    }\n\n    /**\n     * Decomposes the 4x4 transformation matrix into separate translation, rotation, and scale components such\n     * that the original matrix can be represented as a combination of transformations in the form T * R * S.\n     * The decomposition is straightforward (relatively efficient) if the matrix does not include a negative\n     * scale.  If the matrix includes a negative scale factor, a slower polar decomposition must be used,\n     * and the caller must explicitly set the containsNegScale to true.\n     * \n     * @param containsNegScale Set to true if the matrix includes a negative scale factor.\n     * @returns An array of three elements [translation: Vector3, rotation: Quaternion, scale: Vector3]\n     */\n    decompose(containsNegScale: boolean): [Vector3, Quaternion, Vector3]\n    {\n        const position = new Vector3();\n        const rotation = new Quaternion();\n        const scale = new Vector3();\n\n        const matrixCopy = this.clone();\n\n        // Extract translation component of the matrix\n        position.set(matrixCopy.mat[12], matrixCopy.mat[13], matrixCopy.mat[14]);\n        matrixCopy.mat[12] = 0;\n        matrixCopy.mat[13] = 0;\n        matrixCopy.mat[14] = 0;\n\n        // Zero out any projection components of the matrix\n        matrixCopy.mat[3] = 0;\n        matrixCopy.mat[7] = 0;\n        matrixCopy.mat[11] = 0;\n        matrixCopy.mat[15] = 1;\n\n        if(containsNegScale)\n        {\n            // If the matrix includes negative scales, then the rotation and scale\n            // can be extracted using the polar decomposition method described here\n            // http://callumhay.blogspot.com/2010/10/decomposing-affine-transforms.html\n\n            // Extract the rotation component - this is done using polar decompostion, where\n            // we successively average the matrix with its inverse transpose until there is\n            // no/a very small difference between successive averages\n            let rotationMatrix = new Matrix4();\n            let count = 0;\n            let norm;\n            do \n            {\n                const currentInverseTranspose = rotationMatrix.transpose();\n                currentInverseTranspose.invert();\n\n                // Go through every component in the matrices and find the next matrix\n                const nextRotationMatrix = new Matrix4();\n                for(let i=0; i<16; i++)\n                {\n                    nextRotationMatrix.mat[i] = 0.5 * (rotationMatrix.mat[i] + currentInverseTranspose.mat[i]);\n                }\n\n                norm = 0;\n\n                for (let i = 0; i < 3; i++) \n                {\n                    const n = Math.abs(rotationMatrix.mat[i] - nextRotationMatrix.mat[i]) +\n                              Math.abs(rotationMatrix.mat[i+4] - nextRotationMatrix.mat[i+4]) +\n                              Math.abs(rotationMatrix.mat[i+8] - nextRotationMatrix.mat[i+8]);\n                    norm = Math.max(norm, n);\n                }\n\n                rotationMatrix = nextRotationMatrix;\n                count ++;\n            }\n            while(count < 100 && norm > Number.EPSILON);\n\n            // Set the quaternion based on the extracted rotation matrix\n            rotation.setMatrix(rotationMatrix);\n\n            // The scale is simply the removal of the rotation from the non-translated matrix\n            const scaleMatrix = Matrix4.multiply(rotationMatrix.inverse(), matrixCopy);\n            scale.set(scaleMatrix.mat[0], scaleMatrix.mat[5], scaleMatrix.mat[10]);\n\n            // Special consideration: if there's a single negative scale (all other combinations of negative \n            // scales will be part of the rotation matrix), the determinant of the normalized rotation matrix\n            // will be < 0.  If this is the case we apply a negative to one arbitrary component of the scale.\n            const row0 = matrixCopy.getRow(0);\n            const row1 = matrixCopy.getRow(1);\n            const row2 = matrixCopy.getRow(2);\n            row0.normalize();\n            row1.normalize();\n            row2.normalize();\n\n            const normalizedRotationMatrix = new Matrix4();\n            normalizedRotationMatrix.setRow(0, row0);\n            normalizedRotationMatrix.setRow(1, row1);\n            normalizedRotationMatrix.setRow(2, row2);\n            if (normalizedRotationMatrix.determinant() < 0.0) \n            {\n                scale.x *= -1;\n            }    \n        }\n        else\n        {\n            // If the matrix does not include negative scales\n            // then we can decompose the matrix more efficiently\n\n            // Extract scale component of the matrix\n            const sx = matrixCopy.getColumn(0).length();\n            const sy = matrixCopy.getColumn(1).length();\n            const sz = matrixCopy.getColumn(2).length();\n            scale.set(sx, sy, sz);\n\n            // Remove scale component from the matrix\n            matrixCopy.multiply(Matrix4.makeScale(new Vector3(1 / sx, 1 / sy, 1 / sz)));\n\n            // Set the rotation quaternion from the pure rotation matrix\n            rotation.setMatrix(matrixCopy);\n        }\n\n        return [position, rotation, scale];\n    }\n\n    /**\n     * Checks if every element of this Matrix4 is exactly equal to every element of the given Matrix4\n     *\n     * @param other - The other Matrix3 to compare to\n     * @returns A boolean value indicating if the two matrices are equal\n     */\n    equals(other: Matrix4): boolean\n    {\n        for (let i=0; i<16; i++) {\n            if (this.mat[i] != other.mat[i]) \n                return false;\n        }\n        return true;\n    }\n\n    /**\n     * Checks if  every element of this Matrix4 is exactly equal (within a small value of epsilon) to\n     * every element of the given Matrix4  \n     *\n     * @param other - The other Matrix3 to compare to\n     * @param epsilon - A small value of acceptable variance to account for numerical instability\n     * @returns A boolean value indicating if the two matrices are equal\n     */\n    fuzzyEquals(other: Matrix4, epsilon: number = MathUtils.EPSILON): boolean\n    {\n        for (let i=0; i<16; i++) {\n            if (Math.abs(this.mat[i] - other.mat[i]) < epsilon) \n                return false;\n        }\n        return true;\n    }\n}", "import { Matrix4 } from \"./Matrix4\";\nimport { Vector3 } from \"./Vector3\"\n\nexport class BoundingBox3 \n{\n    public min: Vector3;\n    public max: Vector3;\n\n/**\n * Constructs a BoundingBox3 object.\n */\n    constructor()\n    {\n        this.min = new Vector3();\n        this.max = new Vector3();\n    }\n\n/**\n * Copies the minimum and maximum values of another BoundingBox3 object into this one.\n * \n * @param box - The BoundingBox3 object to copy\n */\n    copy(box: BoundingBox3): void\n    {\n        this.min.copy(box.min);\n        this.max.copy(box.max);\n    }\n\n    /**\n     * Transforms the BoundingBox3 using a transformation matrix\n     * \n     * @param m - The transformation matrix\n     */\n    transform(m: Matrix4)\n    {\n        // Compute new axis-aligned bounding box\n        const corners: Vector3[] = [];\n        corners.push(new Vector3(this.min.x, this.min.y, this.min.z));\n        corners.push(new Vector3(this.min.x, this.min.y, this.max.z));\n        corners.push(new Vector3(this.min.x, this.max.y, this.min.z));\n        corners.push(new Vector3(this.min.x, this.max.y, this.max.z));\n        corners.push(new Vector3(this.max.x, this.min.y, this.min.z));\n        corners.push(new Vector3(this.max.x, this.min.y, this.max.z));\n        corners.push(new Vector3(this.max.x, this.max.y, this.min.z));\n        corners.push(new Vector3(this.max.x, this.max.y, this.max.z));\n\n        corners.forEach((p: Vector3)=>{\n            p.transformPoint(m);\n        });\n\n        this.min.copy(corners[0]);\n        this.max.copy(corners[0]);\n        for(let i=1; i < corners.length; i++)\n        {\n            this.min.x = Math.min(this.min.x, corners[i].x);\n            this.min.y = Math.min(this.min.y, corners[i].y);\n            this.min.z = Math.min(this.min.z, corners[i].z);\n\n            this.max.x = Math.max(this.max.x, corners[i].x);\n            this.max.y = Math.max(this.max.y, corners[i].y);\n            this.max.z = Math.max(this.max.z, corners[i].z);\n        }\n    }\n\n    /**\n     * Checks if this BoundingBox3 object intersects with the provided BoundingBox3 object\n     * \n     * @param box - The BoundingBox3 object to check intersection against\n     * @returns True if the boxes intersect, false otherwise\n     */\n    intersects(box: BoundingBox3): boolean\n    {\n        const thisCenter = Vector3.add(this.max, this.min);\n        thisCenter.multiplyScalar(0.5);\n\n        const otherCenter = Vector3.add(box.max, box.min);\n        otherCenter.multiplyScalar(0.5);\n\n        const thisHalfWidth = Vector3.subtract(this.max, this.min);\n        thisHalfWidth.multiplyScalar(0.5);\n\n        const otherHalfWidth = Vector3.subtract(box.max, box.min);\n        otherHalfWidth.multiplyScalar(0.5);\n\n        if(Math.abs(thisCenter.x - otherCenter.x) > (thisHalfWidth.x + otherHalfWidth.x))\n            return false;\n        else if(Math.abs(thisCenter.y - otherCenter.y) > (thisHalfWidth.y + otherHalfWidth.y))\n            return false;\n        else if(Math.abs(thisCenter.z - otherCenter.z) > (thisHalfWidth.z + otherHalfWidth.z))\n            return false;\n        else\n            return true;\n    }\n\n    /**\n     * Computes the minimum and maximum Vector3 objects for the BoundingBox3 from a given array of vertices\n     * \n     * @param vertices - An array of Vector3 or number objects with the vertices\n     */\n    computeBounds(vertices: Vector3[] | number[]): void\n    {\n        if(typeof vertices[0] === 'number')\n        {\n            const vArray = vertices as number[];\n\n            this.max.set(vArray[0], vArray[1], vArray[2]);\n            this.min.set(vArray[0], vArray[1], vArray[2]);\n            \n            for(let i=0; i < vArray.length; i+=3)\n            {\n                if(vArray[i] > this.max.x)\n                    this.max.x = vArray[i];\n                if(vArray[i] < this.min.x)\n                    this.min.x = vArray[i];\n\n                if(vArray[i+1] > this.max.y)\n                    this.max.y = vArray[i+1];\n                if(vArray[i+1] < this.min.y)\n                    this.min.y = vArray[i+1];\n\n                if(vArray[i+2] > this.max.z)\n                    this.max.z = vArray[i+2];\n                if(vArray[i+2] < this.min.z)\n                    this.min.z = vArray[i+2];    \n            }\n        }\n        else\n        {\n            this.max.copy((vertices as Vector3[])[0]);\n            this.min.copy((vertices as Vector3[])[0]);\n\n            (vertices as Vector3[]).forEach((elem: Vector3) =>\n            {\n                if(elem.x > this.max.x)\n                    this.max.x = elem.x;\n                if(elem.x < this.min.x)\n                    this.min.x = elem.x;\n\n                if(elem.y > this.max.y)\n                    this.max.y = elem.y;\n                if(elem.y < this.min.y)\n                    this.min.y =elem.y;\n\n                if(elem.z > this.max.z)\n                    this.max.z = elem.z;\n                if(elem.z < this.min.z)\n                    this.min.z = elem.z;\n            });\n        }\n    }\n}", "import { BoundingBox3 } from \"./BoundingBox3\";\nimport { Vector3 } from \"./Vector3\"\nimport { Matrix4 } from \"./Matrix4\";\n\nexport class BoundingSphere \n{\n    public center: Vector3;\n    public radius: number;\n\n/**\n * Constructs a BoundingSphere\n */    \n    constructor()\n    {\n        this.center = new Vector3();\n        this.radius = 0;\n    }\n\n/**\n * Copies the given BoundingSphere into the current one\n * \n * @param circle - The BoundingSphere object to copy\n */\n    copy(circle: BoundingSphere): void\n    {\n        this.center.copy(circle.center);\n        this.radius = circle.radius;\n    }\n\n    /**\n     * Transforms the BoundingCircle using a transformation matrix\n     * \n     * @param m - The transformation matrix\n     */\n    transform(m: Matrix4)\n    {\n        // Compute new local bounding circle center\n        this.center.add(m.getTranslation());\n        \n        // Compute new local bounding circle radius\n        const radiusVector = new Vector3(this.radius, 0);\n        radiusVector.transformVector(m);\n        this.radius = radiusVector.length();\n    }\n\n    /**\n     * Checks if the given BoundingSphere intersects with the current one\n     * \n     * @param circle - The BoundingSphere to check against\n     * @returns True if the two BoundingSpheres intersect, false otherwise\n     */\n   intersects(circle: BoundingSphere): boolean\n    {\n        const distance = this.center.distanceTo(circle.center);\n\n        if(distance < (this.radius + circle.radius))\n            return true;\n        else\n            return false;\n    }\n\n    /**\n     * Computes the bounds of the BoundingSphere from the given vertices\n     * \n     * @param vertices - The array of Vector3 or number objects representing the vertices\n     * @param boundingBox - The BoundingBox3 object to use when computing the bounds\n     */\n    computeBounds(vertices: Vector3[] | number[], boundingBox: BoundingBox3): void\n    {\n        this.center.copy(boundingBox.min);\n        this.center.add(boundingBox.max);\n        this.center.multiplyScalar(0.5);\n        this.radius = 0;\n        if(typeof vertices[0] === 'number')\n        {\n            const vArray = vertices as number[];\n            for(let i=0; i < vArray.length; i+=3)\n            {\n                const distance = Math.sqrt(\n                    (vArray[i] - this.center.x) * (vArray[i] - this.center.x) +\n                    (vArray[i+1] - this.center.y) * (vArray[i+1] - this.center.y) +\n                    (vArray[i+2] - this.center.z) * (vArray[i+2] - this.center.z)\n                );\n                \n                if(distance > this.radius)\n                    this.radius = distance;\n            }\n        }\n        else\n        {\n            (vertices as Vector3[]).forEach((elem: Vector3) =>\n            {\n                const distance = elem.distanceTo(this.center);\n\n                if(distance > this.radius)\n                    this.radius = distance;\n            });\n        }\n    }\n}", "import { Matrix4 } from \"../math/Matrix4\";\nimport { Quaternion } from \"../math/Quaternion\";\nimport { Vector3 } from \"../math/Vector3\";\nimport { Camera } from \"./Camera\";\nimport { LightManager } from \"../lights/LightManager\";\nimport { BoundingBox3 } from \"../math/BoundingBox3\";\nimport { BoundingSphere } from \"../math/BoundingSphere\"\n\nexport enum IntersectionMode3 {\n    BOUNDING_SPHERE,\n    AXIS_ALIGNED_BOUNDING_BOX\n}\n\nexport enum CoordinateSpace3 {\n    LOCAL_SPACE,\n    WORLD_SPACE\n}\n\n/**\n * This is the base class for all objects that can be added to a GopherGfx 3D scene.  It is named \"Node\"\n * because the scene is stored in a graph data structure, so we think of every element in that graph\n * as a \"node\" in the graph.  There is also a \"Node2\" base class for all objects that can be added to\n * the 2D scene.  \n * \n * Every object that can be added to a 3D scene (e.g., Lights, Mesh3s) will inherit from this base object.\n * So, every object in the scene will have a position, rotation, scale, boundingBox, boundingSphere, \n * visibility, and all of the other properties listed in this class.\n * \n * For more detail on how the scene graph works, see the documentation for the Scene class.\n */\nexport class Node3\n {\n    /**\n     * The position of this node as a Vector3.\n     */\n    protected _position: Vector3;\n\n    /**\n     * The rotation of this transform represented as a quaternion.\n     */\n    protected _rotation: Quaternion;\n    \n    /**\n     * The scale of this node as a Vector3.\n     * */\n    protected _scale: Vector3;\n\n    /**\n     * The local transformation matrix of this node.\n     */\n    protected localToParentMatrix: Matrix4;\n\n    /**\n     * The world transformation matrix of this node.\n     */\n    public localToWorldMatrix: Matrix4;\n\n    protected localMatrixDirty: boolean;\n    protected localMatrixUpdated: boolean;\n    protected localMatrixNegScale: boolean;\n    protected worldMatrixDirty: boolean;\n\n    /*\n    An array of child nodes that are attached to this nodes.\n    */\n    public children: Array<Node3>;\n\n    /**\n    Whether this transform is currently visible in the scene.\n    */\n    public visible: boolean;\n\n    /**\n    The parent transform of this transform. Null if this transform has no parent.\n    */\n    public parent: Node3 | null;\n\n    /**\n    The bounding box in vertex coordinate space\n    */\n    public boundingBox: BoundingBox3;\n\n    /**\n    The bounding sphere in vertex coordinate space\n    */\n    public boundingSphere: BoundingSphere;\n\n    /**\n     * Bounding box in this transform's local coordinate space\n     */\n    protected _localBoundingBox: BoundingBox3;\n\n    /**\n     * Bounding circle in this transform's local coordinate space\n     */\n    protected _localBoundingSphere: BoundingSphere;\n\n    /**\n     * Bounding box in the world coordinate space\n     */\n    protected _worldBoundingBox: BoundingBox3;\n\n    /**\n     * Bounding box in the world coordinate space\n     */\n    protected _worldBoundingSphere: BoundingSphere;\n\n    public localBoundsDirty: boolean;\n    public worldBoundsDirty: boolean;\n\n    /**\n    Constructs a new Node3 object.\n    */\n    constructor() \n    {\n        this._position = new Vector3();\n        this._rotation = new Quaternion();\n        this._scale = new Vector3(1, 1, 1);\n\n        this.localToParentMatrix = new Matrix4();\n        this.localToWorldMatrix = new Matrix4();\n\n        this.localMatrixDirty = false;\n        this.localMatrixUpdated = false;\n        this.localMatrixNegScale = false;\n        this.worldMatrixDirty = false;\n\n        this.children = [];\n        \n        this.visible = true;\n        this.parent = null;\n\n        this.boundingBox = new BoundingBox3();\n        this.boundingSphere = new BoundingSphere();\n        this._localBoundingBox = new BoundingBox3();\n        this._localBoundingSphere = new BoundingSphere();\n        this._worldBoundingBox = new BoundingBox3();\n        this._worldBoundingSphere = new BoundingSphere();\n\n        this.localBoundsDirty = false;\n        this.worldBoundsDirty = false;\n    }\n\n    public get position()\n    {\n        if(this.localMatrixUpdated)\n        {\n            this.decomposeLocalMatrix();\n        }\n        \n        this.localMatrixDirty = true;\n        return this._position;\n    }\n\n    public set position(value: Vector3)\n    {\n        this.localMatrixDirty = true;\n        this._position = value;\n    }\n\n    public get rotation()\n    {\n        if(this.localMatrixUpdated)\n        {\n            this.decomposeLocalMatrix();\n        }\n\n        this.localMatrixDirty = true;\n        return this._rotation;\n    }\n\n    public set rotation(value: Quaternion)\n    {\n        this.localMatrixDirty = true;\n        this._rotation = value;\n    }\n\n    public get scale()\n    {\n        if(this.localMatrixUpdated)\n        {\n            this.decomposeLocalMatrix();\n        }\n\n        this.localMatrixDirty = true;\n        return this._scale;\n    }\n\n    public set scale(value: Vector3)\n    {\n        this.localMatrixDirty = true;\n        this._scale = value;\n    }\n\n    public getLocalToParentMatrix(): Matrix4\n    {\n        if(this.localMatrixDirty)\n        {\n            this.composeLocalMatrix();\n        }\n\n        return this.localToParentMatrix.clone();\n    }\n\n    public setLocalToParentMatrix(matrix: Matrix4, includesNegScale: boolean): void\n    {\n        this.localToParentMatrix.copy(matrix);  \n        this.localMatrixUpdated = true;\n        this.localMatrixNegScale = includesNegScale; \n        this.worldMatrixDirty = true;\n        this.localBoundsDirty = true;\n    }\n\n    public get localBoundingBox()\n    {\n        if(this.localBoundsDirty)\n        {\n            this.updateLocalBounds();\n        }\n\n        return this._localBoundingBox;\n    }\n\n    public set localBoundingBox(value: BoundingBox3)\n    {\n        this._localBoundingBox = value;\n    }\n\n    public get localBoundingSphere()\n    {\n        if(this.localBoundsDirty)\n        {\n            this.updateLocalBounds();\n        }\n\n        return this._localBoundingSphere;\n    }\n\n    public set localBoundingSphere(value: BoundingSphere)\n    {\n        this._localBoundingSphere = value;\n    }\n\n    public get worldBoundingBox()\n    {\n        if(this.worldBoundsDirty)\n        {\n            this.updateWorldBounds();\n        }\n\n        return this._worldBoundingBox;\n    }\n\n    public set worldBoundingBox(value: BoundingBox3)\n    {\n        this._worldBoundingBox = value;\n    }\n\n    public get worldBoundingSphere()\n    {\n        if(this.worldBoundsDirty)\n        {\n            this.updateWorldBounds();\n        }\n\n        return this._worldBoundingSphere;\n    }\n\n    public set worldBoundingSphere(value: BoundingSphere)\n    {\n        this._worldBoundingSphere = value;\n    }\n\n    /**\n     * Traverses the scene graph starting from this Node3 object and updates the world matrices of all\n     * Node3 objects in the graph.\n     */\n    traverseSceneGraph(parentMatrixDirty = false): void \n    {\n        const worldMatrixDirty = parentMatrixDirty || this.localMatrixDirty || this.worldMatrixDirty;\n\n        if(this.localMatrixDirty) \n        {\n            this.composeLocalMatrix();\n        }\n\n        if(worldMatrixDirty)\n        {\n            this.localToWorldMatrix.copy(this.localToParentMatrix);\n\n            if(this.parent)\n            {  \n                this.localToWorldMatrix.premultiply(this.parent.localToWorldMatrix);\n            }\n\n            this.worldBoundsDirty = true;\n            this.worldMatrixDirty = false;\n        }\n\n        this.children.forEach((elem: Node3) => {\n            elem.traverseSceneGraph(worldMatrixDirty);\n        });\n    }\n\n    /**\n    Updates the world matrix of this Node3 by computing the multiplication\n    of its local matrix with its parent's world matrix (if it has a parent).\n    @returns void\n    */\n    updateWorldMatrix(): void \n    {\n        if(this.localMatrixDirty) \n        {\n            this.composeLocalMatrix();\n        }\n\n        this.localToWorldMatrix.copy(this.localToParentMatrix);\n\n        if (this.parent) \n        {\n            this.parent.updateWorldMatrix();\n            this.localToWorldMatrix.premultiply(this.parent.localToWorldMatrix);\n        }\n\n        this.worldBoundsDirty = true;\n        this.worldMatrixDirty = false;  \n    }\n\n    /**\n     * Adds a child Node3 to the current Node3\n     * @param child - The Node3 to be added\n     */\n    add(child: Node3) {\n        this.children.push(child);\n        child.parent = this;\n    }\n\n    /**\n     * Removes the current Node3 from its parent Node3 \n     * @returns true if the Node3 was successfully removed, false otherwise\n     */\n    remove(): boolean {\n        if (this.parent == null)\n            return false;\n        else\n            return this.parent.removeChild(this) != null;\n    }\n\n    /**\n     * Removes the given child Node3 from the current Node3\n     * @param child - The Node3 to be removed\n     * @returns The removed Node3 if found, null otherwise\n     */\n    removeChild(child: Node3): Node3 | null {\n        const index = this.children.indexOf(child);\n\n        if (index == -1) {\n            return null;\n        }\n        else {\n            const removedElement = this.children.splice(index, 1);\n            removedElement[0].parent = null;\n            return removedElement[0];\n        }\n    }\n\n    /**\n    Draws this transform and all its children in the scene graph.\n    @param parent - The parent transform of this transform.\n    @param camera - The camera used to view the scene.\n    @param lightManager - The light manager used to manage the lights in the scene.\n    */\n    draw(parent: Node3, camera: Camera, lightManager: LightManager): void {\n        if (!this.visible)\n            return;\n\n        this.children.forEach((elem: Node3) => {\n            elem.draw(this, camera, lightManager);\n        });\n    }\n\n    /**\n     * Sets lights on the children of the Node3\n     * @param lightManager - The LightManager object\n     */\n    setLights(lightManager: LightManager): void {\n        this.children.forEach((elem) => {\n            elem.setLights(lightManager);\n        });\n    }\n\n    /**\n    * Rotates this Node3 object to look at the given target with the given up vector\n    * \n    * @param target - The Vector3 representing the target in world space\n    * @param up - The Vector3 representing the up direction (defaults to Vector3.UP)\n    */\n    lookAt(target: Vector3, up = Vector3.UP, coordinateSpace = CoordinateSpace3.LOCAL_SPACE): void\n    {\n        if(coordinateSpace == CoordinateSpace3.LOCAL_SPACE)\n        {\n            this._rotation.lookAt(this.position, target, up);\n            this.localMatrixDirty = true;\n        }\n        else\n        {\n            this.updateWorldMatrix();\n            const worldPosition = this.localToWorldMatrix.getTranslation();\n            this._rotation.lookAt(worldPosition, target, up);\n            this.localMatrixDirty = true;\n        }\n    }\n\n    public composeLocalMatrix(): void\n    {\n        this.localMatrixNegScale = this._scale.x < 0 || this._scale.y < 0 || this._scale.z < 0;\n        this.localMatrixDirty = false;\n        this.localMatrixUpdated = false;\n        this.worldMatrixDirty = true;\n        this.localBoundsDirty = true;\n        this.localToParentMatrix.compose(this._position, this._rotation, this._scale);\n    }\n\n    public decomposeLocalMatrix(): void\n    {\n        this.localMatrixDirty = false;\n        this.localMatrixUpdated = false;\n\n        [this._position, this._rotation, this._scale] = this.localToParentMatrix.decompose(this.localMatrixNegScale);\n    }\n\n    updateLocalBounds(): void\n    {\n        this._localBoundingBox.copy(this.boundingBox);\n        this._localBoundingBox.transform(this.localToParentMatrix);\n        this._localBoundingSphere.copy(this.boundingSphere);\n        this._localBoundingSphere.transform(this.localToParentMatrix);\n        this.localBoundsDirty = false;\n    }\n\n    updateWorldBounds(): void\n    {\n        this._worldBoundingBox.copy(this.boundingBox);\n        this._worldBoundingBox.transform(this.localToWorldMatrix);\n        this._worldBoundingSphere.copy(this.boundingSphere);\n        this._worldBoundingSphere.transform(this.localToWorldMatrix)\n        this.worldBoundsDirty = false;\n    }\n\n    /**\n     * Checks for intersection between this Node3 and another\n     * \n     * @param other - The other Node3 object\n     * @param mode - The IntersectionMode3 to use for the comparison (default: BOUNDING_SPHERE)\n     * @param space - The CoordinateSpace3 to use for the comparison (default: LOCAL_SPACE)\n     * @returns Whether or not the two objects intersect\n     */\n    intersects(other: Node3, mode = IntersectionMode3.BOUNDING_SPHERE, space = CoordinateSpace3.LOCAL_SPACE): boolean \n    {\n        if(space == CoordinateSpace3.LOCAL_SPACE)\n        {\n            if(this.localMatrixDirty)\n                this.composeLocalMatrix();\n\n            if(other.localMatrixDirty)\n                other.composeLocalMatrix();\n\n            if(this.localBoundsDirty)\n                this.updateLocalBounds();\n\n            if(other.localBoundsDirty)\n                other.updateLocalBounds();\n\n            if(mode == IntersectionMode3.BOUNDING_SPHERE)\n                return this._localBoundingSphere.intersects(other._localBoundingSphere);\n            else if(mode == IntersectionMode3.AXIS_ALIGNED_BOUNDING_BOX)\n                return this._localBoundingBox.intersects(other._localBoundingBox);\n            else\n                return false;\n        }\n        else\n        {\n            if(this.localMatrixDirty || this.worldMatrixDirty)\n                this.updateWorldMatrix();\n\n            if(this.localMatrixDirty || this.worldMatrixDirty)\n                other.updateWorldMatrix();\n\n            if(this.worldBoundsDirty)\n                this.updateWorldBounds();\n\n            if(other.worldBoundsDirty)\n                other.updateWorldBounds();\n\n            if(mode == IntersectionMode3.BOUNDING_SPHERE)\n                return this._worldBoundingSphere.intersects(other._worldBoundingSphere);\n            else if(mode == IntersectionMode3.AXIS_ALIGNED_BOUNDING_BOX)\n                return this._worldBoundingBox.intersects(other._worldBoundingBox);\n            else\n                return false;\n        }\n    }\n}", "import { Node3 } from './Node3'\nimport { Matrix4 } from '../math/Matrix4'\n\n\n/**\n * Camera class that extends Node3.\n*/\nexport class Camera extends Node3\n{\n    protected aspectRatio: number;\n    protected fov: number;\n    protected near: number;\n    protected far: number;\n    protected left: number;\n    protected right: number;\n    \n    /**\n     * The projection matrix of the camera.\n    */\n    public projectionMatrix: Matrix4;\n\n    /**\n     * The view matrix of the camera.\n    */\n    public viewMatrix: Matrix4;\n\n    /**\n     * Indicates if the projection matrix needs to be updated.\n    */\n    public projectionMatrixDirty: boolean;\n\n    constructor()\n    {\n        super();\n\n        this.fov = 0;\n        this.aspectRatio = 0;\n        this.near = 0;\n        this.far = 0;\n        this.left = 0;\n        this.right = 0;\n        this.projectionMatrixDirty = true;\n\n        this.projectionMatrix = new Matrix4();\n        this.viewMatrix = new Matrix4();\n    }\n\n    /**\n     * Sets the camera parameters for a perspective view\n     * \n     * @param fov - The field of view\n     * @param aspectRatio - The aspect ratio\n     * @param near - The near plane\n     * @param far - The far plane\n     */\n    public setPerspectiveCamera(fov: number, aspectRatio: number, near: number, far: number): void\n    {\n        this.fov = fov;\n        this.aspectRatio = aspectRatio;\n        this.near = near;\n        this.far = far;\n        this.projectionMatrixDirty = true;\n\n        this.projectionMatrix.setPerspective(fov, aspectRatio, near, far);\n    }\n\n    /**\n     * Sets the camera parameters for an orthographic view\n     * \n     * @param left - The left plane\n     * @param right - The right plane\n     * @param bottom - The bottom plane\n     * @param top - The top plane\n     * @param near - The near plane\n     * @param far - The far plane\n     */\n    public setOrthographicCamera(left: number, right: number, bottom: number, top: number, near: number, far: number): void\n    {\n        this.left = left;\n        this.right = right;\n        this.aspectRatio = Math.abs((right-left) / (top-bottom));\n        this.near = near;\n        this.far = far;\n        this.projectionMatrixDirty = true;\n\n        this.projectionMatrix.setOrthographic(left, right, bottom, top, near, far);\n    }\n    \n    /**\n     * Updates the camera's world matrix and view matrix\n     */\n    public updateWorldMatrix(): void\n    {\n        super.updateWorldMatrix();\n        this.viewMatrix = this.localToWorldMatrix.inverse();\n    }\n\n    /**\n     * Gets the aspect ratio of the camera\n     * \n     * @returns The aspect ratio of the camera\n     */\n    public getAspectRatio(): number\n    {\n        return this.aspectRatio;\n    }\n\n    /**\n     * Gets the distance from the camera to the near clipping plane\n     * \n     * @returns The distance from the camera to the near clipping plane\n     */\n    public getNear(): number\n    {\n        return this.near;\n    }\n\n    /**\n     * Gets the distance from the camera to the far clipping plane\n     * \n     * @returns The distance from the camera to the far clipping plane\n     */\n    public getFar(): number\n    {\n        return this.far;\n    }\n\n    /**\n     * Gets the leftmost x position an orthographic camera's view frustum\n     * \n     * @returns The leftmost x position for the camera's view frustum\n     */\n    public getLeft(): number\n    {\n        return this.left;\n    }\n\n    /**\n     * Gets the rightmost x position for an orthographic camera's view frustum\n     * \n     * @returns The rightmost x position for the camera's view frustum\n     */\n    public getRight(): number\n    {\n        return this.right;\n    }\n\n}", "import { Vector2 } from './Vector2'\n\nexport class Matrix3\n{\n    /**\n     *  A static Matrix3 object representing the identity matrix\n     */\n    public static readonly IDENTITY = new Matrix3();\n\n    /**\n     * An array of 9 numbers representing a 3x3 matrix\n     */\n    public mat: Array<number>;\n\n    /**\n     * Multiplies two 3x3 matrices, m1 and m2, and returns the result as a new Matrix3\n     * \n     * @param m1 - The first Matrix3 object to be multiplied\n     * @param m2 - The second Matrix3 object to be multiplied\n     * @returns A new Matrix3 object representing the product of m1 and m2\n     */ \n    static multiply(lhs: Matrix3, rhs: Matrix3): Matrix3\n    {\n        // Code from https://webglfundamentals.org/webgl/lessons/webgl-2d-matrices.html\n        const m = new Matrix3();\n        \n        m.mat[0] = rhs.mat[0] * lhs.mat[0] + rhs.mat[1] * lhs.mat[3] + rhs.mat[2] * lhs.mat[6];\n        m.mat[1] = rhs.mat[0] * lhs.mat[1] + rhs.mat[1] * lhs.mat[4] + rhs.mat[2] * lhs.mat[7];\n        m.mat[2] = rhs.mat[0] * lhs.mat[2] + rhs.mat[1] * lhs.mat[5] + rhs.mat[2] * lhs.mat[8];\n        m.mat[3] = rhs.mat[3] * lhs.mat[0] + rhs.mat[4] * lhs.mat[3] + rhs.mat[5] * lhs.mat[6];\n        m.mat[4] = rhs.mat[3] * lhs.mat[1] + rhs.mat[4] * lhs.mat[4] + rhs.mat[5] * lhs.mat[7];\n        m.mat[5] = rhs.mat[3] * lhs.mat[2] + rhs.mat[4] * lhs.mat[5] + rhs.mat[5] * lhs.mat[8];\n        m.mat[6] = rhs.mat[6] * lhs.mat[0] + rhs.mat[7] * lhs.mat[3] + rhs.mat[8] * lhs.mat[6];\n        m.mat[7] = rhs.mat[6] * lhs.mat[1] + rhs.mat[7] * lhs.mat[4] + rhs.mat[8] * lhs.mat[7];\n        m.mat[8] = rhs.mat[6] * lhs.mat[2] + rhs.mat[7] * lhs.mat[5] + rhs.mat[8] * lhs.mat[8];\n\n        return m;\n    }\n\n    /**\n     * Creates a copy of a Matrix3 object\n     * \n     * @param m - The Matrix3 object to be copied\n     * @returns A new Matrix3 object representing a copy of the input Matrix3\n     */\n    static copy(m: Matrix3): Matrix3\n    {\n        const mat = new Matrix3();\n        mat.copy(m);\n        return mat;\n    }\n\n    /**\n     * Creates a new Matrix3 object from 9 numbers representing a row-major matrix\n     * \n     * @param n1 - Number in row 1, column 1\n     * @param n2 - Number in row 1, column 2\n     * @param n3 - Number in row 1, column 3\n     * @param n4 - Number in row 2, column 1\n     * @param n5 - Number in row 2, column 2\n     * @param n6 - Number in row 2, column 3\n     * @param n7 - Number in row 3, column 1\n     * @param n8 - Number in row 3, column 2\n     * @param n9 - Number in row 3, column 3\n     * @returns A new Matrix3 object created from the given numbers\n     */\n    public static fromRowMajor(n1: number, n2: number, n3: number,\n        n4: number, n5: number, n6: number, \n        n7: number, n8: number, n9: number): Matrix3\n    {\n        const matrix = new Matrix3();\n        matrix.setRowMajor(n1, n2, n3, n4, n5, n6, n7, n8, n9);\n        return matrix;\n    }\n\n    /**\n     * Creates a new Matrix3 object from 9 numbers representing a column-major matrix\n     * \n     * @param n1 - Number in column 1, row 1\n     * @param n2 - Number in column 2, row 1\n     * @param n3 - Number in column 3, row 1\n     * @param n4 - Number in column 1, row 2\n     * @param n5 - Number in column 2, row 2\n     * @param n6 - Number in column 3, row 2\n     * @param n7 - Number in column 1, row 3\n     * @param n8 - Number in column 2, row 3\n     * @param n9 - Number in column 3, row 3\n     * @returns A new Matrix3 object created from the given numbers\n     */\n    public static fromColumnMajor(n1: number, n2: number, n3: number,\n        n4: number, n5: number, n6: number, \n        n7: number, n8: number, n9: number): Matrix3\n    {\n        const matrix = new Matrix3();\n        matrix.setColumnMajor(n1, n2, n3, n4, n5, n6, n7, n8, n9);\n        return matrix;\n    }\n\n    /**\n     * Creates a new Matrix3 object representing a translation matrix\n     * \n     * @param v - The Vector2 object representing the translation vector\n     * @returns A new Matrix3 object representing a translation matrix\n     */\n    public static makeTranslation(v: Vector2): Matrix3\n    {\n        return Matrix3.fromRowMajor(\n            1, 0, v.x,\n            0, 1, v.y,\n            0, 0, 1\n        );\n    }\n\n    /**\n     * Creates a new Matrix3 object representing a rotation matrix\n     * \n     * @param angle - The angle of rotation, in radians\n     * @returns A new Matrix3 object representing a rotation matrix\n     */\n    public static makeRotation(angle: number): Matrix3\n    {\n        const cosTheta = Math.cos(angle);\n        const sinTheta = Math.sin(angle);\n        \n        return Matrix3.fromRowMajor(\n            cosTheta, -sinTheta, 0,\n            sinTheta, cosTheta, 0,\n            0, 0, 1\n        );\n    }\n\n    /**\n     * Creates a new Matrix3 object representing a scaling matrix\n     * \n     * @param scale - The Vector2 object representing the x and y scaling factors\n     * @returns A new Matrix3 object representing a scaling matrix\n     */\n    public static makeScale(scale: Vector2): Matrix3\n    {\n        return Matrix3.fromRowMajor(\n            scale.x, 0, 0,\n            0, scale.y, 0,\n            0, 0, 1 \n        );\n    }\n\n    public static makeShear(shear: Vector2): Matrix3\n    {\n        // Construct a 2D shear matrix from the X and Y shear angles in radians\n        return Matrix3.fromRowMajor(\n            1, Math.tan(shear.x), 0,\n            Math.tan(shear.y), 1, 0,\n            0, 0, 1\n        );\n    }\n\n    /**\n     * Creates a Matrix3 object from position, rotation, and scale\n     * \n     * @param position - The Vector2 representing the position\n     * @param rotation - The angle to rotate by, in radians\n     * @param scale - The Vector2 representing the scale to apply\n     * @returns The resulting Matrix3 object\n     */ \n    public static compose(position = Vector2.ZERO, rotation = 0, scale = Vector2.ONE): Matrix3\n    {\n        const m = Matrix3.makeScale(scale);\n        m.premultiply(Matrix3.makeRotation(rotation));\n\n        m.mat[6] = position.x;\n        m.mat[7] = position.y;\n        return m;\n    }\n\n    public static transformPoint(v: Vector2, m: Matrix3): Vector2\n    {\n        const result = new Vector2();\n        const w = 1 / (m.mat[2]*v.x + m.mat[5]*v.y + m.mat[8]);\n        result.x = w * (m.mat[0]*v.x + m.mat[3]*v.y + m.mat[6]);\n        result.y = w * (m.mat[1]*v.x + m.mat[4]*v.y + m.mat[7]);\n        return result;\n    }\n\n    public static transformVector(v: Vector2, m: Matrix3): Vector2\n    {\n        const result = new Vector2();\n        const w = 1 / (m.mat[2]*v.x + m.mat[5]*v.y + m.mat[8]);\n        result.x = w * (m.mat[0]*v.x + m.mat[3]*v.y);\n        result.y = w * (m.mat[1]*v.x + m.mat[4]*v.y);\n        return result;\n    }\n\n    /**\n     * Creates a new Matrix3 object and initializes the mat array with the given values.\n     */\n    constructor()\n    {\n        this.mat = [ \n            1, 0, 0,\n            0, 1, 0,\n            0, 0, 1\n        ];\n    }\n\n    /**\n     * Sets the elements of the Matrix3 in column major order.\n     * \n     * @param n1 - The first element in the first column\n     * @param n2 - The second element in the first column\n     * @param n3 - The third element in the first column\n     * @param n4 - The first element in the second column\n     * @param n5 - The second element in the second column\n     * @param n6 - The third element in the second column\n     * @param n7 - The first element in the third column\n     * @param n8 - The second element in the third column\n     * @param n9 - The third element in the third column\n     */\n    setColumnMajor(n1: number, n2: number, n3: number,\n        n4: number, n5: number, n6: number, \n        n7: number, n8: number, n9: number): void\n    {\n        this.mat[0] = n1;\n        this.mat[1] = n2;\n        this.mat[2] = n3;\n        this.mat[3] = n4;\n        this.mat[4] = n5;\n        this.mat[5] = n6;\n        this.mat[6] = n7;\n        this.mat[7] = n8;\n        this.mat[8] = n9;\n    }\n\n    /**\n     * Sets the elements of the Matrix3 in row major order.\n     * \n     * @param n1 - The first element in the first row\n     * @param n2 - The second element in the first row\n     * @param n3 - The third element in the first row\n     * @param n4 - The first element in the second row\n     * @param n5 - The second element in the second row\n     * @param n6 - The third element in the second row\n     * @param n7 - The first element in the third row\n     * @param n8 - The second element in the third row\n     * @param n9 - The third element in the third row\n     */\n    setRowMajor(n1: number, n2: number, n3: number,\n        n4: number, n5: number, n6: number, \n        n7: number, n8: number, n9: number): void\n    {\n        this.mat[0] = n1;\n        this.mat[1] = n4;\n        this.mat[2] = n7;\n        this.mat[3] = n2;\n        this.mat[4] = n5;\n        this.mat[5] = n8;\n        this.mat[6] = n3;\n        this.mat[7] = n6;\n        this.mat[8] = n9;\n    }\n\n    /**\n     * Copies the values of the specified Matrix3 into this Matrix3.\n     * \n     * @param m - The Matrix3 to copy the values from\n     */\n    copy(m: Matrix3): void\n    {\n        for(let i=0; i < 9; i++)\n            this.mat[i] = m.mat[i];\n    }\n\n    /**\n     * Creates a new Matrix3 object with the same values as this Matrix3.\n     * \n     * @returns A new Matrix3 object with the same values as this Matrix3.\n     */\n    clone(): Matrix3\n    {\n        const matrix = new Matrix3();\n        \n        for(let i=0; i < 9; i++)\n            matrix.mat[i] = this.mat[i];\n\n        return matrix;\n    }\n\n\n    /**\n     * Returns the element at the specified row and column of the Matrix3.\n     * \n     * @param row - The row of the element to return\n     * @param col - The column of the element to return\n     * @returns The element at the specified row and column of the Matrix3\n     */\n    element(row: number, col: number): number\n    {\n        return this.mat[col*3 + row];\n    }\n\n    /**\n     * Sets the value of the specified element in the Matrix3.\n     * \n     * @param value - The value to set\n     * @param row - The row of the element to set\n     * @param col - The column of the element to set\n     */\n    set(value: number, row: number, col: number): void\n    {\n       this.mat[col*3 + row] = value;\n    }\n\n    /**\n     * Multiplies this Matrix4 with another Matrix3 on the right hand side, and sets this Matrix3 to the result.\n     * \n     * @param rhs - The Matrix3 to multiply with.\n     */\n    multiply(rhs: Matrix3): void\n    {\n        const lhs = this.clone();\n\n        this.mat[0] = rhs.mat[0] * lhs.mat[0] + rhs.mat[1] * lhs.mat[3] + rhs.mat[2] * lhs.mat[6];\n        this.mat[1] = rhs.mat[0] * lhs.mat[1] + rhs.mat[1] * lhs.mat[4] + rhs.mat[2] * lhs.mat[7];\n        this.mat[2] = rhs.mat[0] * lhs.mat[2] + rhs.mat[1] * lhs.mat[5] + rhs.mat[2] * lhs.mat[8];\n        this.mat[3] = rhs.mat[3] * lhs.mat[0] + rhs.mat[4] * lhs.mat[3] + rhs.mat[5] * lhs.mat[6];\n        this.mat[4] = rhs.mat[3] * lhs.mat[1] + rhs.mat[4] * lhs.mat[4] + rhs.mat[5] * lhs.mat[7];\n        this.mat[5] = rhs.mat[3] * lhs.mat[2] + rhs.mat[4] * lhs.mat[5] + rhs.mat[5] * lhs.mat[8];\n        this.mat[6] = rhs.mat[6] * lhs.mat[0] + rhs.mat[7] * lhs.mat[3] + rhs.mat[8] * lhs.mat[6];\n        this.mat[7] = rhs.mat[6] * lhs.mat[1] + rhs.mat[7] * lhs.mat[4] + rhs.mat[8] * lhs.mat[7];\n        this.mat[8] = rhs.mat[6] * lhs.mat[2] + rhs.mat[7] * lhs.mat[5] + rhs.mat[8] * lhs.mat[8];\n    }\n\n    /**\n     * Multiplies this Matrix4 with another Matrix3 on the left hand side, and sets this Matrix3 to the result.\n     * \n     * @param rhs - The Matrix3 to multiply with.\n     */\n    premultiply(lhs: Matrix3): void\n    {\n        const rhs = this.clone();\n\n        this.mat[0] = rhs.mat[0] * lhs.mat[0] + rhs.mat[1] * lhs.mat[3] + rhs.mat[2] * lhs.mat[6];\n        this.mat[1] = rhs.mat[0] * lhs.mat[1] + rhs.mat[1] * lhs.mat[4] + rhs.mat[2] * lhs.mat[7];\n        this.mat[2] = rhs.mat[0] * lhs.mat[2] + rhs.mat[1] * lhs.mat[5] + rhs.mat[2] * lhs.mat[8];\n        this.mat[3] = rhs.mat[3] * lhs.mat[0] + rhs.mat[4] * lhs.mat[3] + rhs.mat[5] * lhs.mat[6];\n        this.mat[4] = rhs.mat[3] * lhs.mat[1] + rhs.mat[4] * lhs.mat[4] + rhs.mat[5] * lhs.mat[7];\n        this.mat[5] = rhs.mat[3] * lhs.mat[2] + rhs.mat[4] * lhs.mat[5] + rhs.mat[5] * lhs.mat[8];\n        this.mat[6] = rhs.mat[6] * lhs.mat[0] + rhs.mat[7] * lhs.mat[3] + rhs.mat[8] * lhs.mat[6];\n        this.mat[7] = rhs.mat[6] * lhs.mat[1] + rhs.mat[7] * lhs.mat[4] + rhs.mat[8] * lhs.mat[7];\n        this.mat[8] = rhs.mat[6] * lhs.mat[2] + rhs.mat[7] * lhs.mat[5] + rhs.mat[8] * lhs.mat[8];\n    }\n\n    /**\n     * Sets the translation of this matrix from a Vector2.\n     * \n     * @param v - The Vector2 to set the translation from.\n     */\n    setTranslation(v: Vector2): void\n    { \n        this.setRowMajor(\n            1, 0, v.x,\n            0, 1, v.y,\n            0, 0, 1\n        );\n    }\n\n    /**\n     * Sets the rotation of this matrix from a given angle.\n     * \n     * @param angle - The angle in radians to set the rotation from.\n     */   \n    setRotation(angle: number): void\n    {\n        const cosTheta = Math.cos(angle);\n        const sinTheta = Math.sin(angle);\n        \n        this.setRowMajor(\n            cosTheta, -sinTheta, 0,\n            sinTheta, cosTheta, 0,\n            0, 0, 1\n        );\n    }\n\n    /**\n     * Sets the scale of this matrix from a Vector2.\n     * \n     * @param scale - The Vector2 to set the scale from.\n     */\n    setScale(scale: Vector2): void\n    {\n        this.setRowMajor(\n            scale.x, 0, 0,\n            0, scale.y, 0,\n            0, 0, 1 \n        );\n    }\n\n    setShear(shear: Vector2): void\n    {\n        // Construct a 2D shear matrix from the X and Y shear angles in radians\n        this.setRowMajor(\n            1, Math.tan(shear.x), 0,\n            Math.tan(shear.y), 1, 0,\n            0, 0, 1\n        );\n    }\n\n    /**\n     * Gets the translation vector of this Matrix3 object\n     * \n     * @returns The Vector2 representing the translation vector\n     */\n    getTranslation(): Vector2\n    {\n        return new Vector2(this.mat[6], this.mat[7]);\n    }\n\n    /**\n     * Gets the rotation quaternion of this Matrix4 object\n     * \n     * @returns The rotation angle in radians\n     */\n    getRotation(): number\n    {\n        return Math.atan2(this.mat[1], this.mat[0]);\n    }\n\n    /**\n     * Gets the scale vector of this Matrix3 object\n     * \n     * @returns The Vector2 representing the scale vector\n     */\n    getScale(): Vector2\n    {\n        return new Vector2(\n            Math.sqrt(this.mat[0]*this.mat[0] + this.mat[1]*this.mat[1]),\n            Math.sqrt(this.mat[3]*this.mat[3] + this.mat[4]*this.mat[4])\n        );\n    }\n    \n    /**\n     * Gets the shear angles of this Matrix3 object\n     * \n     * @returns The Vector2 containing the X and Y shear angles\n     */\n    getShear(): Vector2\n    {\n        return new Vector2(\n            Math.atan2(this.mat[3], this.mat[4]),\n            Math.atan2(this.mat[1], this.mat[0])\n        );\n    }\n    \n\n    multiplyScalar(x: number): void\n    {\n        for(let i=0; i < 9; i++)\n            this.mat[i] *= x;\n    }\n    \n    /**\n     * Computes the inverse of this matrix.\n     * \n     * @returns The inverse of this matrix\n     */\n    inverse(): Matrix3\n    {\n        // Code from http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/threeD/index.htm\n\n        const inverse = new Matrix3();\n\n        const det = this.mat[0]*this.mat[4]*this.mat[8] + \n            this.mat[1]*this.mat[5]*this.mat[6] + \n            this.mat[2]*this.mat[3]*this.mat[7] - \n            this.mat[0]*this.mat[5]*this.mat[7] -\n             this.mat[1]*this.mat[3]*this.mat[8] - \n             this.mat[2]*this.mat[4]*this.mat[6];\n\n        this.mat[0] = (this.mat[4]*this.mat[8] - this.mat[5]*this.mat[7])/det;\n        this.mat[1] = (this.mat[2]*this.mat[7] - this.mat[1]*this.mat[8])/det;\n        this.mat[2] = (this.mat[1]*this.mat[5] - this.mat[2]*this.mat[4])/det;\n        this.mat[3] = (this.mat[5]*this.mat[6] - this.mat[3]*this.mat[8])/det;\n        this.mat[4] = (this.mat[0]*this.mat[8] - this.mat[2]*this.mat[6])/det;\n        this.mat[5] = (this.mat[2]*this.mat[3] - this.mat[0]*this.mat[5])/det;\n        this.mat[6] = (this.mat[3]*this.mat[7] - this.mat[4]*this.mat[6])/det;\n        this.mat[7] = (this.mat[1]*this.mat[6] - this.mat[0]*this.mat[7])/det;\n        this.mat[8] = (this.mat[0]*this.mat[4] - this.mat[1]*this.mat[3])/det;\n\n        return inverse;\n    }\n\n    /**\n     * Inverts this matrix in place.\n     */\n    invert(): void\n    {\n        const inverseMatrix = this.inverse();\n        this.copy(inverseMatrix);\n    }\n\n    /**\n     * Transposes this matrix.\n     * \n     * @returns The transposed matrix.\n     */\n    transpose(): Matrix3\n    {\n        return Matrix3.fromRowMajor(\n            this.mat[0], this.mat[1], this.mat[2], \n            this.mat[3], this.mat[4], this.mat[5], \n            this.mat[6], this.mat[7], this.mat[8]\n        );\n    }\n\n    /**\n     * Compose the current Matrix3 object from position, rotation, and scale\n     * \n     * @param position - The Vector2 representing the position\n     * @param rotation - The angle to rotate by, in radians\n     * @param scale - The Vector2 representing the scale to apply\n     */\n    compose(position: Vector2, rotation: number, scale: Vector2, shear: Vector2 | null): void\n    {\n        this.setScale(scale);\n\n        if(shear)\n        {\n            this.premultiply(Matrix3.makeShear(shear));\n        }\n\n        this.premultiply(Matrix3.makeRotation(rotation));\n\n        this.mat[6] = position.x;\n        this.mat[7] = position.y;\n    }\n\n    transformPoint(v: Vector2): Vector2\n    {\n        const result = new Vector2();\n        const w = 1 / (this.mat[2]*v.x + this.mat[5]*v.y + this.mat[8]);\n        result.x = w * (this.mat[0]*v.x + this.mat[3]*v.y + this.mat[6]);\n        result.y = w * (this.mat[1]*v.x + this.mat[4]*v.y + this.mat[7]);\n        return result;\n    }\n\n    transformVector(v: Vector2): Vector2\n    {\n        const result = new Vector2();\n        const w = 1 / (this.mat[2]*v.x + this.mat[5]*v.y + this.mat[8]);\n        result.x = w * (this.mat[0]*v.x + this.mat[3]*v.y);\n        result.y = w * (this.mat[1]*v.x + this.mat[4]*v.y);\n        return result;\n    }\n\n    getColumn(i: number): Vector2\n    {\n        return new Vector2(this.mat[i], this.mat[i+3]);\n    }\n\n    getRow(i: number): Vector2\n    {\n        return new Vector2(this.mat[i*3], this.mat[i*3+1]);\n    }\n\n    setColumn(col: number, v: Vector2): void\n    {\n        this.mat[col] = v.x;\n        this.mat[col+3] = v.y;\n    }\n\n    setRow(row: number, v: Vector2): void\n    {\n        this.mat[row*3] = v.x;\n        this.mat[row*3+1] = v.y;\n    }\n\n    decompose(): [Vector2, number, Vector2, Vector2 | null]\n    {\n        const position = new Vector2();\n        let rotation = 0;\n        const scale = new Vector2();\n\n        // Extract translation component of the matrix\n        position.set(this.mat[6], this.mat[7]);\n\n        // https://github.com/wisec/DOMinator/blob/master/layout/style/nsStyleAnimation.cpp#L946\n        let a = this.mat[0];\n        let b = this.mat[1];\n        let c = this.mat[3];\n        let d = this.mat[4];\n\n        // singular matrix\n        if (a * d == b * c) \n        { \n            return [position, rotation, scale, null];\n        }\n\n        scale.x = Math.sqrt(a * a + b * b);\n        a /= scale.x;\n        b /= scale.x;\n\n        let xyShear = a * c + b * d;\n        c -= a * xyShear;\n        d -= b * xyShear;\n\n        scale.y = Math.sqrt(c * c + d * d);\n        c /= scale.y;\n        d /= scale.y;\n        xyShear /= scale.y;\n\n        // a*d - b*c should now be 1 or -1\n        if (a * d < b * c) \n        {\n            a = -a;\n            b = -b;\n            c = -c;\n            d = -d;\n            xyShear = -xyShear;\n            scale.x = -scale.x;\n        }\n\n        rotation = Math.atan2(b, a);\n\n        if(Math.abs(xyShear) < 0.0001)\n            return [position, rotation, scale, null];\n        else\n            return [position, rotation, scale, new Vector2(Math.atan(xyShear), 0)];\n    }\n}", "import { Matrix3 } from \"./Matrix3\";\nimport { Vector2 } from \"./Vector2\"\n\nexport class BoundingBox2 \n{\n    public min: Vector2;\n    public max: Vector2;\n\n    /**\n    * Constructs a new BoundingBox2\n    */\n    constructor()\n    {\n        this.min = new Vector2();\n        this.max = new Vector2();\n    }\n\n    /**\n     * Copies an existing BoundingBox2 to this one\n     * \n     * @param box - The BoundingBox2 to copy\n     */\n    copy(box: BoundingBox2): void\n    {\n        this.min.copy(box.min);\n        this.max.copy(box.max);\n    }\n\n    /**\n     * Transforms the BoundingBox2 using a transformation matrix\n     * \n     * @param m - The transformation matrix\n     */\n    transform(m: Matrix3)\n    {\n        // Compute new axis-aligned bounding box\n        const topLeft = new Vector2(this.min.x, this.max.y);\n        const topRight = new Vector2(this.max.x, this.max.y);\n        const bottomLeft = new Vector2(this.min.x, this.min.y);\n        const bottomRight = new Vector2(this.max.x, this.min.y);\n\n        topLeft.transformPoint(m);\n        topRight.transformPoint(m);\n        bottomLeft.transformPoint(m);\n        bottomRight.transformPoint(m);\n\n        this.min.x = Math.min(topLeft.x, Math.min(topRight.x, Math.min(bottomLeft.x, bottomRight.x)));\n        this.min.y = Math.min(topLeft.y, Math.min(topRight.y, Math.min(bottomLeft.y, bottomRight.y)));\n        this.max.x = Math.max(topLeft.x, Math.max(topRight.x, Math.max(bottomLeft.x, bottomRight.x)));\n        this.max.y = Math.max(topLeft.y, Math.max(topRight.y, Math.max(bottomLeft.y, bottomRight.y)));\n    }\n\n    /**\n     * Checks if this BoundingBox2 intersects with another BoundingBox2\n     * \n     * @param box - The other BoundingBox2 to check against\n     * @returns True if the two BoundingBox2s intersect, false otherwise\n     */\n    intersects(box: BoundingBox2): boolean\n    {\n        const thisCenter = Vector2.add(this.max, this.min);\n        thisCenter.multiplyScalar(0.5);\n\n        const otherCenter = Vector2.add(box.max, box.min);\n        otherCenter.multiplyScalar(0.5);\n\n        const thisHalfWidth = Vector2.subtract(this.max, this.min);\n        thisHalfWidth.multiplyScalar(0.5);\n\n        const otherHalfWidth = Vector2.subtract(box.max, box.min);\n        otherHalfWidth.multiplyScalar(0.5);\n\n        if(Math.abs(thisCenter.x - otherCenter.x) > (thisHalfWidth.x + otherHalfWidth.x))\n            return false;\n        else if(Math.abs(thisCenter.y - otherCenter.y) > (thisHalfWidth.y + otherHalfWidth.y))\n            return false;\n        else\n            return true;\n    }\n\n    /**\n     * Computes the minimum and maximum Vector2 objects for the BoundingBox2 from a given array of vertices\n     * \n     * @param vertices - An array of Vector2 or number objects with the vertices\n     */\n    computeBounds(vertices: Vector2[] | number[]): void\n    {\n        if(typeof vertices[0] === 'number')\n        {\n            const vArray = vertices as number[];\n\n            this.max.set(vArray[0], vArray[1]);\n            this.min.set(vArray[0], vArray[1]);\n            \n            for(let i=0; i < vArray.length; i+=3)\n            {\n                if(vArray[i] > this.max.x)\n                    this.max.x = vArray[i];\n                if(vArray[i] < this.min.x)\n                    this.min.x = vArray[i];\n\n                if(vArray[i+1] > this.max.y)\n                    this.max.y = vArray[i+1];\n                if(vArray[i+1] < this.min.y)\n                    this.min.y = vArray[i+1];\n            }\n        }\n        else\n        {\n            this.max.copy((vertices as Vector2[])[0]);\n            this.min.copy((vertices as Vector2[])[0]);\n\n            (vertices as Vector2[]).forEach((elem: Vector2) =>\n            {\n                if(elem.x > this.max.x)\n                    this.max.x = elem.x;\n                if(elem.x < this.min.x)\n                    this.min.x = elem.x;\n\n                if(elem.y > this.max.y)\n                    this.max.y = elem.y;\n                if(elem.y < this.min.y)\n                    this.min.y =elem.y;\n            });\n        }\n    }\n}", "import { Vector2 } from \"./Vector2\"\nimport { Matrix3 } from \"./Matrix3\"\nimport { BoundingBox2 } from \"./BoundingBox2\"\n\nexport class BoundingCircle \n{\n    public center: Vector2;\n    public radius: number;\n\n    /**\n     * Constructor for the BoundingCircle class\n     * \n     * @returns A new instance of the BoundingCircle class\n     */\n    constructor()\n    {\n        this.center = new Vector2();\n        this.radius = 0;\n    }\n\n    /**\n     * Copies the properties of a given circle to this instance\n     * \n     * @param circle - The circle whose properties will be copied\n     */\n    copy(circle: BoundingCircle): void\n    {\n        this.center.copy(circle.center);\n        this.radius = circle.radius;\n    }\n\n    /**\n     * Transforms the BoundingCircle using a transformation matrix\n     * \n     * @param m - The transformation matrix\n     */\n    transform(m: Matrix3)\n    {\n        // Compute new local bounding circle center\n        this.center.add(m.getTranslation());\n        \n        // Compute new local bounding circle radius\n        const radiusVector = new Vector2(this.radius, 0);\n        radiusVector.transformVector(m);\n        this.radius = radiusVector.length();\n    }\n\n    /**\n     * Returns whether this BoundingCircle intersects with the input BoundingCircle\n     * \n     * @param circle - The BoundingCircle object to check for intersection\n     * @returns True if the two BoundingCircle objects intersect, false otherwise\n     */\n    intersects(circle: BoundingCircle): boolean\n    {\n        const distance = this.center.distanceTo(circle.center);\n\n        if(distance < (this.radius + circle.radius))\n            return true;\n        else\n            return false;\n    }\n\n    /**\n     * Computes the bounds of the BoundingCircle from the given vertices\n     * \n     * @param vertices - The array of Vector2 or number objects representing the vertices\n     * @param boundingBox - The BoundingBox2 object to use when computing the bounds\n     */\n    computeBounds(vertices: Vector2[] | number[], boundingBox: BoundingBox2): void\n    {\n        this.center.copy(boundingBox.min);\n        this.center.add(boundingBox.max);\n        this.center.multiplyScalar(0.5);\n        this.radius = 0;\n        if(typeof vertices[0] === 'number')\n        {\n            const vArray = vertices as number[];\n            for(let i=0; i < vArray.length; i+=3)\n            {\n                const distance = Math.sqrt(\n                    (vArray[i] - this.center.x) * (vArray[i] - this.center.x) +\n                    (vArray[i+1] - this.center.y) * (vArray[i+1] - this.center.y)\n                );\n                \n                if(distance > this.radius)\n                    this.radius = distance;\n            }\n        }\n        else\n        {\n            (vertices as Vector2[]).forEach((elem: Vector2) =>\n            {\n                const distance = elem.distanceTo(this.center);\n\n                if(distance > this.radius)\n                    this.radius = distance;\n            });\n        }\n    }\n}", "import { Matrix3 } from \"../math/Matrix3\";\nimport { Vector2 } from \"../math/Vector2\";\nimport { BoundingBox2 } from \"../math/BoundingBox2\";\nimport { BoundingCircle } from \"../math/BoundingCircle\";\n\nexport enum IntersectionMode2\n{\n    BOUNDING_CIRCLE,\n    AXIS_ALIGNED_BOUNDING_BOX\n}\n\nexport enum CoordinateSpace2\n{\n    LOCAL_SPACE,\n    WORLD_SPACE\n}\n\n/**\n * This is the base class for all objects that can be added to a GopherGfx 2D scene.  It is named \"Node\"\n * because the scene is stored in a graph data structure, so we think of every element in that graph\n * as a \"node\" in the graph.  There is also a \"Node3\" base class for all objects that can be added to\n * the 3D scene.  \n * \n * Every object that can be added to a 2D scene (e.g., Mesh2s, Line2s) will inherit from this base object.\n * So, every object in the scene will have a position, rotation, scale, boundingBox, boundingSphere, \n * visibility, and all of the other properties listed in this class.\n * \n * For more detail on how the scene graph works, see the documentation for the Scene class.\n * \n */\nexport class Node2\n{\n     /**\n     * Vector2 representing the position\n     */\n     protected _position: Vector2;\n\n     /**\n      * Rotation of the transform in radians\n      */\n     protected _rotation: number;\n \n     /**\n      * Vector2 representing the scale\n      */\n     protected _scale: Vector2;\n\n     protected _shear: Vector2 | null;\n\n    /**\n     * Matrix3 representing the transformation matrix in local space\n     */\n    protected localToParentMatrix: Matrix3;\n\n    /**\n     * Matrix3 representing the transformation matrix in world space\n     */\n    public localToWorldMatrix: Matrix3;\n\n    protected localMatrixDirty: boolean;\n    protected localMatrixUpdated: boolean;\n    protected worldMatrixDirty: boolean;\n    \n    /**\n     * Array of children for this transform\n     */\n    public children: Array<Node2>;\n\n    /**\n     * Parent transform for this transform\n     */\n    public parent: Node2 | null;\n\n    /**\n     * Integer representing the layer of this transform\n     */\n    public layer: number;\n\n    /**\n     * Boolean indicating whether this transform should be rendered\n     */\n    public visible: boolean;\n\n    /**\n     * Bounding box in vertex coordinate space\n     */\n    public boundingBox: BoundingBox2;\n\n    /**\n     * Bounding circle in vertex coordinate space\n     */\n    public boundingCircle: BoundingCircle;\n\n    /**\n     * Bounding box in this transform's local coordinate space\n     */\n    public _localBoundingBox: BoundingBox2;\n\n    /**\n     * Bounding circle in this transform's local coordinate space\n     */\n    public _localBoundingCircle: BoundingCircle;\n\n    /**\n     * Bounding box in the world coordinate space\n     */\n    public _worldBoundingBox: BoundingBox2;\n\n    /**\n     * Bounding box in the world coordinate space\n     */\n    public _worldBoundingCircle: BoundingCircle;\n\n    public localBoundsDirty: boolean;\n    public worldBoundsDirty: boolean;\n\n    /**\n     * Constructor for Node2 class\n     * \n     */\n    constructor()\n    {\n        this.children = [];\n\n        this._position = new Vector2();\n        this._rotation = 0;\n        this._scale = new Vector2(1, 1);\n        this._shear = null;\n\n        this.localToParentMatrix = new Matrix3();\n        this.localToWorldMatrix = new Matrix3();\n\n        this.localMatrixDirty = false;\n        this.localMatrixUpdated = false;\n        this.worldMatrixDirty = false;\n\n        // default layer\n        this.layer = 0;\n\n        this.visible = true;\n\n        this.parent = null;\n\n        this.boundingBox = new BoundingBox2();\n        this.boundingCircle = new BoundingCircle();\n        this._localBoundingBox = new BoundingBox2();\n        this._localBoundingCircle = new BoundingCircle();\n        this._worldBoundingBox = new BoundingBox2();\n        this._worldBoundingCircle = new BoundingCircle();\n\n        this.localBoundsDirty = false;\n        this.worldBoundsDirty = false;\n    }\n\n    public get position()\n    {\n        if(this.localMatrixUpdated)\n        {\n            this.decomposeLocalMatrix();\n        }\n        \n        this.localMatrixDirty = true;\n        return this._position;\n    }\n\n    public set position(value: Vector2)\n    {\n        this.localMatrixDirty = true;\n        this._position = value;\n    }\n\n    public get rotation()\n    {\n        if(this.localMatrixUpdated)\n        {\n            this.decomposeLocalMatrix();\n        }\n\n        this.localMatrixDirty = true;\n        return this._rotation;\n    }\n\n    public set rotation(value: number)\n    {\n        this.localMatrixDirty = true;\n        this._rotation = value;\n    }\n\n    public get scale()\n    {\n        if(this.localMatrixUpdated)\n        {\n            this.decomposeLocalMatrix();\n        }\n\n        this.localMatrixDirty = true;\n        return this._scale;\n    }\n\n    public set scale(value: Vector2)\n    {\n        this.localMatrixDirty = true;\n        this._scale = value;\n    }\n\n    public get shear()\n    {\n        if(this.localMatrixUpdated)\n        {\n            this.decomposeLocalMatrix();\n        }\n\n        if(!this._shear)\n        {\n            this._shear = new Vector2();\n        }\n\n        this.localMatrixDirty = true;\n        return this._shear;\n    }\n\n    public set shear(value: Vector2)\n    {\n        if(!this._shear)\n        {\n            this._shear = new Vector2();\n        }\n\n        this.localMatrixDirty = true;\n        this._shear = value;\n    }\n\n    public getLocalToParentMatrix(): Matrix3\n    {\n        if(this.localMatrixDirty)\n        {\n            this.composeLocalMatrix();\n        }\n        \n        return this.localToParentMatrix.clone();\n    }\n\n    public setLocalToParentMatrix(matrix: Matrix3): void\n    {\n        this.localToParentMatrix.copy(matrix);  \n        this.localMatrixUpdated = true;\n        this.worldMatrixDirty = true;\n        this.localBoundsDirty = true;\n    }\n\n    public get localBoundingBox()\n    {\n        if(this.localBoundsDirty)\n        {\n            this.updateLocalBounds();\n        }\n\n        return this._localBoundingBox;\n    }\n\n    public set localBoundingBox(value: BoundingBox2)\n    {\n        this._localBoundingBox = value;\n    }\n\n    public get localBoundingCircle()\n    {\n        if(this.localBoundsDirty)\n        {\n            this.updateLocalBounds();\n        }\n\n        return this._localBoundingCircle;\n    }\n\n    public set localBoundingSphere(value: BoundingCircle)\n    {\n        this._localBoundingCircle = value;\n    }\n\n    public get worldBoundingBox()\n    {\n        if(this.worldBoundsDirty)\n        {\n            this.updateWorldBounds();\n        }\n\n        return this._worldBoundingBox;\n    }\n\n    public set worldBoundingBox(value: BoundingBox2)\n    {\n        this._worldBoundingBox = value;\n    }\n\n    public get worldBoundingCircle()\n    {\n        if(this.worldBoundsDirty)\n        {\n            this.updateWorldBounds();\n        }\n\n        return this._worldBoundingCircle;\n    }\n\n    public set worldBoundingSphere(value: BoundingCircle)\n    {\n        this._worldBoundingCircle = value;\n    }\n\n    /**\n     * Recursively draws the Node2 object and its children\n     */\n    draw(): void\n    {\n        if(!this.visible)\n            return;\n\n        this.children.forEach((elem: Node2) => {\n            elem.draw();\n        });\n    }\n\n    /**\n     * Traverses the scene graph starting from the current Node2 object\n     */\n    traverseSceneGraph(parentMatrixDirty = false): void\n    {\n        const worldMatrixDirty = parentMatrixDirty || this.localMatrixDirty || this.worldMatrixDirty;\n\n        if(this.localMatrixDirty) \n        {\n            this.composeLocalMatrix();\n        }\n\n        if(worldMatrixDirty)\n        {\n            this.localToWorldMatrix.copy(this.localToParentMatrix);\n\n            if(this.parent)\n            {  \n                this.localToWorldMatrix.premultiply(this.parent.localToWorldMatrix);\n            }\n\n            this.worldBoundsDirty = true;\n            this.worldMatrixDirty = false;\n        }\n\n        this.children.forEach((elem: Node2) => {\n            elem.traverseSceneGraph(worldMatrixDirty);\n        });\n    }\n\n    /**\n     * Updates the world matrix of the current Node2 object and its parent\n     */\n    updateWorldMatrix(): void \n    {\n        if(this.localMatrixDirty) \n        {\n            this.composeLocalMatrix();\n        }\n\n        this.localToWorldMatrix.copy(this.localToParentMatrix);\n\n        if (this.parent) \n        {\n            this.parent.updateWorldMatrix();\n            this.localToWorldMatrix.premultiply(this.parent.localToWorldMatrix);\n        }\n\n        this.worldBoundsDirty = true;\n        this.worldMatrixDirty = false;\n    }\n\n    /**\n     * Adds a child Node2 to the current Node2\n     * \n     * @param child - The child Node2 to add\n     */\n    add(child: Node2) \n    {\n        this.children.push(child);\n        child.parent = this;\n    }\n\n    /**\n     * Removes the current Node2 from its parent\n     * \n     * @returns True if the Node2 was successfully removed, false otherwise\n     */\n    remove(): boolean\n    {\n        if(this.parent == null)\n            return false;\n        else\n            return this.parent.removeChild(this) != null;\n    }\n\n    /**\n     * Removes the specified child Node2 from the current Node2\n     * \n     * @param child - The child Node2 to remove\n     * @returns The removed Node2, or null if it was not found\n     */\n    removeChild(child: Node2): Node2 | null\n    {\n        const index = this.children.indexOf(child);\n\n        if(index == -1)\n        {\n            return null;\n        }\n        else\n        {\n            const removedElement = this.children.splice(index, 1);\n            removedElement[0].parent = null;\n            return removedElement[0];\n        }\n    }\n\n    /**\n     * Looks at a target vector with the given look vector\n     * \n     * @param target - The vector to look at\n     * @param lookVector - The vector used to determine the look direction (defaults to Vector2.UP)\n     */\n    lookAt(target: Vector2, lookVector = Vector2.UP, coordinateSpace = CoordinateSpace2.LOCAL_SPACE): void\n    {\n        if(coordinateSpace == CoordinateSpace2.LOCAL_SPACE)\n        {\n            const targetVector = Vector2.subtract(target, this.position);\n\n            if(targetVector.length() > 0)\n            {\n                this._rotation = lookVector.angleBetweenSigned(targetVector);\n                this.localMatrixDirty = true;\n            }\n        }\n        else\n        {\n            this.updateWorldMatrix();\n\n            const worldPosition = this.localToWorldMatrix.getTranslation();\n            const targetVector = Vector2.subtract(target, worldPosition);\n\n            if(targetVector.length() > 0)\n            {\n                const worldLookVector = this.localToWorldMatrix.transformVector(lookVector);\n                this._rotation += worldLookVector.angleBetweenSigned(targetVector);\n                this.localMatrixDirty = true;\n            }\n        }\n    }\n\n    public composeLocalMatrix(): void\n    {\n        this.localMatrixDirty = false;\n        this.localMatrixUpdated = false;\n        this.worldMatrixDirty = true;\n        this.localBoundsDirty = true;\n        this.localToParentMatrix.compose(this._position, this._rotation, this._scale, this._shear);\n    }\n\n    public decomposeLocalMatrix(): void\n    {\n        this.localMatrixDirty = false;\n        this.localMatrixUpdated = false;\n        \n        [this._position, this._rotation, this._scale, this._shear] = this.localToParentMatrix.decompose();\n    }\n\n    updateLocalBounds(): void\n    {\n        this._localBoundingBox.copy(this.boundingBox);\n        this._localBoundingBox.transform(this.localToParentMatrix);\n        this._localBoundingCircle.copy(this.boundingCircle);\n        this._localBoundingCircle.transform(this.localToParentMatrix);\n        this.localBoundsDirty = false;\n    }\n\n    updateWorldBounds(): void\n    {\n        this._worldBoundingBox.copy(this.boundingBox);\n        this._worldBoundingBox.transform(this.localToWorldMatrix);\n        this._worldBoundingCircle.copy(this.boundingCircle);\n        this._worldBoundingCircle.transform(this.localToWorldMatrix)\n        this.worldBoundsDirty = false;\n    }\n\n    /**\n     * Checks if this Node2 intersects another Node2, using either a BoundingCircle or AxisAlignedBoundingBox\n     * \n     * @param other - The Node2 to check for intersection with \n     * @param mode - The IntersectionMode2 to use for the comparison (default: BOUNDING_CIRCLE)\n     * @param space - The CoordinateSpace2 to use for the comparison (default: LOCAL_SPACE)\n     * @returns A boolean indicating whether the two objects intersect\n     */\n    intersects(other: Node2, mode = IntersectionMode2.BOUNDING_CIRCLE, space = CoordinateSpace2.LOCAL_SPACE): boolean\n    {\n        if(space == CoordinateSpace2.LOCAL_SPACE)\n        {\n            if(this.localMatrixDirty)\n                this.composeLocalMatrix();\n\n            if(other.localMatrixDirty)\n                other.composeLocalMatrix();\n\n            if(this.localBoundsDirty)\n                this.updateLocalBounds();\n\n            if(other.localBoundsDirty)\n                other.updateLocalBounds();\n   \n            if(mode == IntersectionMode2.BOUNDING_CIRCLE)\n                return this._localBoundingCircle.intersects(other._localBoundingCircle);\n            else if(mode == IntersectionMode2.AXIS_ALIGNED_BOUNDING_BOX)\n                return this._localBoundingBox.intersects(other._localBoundingBox);\n            else\n                return false;\n        }\n        else\n        {\n            if(this.localMatrixDirty || this.worldMatrixDirty)\n                this.updateWorldMatrix();\n\n            if(this.localMatrixDirty || this.worldMatrixDirty)\n                other.updateWorldMatrix();\n\n            if(this.worldBoundsDirty)\n                this.updateWorldBounds();\n\n            if(other.worldBoundsDirty)\n                other.updateWorldBounds();\n\n            if(mode == IntersectionMode2.BOUNDING_CIRCLE)\n                return this._worldBoundingCircle.intersects(other._worldBoundingCircle);\n            else if(mode == IntersectionMode2.AXIS_ALIGNED_BOUNDING_BOX)\n                return this._worldBoundingBox.intersects(other._worldBoundingBox);\n            else\n                return false;\n        }\n    }\n}", "import { Light } from './Light'\n\n/**\n * This class is used each frame as a temporary data structure to pass a complete list of\n * lights that have been added to the scene to any shader programs.  You should not add or\n * clear lights directly via this class.  Instead, create a new AmbientLight, \n * DirectionalLight, and/or PointLight object and add it to the scene the same way you would\n * with a Mesh3 or other scene object.\n */\nexport class LightManager\n{\n    public lights: Light[];\n    public lightTypes: number[];\n    public lightPositions: number[];\n    public ambientIntensities: number[];\n    public diffuseIntensities: number[];\n    public specularIntensities: number[];\n\n    constructor()\n    {\n        this.lights = [];\n        this.lightTypes = [];\n        this.lightPositions = [];\n        this.ambientIntensities = [];\n        this.diffuseIntensities = [];\n        this.specularIntensities = [];\n    }\n\n    clear(): void\n    {\n        this.lights = [];\n        this.lightTypes = [];\n        this.lightPositions = [];\n        this.ambientIntensities = [];\n        this.diffuseIntensities = [];\n        this.specularIntensities = [];\n    }\n\n    addLight(light: Light): void\n    {\n        const alreadyAdded = this.lights.some((elem: Light)=>{\n            return elem==light;\n        });\n\n        if(!alreadyAdded)\n            this.lights.push(light)\n    }\n\n    getNumLights(): number\n    {\n        return this.lights.length;\n    }\n\n    updateLights(): void\n    {\n        this.lights.forEach((light: Light) => {\n\n            const worldPosition = light.localToWorldMatrix.getTranslation();\n            this.lightPositions.push(worldPosition.x, worldPosition.y, worldPosition.z);\n            this.lightTypes.push(light.getType());\n\n            if(light.visible)\n            {\n                this.ambientIntensities.push(light.ambientIntensity.x, light.ambientIntensity.y, light.ambientIntensity.z);\n                this.diffuseIntensities.push(light.diffuseIntensity.x, light.diffuseIntensity.y, light.diffuseIntensity.z);\n                this.specularIntensities.push(light.specularIntensity.x, light.specularIntensity.y, light.specularIntensity.z);\n            }\n            else\n            {\n                this.ambientIntensities.push(0, 0, 0);\n                this.diffuseIntensities.push(0, 0, 0);\n                this.specularIntensities.push(0, 0, 0);\n            }\n        });\n    }\n}", "import { Camera } from \"./Camera\";\nimport { Node2 } from \"./Node2\";\nimport { Node3 } from \"./Node3\";\nimport { LightManager } from \"../lights/LightManager\";\n\n/**\n * The Scene class contains and organizes all of the 2D and 3D objects that GopherGfx can draw each frame.\n * In computer graphics, the classic way to organize all these objects is in a graph data structure called\n * a \"scene graph\".  This Scene class actually contains two such scene graphs, one for all the 2D objects in\n * the scene and one for all the 3D objects in the scene.  Each scene graph follows a tree structure with\n * one root node (see root2d and root3d), and every object in the scene needs to be added to one of these\n * root nodes, either as a direct child of the root node or a child of a child, or child of a child of a child,\n * etc.\n * \n * For the 2D scene graph the base class for every object that can be added to the scene graph is Node2.  If\n * you look at the Node2 class, you will see every Node2 has a postion, rotation, scale, and a number of other\n * properties.\n * \n * For the 3D scene graph the base class for every object is Node3.  Again, each Node3 has a position, rotation,\n * scale, etc.  It is possible to create Node3s directly, and the main reason for this would be to setup a \n * hierarchy of nodes in the scenegraph, for example\n * ```\n *    // add a node for the parent of a car geometry to the scene\n *    const carParentNode = new Node3();\n *    this.scene.add(carParentNode);\n * \n *    // add child nodes to the carParentNode\n *    const wheels = new Node3();\n *    carParentNode.add(wheels);\n *    const doors = new Node3();\n *    carParentNode.add(doors);\n * ```\n * \n * If you don't need a complex hierarchy, you may never deal directly with a Node3 and instead\n * just work with subclasses of Node3, like Mesh3 and PointLight.  In the car example above, none of\n * the Node3s that have been added so far actually draw anything because none of them are meshes.  They\n * are just there for organization.  A next step in creating the car would be to add 4 cylinders Mesh3s\n * under the wheels node, for example:\n * ```\n *    const leftFrontWheel = gfx.Geometry3Factory.createCylinder(..);\n *    wheels.add(leftFrontWheel);\n *    const leftBackWheel = gfx.Geometry3Factory.createCylinder(..);\n *    wheels.add(leftBackWheel);\n *    const rightFrontWheel = gfx.Geometry3Factory.createCylinder(..);\n *    wheels.add(rightFrontWheel);\n *    const rightBackWheel = gfx.Geometry3Factory.createCylinder(..);\n *    wheels.add(rightBackWheel);\n * ```\n * \n * There are several benefits to using a hierarchy like this to organize our Meshes.  If we want to reposition\n * the entire car in the scene, then we can change the position of the carParentNode and all of the wheels, doors,\n * etc, will move because they are all children of the carParentNode.  We may also want to loop through all of\n * the wheels of the car, for example, to make them spin, and we can do this by looping through all of the\n * children of the \"wheels\" node.\n * \n * ```\n *    for (let i=0; i<wheels.children.length; i++) {\n *       // note that wheels.children is an Array of Node3s, so accessing wheels.children[i] will give you a Node3\n *       childNode: gfx.Node3 = wheels.children[i];\n *       // that is great if all we want to do is rotate the wheels becuase rotation is a property of every Node3\n *       childNode.rotation.multiply(Quaternion.makeRotationX(deltaTime * angularVel));\n * \n *       // in this case, we know that wheels.children[i] is also a Mesh3. if we want to change something about\n *       // the mesh, we must first cast wheels.children[i] to a Mesh3 using the keyword \"as\".\n *       childNodeAsMesh: gfx.Mesh3 = wheels.children[i] as gfx.Mesh3;\n *       if (childNodeAsMesh instanceof gfx.Mesh3) {\n *          // the cast to a Mesh3 succeeded and we can now access any properties of the Mesh3\n *          childNodeAsMesh.material.setColor(..);\n *       }\n *    }\n * ```\n */\nexport class Scene\n{\n    /**\n     * The root node for all 3D elements in the scene.\n     */\n    public root3d: Node3;\n\n    /**\n     * The root node for all 2D elements in the scene.\n     */\n    public root2d: Node2;\n\n    /**\n     * Manager for updating the lights in the scene.\n     */\n    private lightManager: LightManager;\n    \n    constructor()\n    {\n        this.root3d = new Node3();\n        this.root2d = new Node2();\n        this.lightManager = new LightManager();\n    }\n\n    /**\n     * Draws the scene by updating the camera's world transform, updating the lights, and drawing the 3D and 2D elements.\n     * @param camera - The camera used to draw the scene.\n     */\n    draw(camera: Camera): void\n    {\n        // Make sure the camera world transform is computed\n        camera.updateWorldMatrix();\n\n        // Update the scene lights\n        this.lightManager.clear();\n        this.root3d.setLights(this.lightManager);\n        this.lightManager.updateLights();\n\n        this.root3d.children.forEach((elem: Node3) => {\n            elem.draw(this.root3d, camera, this.lightManager);\n        });\n\n        this.root2d.children.forEach((elem: Node2) => {\n            elem.draw();\n        });\n    }\n\n    /**\n     * Adds a child element to the scene, either as a Node3 or a Node2.\n     * @param child - The child element to add to the scene.\n     */\n    add(child: Node2 | Node3): void\n    {\n        if(child instanceof Node3)\n        {\n            this.root3d.add(child);\n        }\n        else\n        {\n            this.root2d.add(child);\n        }\n    }\n\n    /**\n     * Traverses the 3D and 2D elements of the scene, recursively calling the `traverseSceneGraph()` method on each element.\n     */\n    traverseSceneGraph(): void\n    {\n        this.root3d.children.forEach((elem: Node3) => {\n            elem.traverseSceneGraph();\n        });\n\n        this.root2d.children.forEach((elem: Node2) => {\n            elem.traverseSceneGraph();\n        });\n    }\n}", "export class AssetManager\n{\n    public requestedAssets: string[];\n    public loadedAssets: string[];\n    public errorAssets: string[];\n\n/**\n * Constructor for the AssetManager class\n * Initializes the requestedAssets, loadedAssets, and errorAssets arrays\n */\n    constructor()\n    {\n        this.requestedAssets = [];\n        this.loadedAssets = [];\n        this.errorAssets = [];\n    }\n\n/**\n * Checks if all requested assets have been loaded\n * \n * @returns boolean value indicating if all assets are loaded\n */\n    allAssetsLoaded(): boolean\n    {\n        return this.requestedAssets.length == (this.loadedAssets.length + this.errorAssets.length);\n    }\n}", "import { Renderer } from './Renderer'\nimport { Camera } from './Camera'\nimport { Scene } from './Scene';\nimport { Vector2 } from '../math/Vector2'\nimport { AssetManager } from '../loaders/AssetManager';\n\n/**\n * The base class for a GopherGfx application.\n*/\nexport abstract class GfxApp \n{\n    /**\n     * The singleton instance of the GfxApp class.\n     */\n    private static instance: GfxApp;\n    \n    /**\n     * Gets the singleton instance of the GfxApp class.\n     * \n     * @returns The singleton instance of the GfxApp class.\n     */\n    public static getInstance(): GfxApp\n    {\n        return GfxApp.instance;\n    }\n\n    /**\n     * The renderer used by the GfxApp instance.\n     */\n    public renderer: Renderer;\n\n    /**\n     * The camera used by the GfxApp instance.\n     */\n    public camera: Camera;\n\n    /**\n     * The scene used by the GfxApp instance.\n     */\n    public scene: Scene;\n\n    /**\n     * Coordinates asynchronous loading of external assets.\n     */\n    public assetManager: AssetManager;\n\n    /**\n     * A boolean indicating whether the GfxApp should continue to run in the background.\n     */\n    public runInBackground: boolean;\n\n    /**\n     * The current game time in seconds.\n     */\n    private time: number;\n\n    /**\n     * A boolean indicating whether the GfxApp is currently paused.\n     */\n    private paused: boolean;\n\n    /**\n     * An array of the previous touches on the touch screen.\n     */\n    private previousTouches: Vector2[];\n\n    /**\n     * Constructor for the GfxApp class\n     * \n     * @param enableStencilBuffer - Boolean value to enable/disable the stencil buffer\n     */\n    constructor(enableStencilBuffer = false)\n    {\n        GfxApp.instance = this;\n\n        this.time = Date.now();\n        this.paused = false;\n\n        this.camera = new Camera();\n        this.scene = new Scene();\n        this.renderer = new Renderer(enableStencilBuffer);\n        this.assetManager = new AssetManager();\n        this.runInBackground = false;\n\n        this.previousTouches = [ new Vector2() ];\n  \n        // Register event handlers\n        window.addEventListener('resize', () => {this.resize()}, false);\n        window.addEventListener('mousedown', (event: MouseEvent) => {this.onMouseDown(event)});\n        window.addEventListener('mouseup', (event: MouseEvent) => {this.onMouseUp(event)});\n        window.addEventListener('mousemove', (event: MouseEvent) => {this.onMouseMove(event)});\n        window.addEventListener('wheel', (event: WheelEvent) => {this.onMouseWheel(event)});\n        window.addEventListener('keydown', (event: KeyboardEvent) => {this.onKeyDown(event)});\n        window.addEventListener('keyup', (event: KeyboardEvent) => {this.onKeyUp(event)});  \n        window.addEventListener('focus', (event: FocusEvent) => {this.onFocusReceived(event)});\n        window.addEventListener('blur', (event: FocusEvent) => {this.onFocusLost(event)});\n        window.addEventListener('touchstart', (event: TouchEvent) => {this.onTouchStart(event)}, {passive: false});\n        window.addEventListener('touchmove', (event: TouchEvent) => {this.onTouchMove(event)}, {passive: false});\n        window.addEventListener('touchend', (event: TouchEvent) => {this.onTouchEnd(event)}, {passive: false});\n        window.addEventListener('touchcancel', (event: TouchEvent) => {this.onTouchEnd(event)}, {passive: false});\n        window.addEventListener('contextmenu', event => event.preventDefault());\n\n        // default orthographic camera\n        this.camera.setOrthographicCamera(0, 1, 0, 1, 0.01, 1);\n    }\n\n    /**\n     * Creates the scene and starts the program\n     */\n    start(): void \n    {\n        this.createScene();\n        this.initializationLoop();\n    }\n\n    /**\n     * Initialization loop for loading assets before starting the main loop\n     */\n    private initializationLoop(): void\n    {\n        if(!this.assetManager.allAssetsLoaded())\n        {\n            window.requestAnimationFrame(() => this.initializationLoop());\n        }\n        else\n        {\n            this.onAssetsLoaded();\n            this.time = Date.now();\n            this.mainLoop();\n        }\n    }\n\n    /**\n     * Main loop for the GfxApp class\n     * \n     * @param deltaTime - The time difference between frames for calculating updates\n     */\n    private mainLoop(): void\n    {\n        if(this.runInBackground || !this.paused)\n        {\n            // Compute the delta time\n            const deltaTime =  (Date.now() - this.time) / 1000;\n\n            // Update the time\n            this.time = Date.now();\n\n            // Update the app\n            this.update(deltaTime);\n            \n            // Compute the world transforms for all objects in the scene graph\n            this.scene.traverseSceneGraph();\n\n            // Call the late update method\n            this.lateUpdate(deltaTime);\n\n            // Draw the graphics\n            this.renderer.render(this.scene, this.camera);\n        }\n\n        // Run the main loop function on the next frame\n        window.requestAnimationFrame(() => this.mainLoop());\n    }\n\n    /**\n     * Resizes the viewport of the GfxApp\n     */\n    resize(): void\n    {\n        this.renderer.resize(window.innerWidth, window.innerHeight, this.camera.getAspectRatio());\n    }\n\n    /**\n     * Creates a simulated mouse down event for touch input\n     */\n    onTouchStart(event: TouchEvent): void\n    {\n        event.preventDefault();\n        if(event.touches.length == 1)\n            this.simulateMouseEvent('mousedown', event);\n    }\n\n    /**\n     * Creates a simulated mouse move event for touch input\n     */\n    onTouchMove(event: TouchEvent): void\n    {\n        event.preventDefault();\n        if(event.touches.length == 1)\n            this.simulateMouseEvent('mousemove', event);\n        else\n            this.simulateWheelEvent(event);\n    }\n\n    /**\n     * Creates a simulated mouse up event for touch input\n     */\n    onTouchEnd(event: TouchEvent): void\n    {\n        event.preventDefault();\n        if(event.touches.length == 0)\n            this.simulateMouseEvent('mouseup', event);\n    }\n\n    /**\n     * Handles focus events to pause and resume the application\n     * \n     * @param event - The FocusEvent\n     */\n    onFocusReceived(event: FocusEvent): void \n    {\n        this.resume();\n    }\n\n    /**\n     * Handles focus events to pause and resume the application\n     * \n     * @param event - The FocusEvent\n     */\n    onFocusLost(event: FocusEvent): void \n    {\n        this.pause();\n    }\n\n    /**\n     * Pauses the application\n     */\n    pause(): void\n    {\n        this.paused = true;\n    }\n\n    /**\n     * Resumes the application\n     */\n    resume(): void\n    {\n        this.time = Date.now();\n        this.paused = false;\n    }\n\n    /**\n     * Returns true if the application is paused\n     * \n     * @returns True if the application is paused, false otherwise\n     */\n    isPaused(): boolean\n    {\n        return this.paused;\n    }\n\n    /**\n     * Converts mouse coordinates to normalized device coordinates\n     * \n     * @param mouseX - The x coordinate of the mouse\n     * @param mouseY - The y coordinate of the mouse\n     * @returns The normalized device coordinates\n     */\n    getNormalizedDeviceCoordinates(mouseX: number, mouseY: number): Vector2\n    {\n        return this.renderer.getNormalizedDeviceCoordinates(mouseX, mouseY);\n    }\n\n    /**\n     * Simulates a mouse event from a given TouchEvent\n     * \n     * @param type - The type of mouse event to simulate\n     * @param touchEvent - The touch event to use for simulating the mouse event\n     */\n    private simulateMouseEvent(type: string, touchEvent: TouchEvent): void\n    {\n        if(this.previousTouches.length == 1)\n        {\n            const mouseEvent = new MouseEvent(type, {\n                'button': 0,\n                'buttons': 1,\n                'clientX': touchEvent.changedTouches[0].clientX, \n                'clientY': touchEvent.changedTouches[0].clientY,\n                'screenX': touchEvent.changedTouches[0].screenX,\n                'screenY': touchEvent.changedTouches[0].screenY,\n                'movementX': touchEvent.changedTouches[0].clientX - this.previousTouches[0].x,\n                'movementY': touchEvent.changedTouches[0].clientY - this.previousTouches[0].y,\n                'view': touchEvent.view,\n                cancelable: true,\n                bubbles: true,\n            });\n\n            touchEvent.target!.dispatchEvent(mouseEvent);\n        }\n\n        this.previousTouches = [ new Vector2(touchEvent.changedTouches[0].clientX, touchEvent.changedTouches[0].clientY) ];\n    }\n\n    /**\n     * Simulates a mouse wheel event from a given TouchEvent\n     * \n     * @param touchEvent - The touch event to use for simulating the wheel event\n     */\n    private simulateWheelEvent(touchEvent: TouchEvent): void\n    {\n        if(this.previousTouches.length > 1)\n        {\n            const previousDistance = this.previousTouches[0].distanceTo(this.previousTouches[1]);\n            const currentDistance = Math.sqrt(\n                (touchEvent.touches[0].clientX -  touchEvent.touches[1].clientX) * (touchEvent.touches[0].clientX -  touchEvent.touches[1].clientX) +\n                (touchEvent.touches[0].clientY -  touchEvent.touches[1].clientY) * (touchEvent.touches[0].clientY -  touchEvent.touches[1].clientY)\n            );\n            \n            let scaleFactor = 0;\n            if(currentDistance > previousDistance)\n                scaleFactor = -currentDistance / previousDistance;\n            else if(currentDistance < previousDistance)\n                scaleFactor = previousDistance / currentDistance;\n\n            const wheelEvent = new WheelEvent('wheel', {\n                'clientX': (touchEvent.touches[0].clientX + touchEvent.touches[1].clientX) / 2, \n                'clientY': (touchEvent.touches[0].clientY + touchEvent.touches[1].clientY) / 2,\n                'screenX': (touchEvent.touches[0].screenX + touchEvent.touches[1].screenX) / 2,\n                'screenY': (touchEvent.touches[0].screenY + touchEvent.touches[1].screenY) / 2,\n                'movementX': (\n                    (touchEvent.touches[0].clientX - this.previousTouches[0].x) + \n                    (touchEvent.touches[1].clientX - this.previousTouches[1].x) ) / 2,\n                'movementY': (\n                    (touchEvent.touches[0].clientY - this.previousTouches[0].y) + \n                    (touchEvent.touches[1].clientY - this.previousTouches[1].y) ) / 2,\n                'deltaX': 0,\n                'deltaY': 50 * scaleFactor,\n                'deltaZ': 0,\n                'deltaMode': WheelEvent.DOM_DELTA_PIXEL,\n                'view': touchEvent.view,\n                cancelable: true,\n                bubbles: true,\n            });\n\n            touchEvent.target!.dispatchEvent(wheelEvent);\n        }  \n\n        this.previousTouches = [];\n        for(let i = 0; i < touchEvent.changedTouches.length; i++)\n        {\n            this.previousTouches.push(new Vector2(touchEvent.touches[i].clientX, touchEvent.touches[i].clientY));\n        }   \n    }\n\n    /**\n     * Abstract method to be implemented by any subclass of GfxApp.\n     * Creates the scene for the application.\n     */\n    abstract createScene(): void;\n\n    /**\n     * Abstract method to be implemented by any subclass of GfxApp.\n     * Updates the application's state with the given deltaTime.\n     * \n     * @param deltaTime - Time elapsed since the last update call (in seconds)\n     */\n    abstract update(deltaTime: number): void;\n\n    /**\n     * Late update method to be called just before drawing the scene.\n     * Optional method - subclasses do not need to override it.\n     * \n     * @param deltaTime - Time elapsed since the last update call (in seconds)\n     */\n    lateUpdate(deltaTime: number): void {}\n\n    /**\n     * Method called after all assets are loaded before entering main loop.\n     * Optional method - subclasses do not need to override it.\n     */\n    onAssetsLoaded(): void {}\n\n    /**\n     * Method called when the mouse is clicked. Subclasses can override this method to handle the event.\n     * \n     * @param event - The MouseEvent object associated with the mouse click\n     */\n    onMouseDown(event: MouseEvent): void {}\n\n    /**\n     * Method called when the mouse is released. Subclasses can override this method to handle the event.\n     * \n     * @param event - The MouseEvent object associated with the mouse release\n     */\n    onMouseUp(event: MouseEvent): void {}\n\n    /**\n     * Method called when the mouse is moved. Subclasses can override this method to handle the event.\n     * \n     * @param event - The MouseEvent object associated with the mouse movement\n     */\n    onMouseMove(event: MouseEvent): void {}\n\n    /**\n     * Method called when the mouse wheel is moved. Subclasses can override this method to handle the event.\n     * \n     * @param event - The WheelEvent object associated with the mouse wheel movement\n     */\n    onMouseWheel(event: WheelEvent): void {}\n\n    /**\n     * Method called when a key is pressed. Subclasses can override this method to handle the event.\n     * \n     * @param event - The KeyboardEvent object associated with the key press\n     */\n    onKeyDown(event: KeyboardEvent): void {}\n\n    /**\n     * Method called when a key is released. Subclasses can override this method to handle the event.\n     * \n     * @param event - The KeyboardEvent object associated with the key release\n     */\n    onKeyUp(event: KeyboardEvent): void {}\n}", "export class ShaderProgram\n{\n    private vertexShader: WebGLShader | null;\n    private fragmentShader: WebGLShader | null;\n    private shaderProgram: WebGLProgram | null;\n    private vertexSource: string;\n    private fragmentSource: string;\n\n    public initialized: boolean;\n\n    constructor(vertexSource: string, fragmentSource: string)\n    {\n        this.vertexSource = vertexSource;\n        this.fragmentSource = fragmentSource;\n        this.vertexShader = null;\n        this.fragmentShader = null;\n        this.shaderProgram = null;\n        this.initialized = false;\n    }\n\n    public initialize(gl: WebGL2RenderingContext): void \n    {\n        if(this.initialized)\n            return;\n\n        this.initialized = true;\n\n        this.vertexShader = this.createVertexShader(gl, this.vertexSource);\n        this.fragmentShader = this.createFragmentShader(gl, this.fragmentSource);\n\n        if(this.vertexShader && this.fragmentShader)\n            this.shaderProgram = this.createShaderProgram(gl, this.vertexShader, this.fragmentShader); \n    }\n\n    private createVertexShader(gl: WebGL2RenderingContext, source: string): WebGLShader | null \n    {\n        const shader = gl.createShader(gl.VERTEX_SHADER);\n\n        if(!shader)\n        {\n            console.error('Error: unable to create vertex shader');\n        }\n        else\n        {\n            gl.shaderSource(shader, source);\n            gl.compileShader(shader);\n\n            if(!gl.getShaderParameter(shader, gl.COMPILE_STATUS))\n            {\n                 console.error('Error: unable to load vertex shader');\n                 console.error(gl.getShaderInfoLog(shader));\n            }\n        }\n\n        return shader;\n    }\n\n    private createFragmentShader(gl: WebGL2RenderingContext, source: string): WebGLShader | null  \n    {\n        const shader = gl.createShader(gl.FRAGMENT_SHADER);\n\n        if(!shader)\n        {\n            console.error('Error: unable to create fragment shader');\n        }\n        else\n        {\n            gl.shaderSource(shader, source);\n            gl.compileShader(shader);\n\n            if(!gl.getShaderParameter(shader, gl.COMPILE_STATUS))\n            {\n                 console.error('Error: unable to load fragment shader');\n                 console.error(gl.getShaderInfoLog(shader));\n            }\n        }\n\n        return shader;\n    }\n\n    private createShaderProgram(gl: WebGL2RenderingContext, vertexShader: WebGLShader, fragmentShader: WebGLShader): WebGLProgram | null\n    {\n        let program: WebGLShader | null = null;\n\n        if(vertexShader && fragmentShader)\n        {\n            program = gl.createProgram();\n\n            if(!program)\n            {\n                console.error(\"Error: could not create shader program\");\n                return null;\n            }\n            \n\n            gl.attachShader(program, vertexShader);\n            gl.attachShader(program, fragmentShader);\n            gl.linkProgram(program);\n\n            if(!gl.getProgramParameter(program, gl.LINK_STATUS))\n            {\n                console.error(\"Error: could not link shader program\");\n                console.error(gl.getProgramInfoLog(program));\n                return null;\n            }\n        }\n\n        return program;\n    }\n\n    public getProgram(): WebGLProgram | null\n    {\n        return this.shaderProgram;\n    }\n\n    public getAttribute(gl: WebGL2RenderingContext, attribute: string): number\n    {\n        if(this.shaderProgram)\n            return gl.getAttribLocation(this.shaderProgram, attribute);\n        else\n            return -1;\n    }\n\n    public getUniform(gl: WebGL2RenderingContext, uniform: string): WebGLUniformLocation | null\n    {\n        \n        if(this.shaderProgram)\n            return gl.getUniformLocation(this.shaderProgram, uniform);\n        else\n            return null;\n    }\n}", "// @ts-ignore\nimport shapeVertexShader from '../shaders/material2.vert'\n// @ts-ignore\nimport shapeFragmentShader from '../shaders/material2.frag'\n\nimport { GfxApp } from '../core/GfxApp';\nimport { ShaderProgram } from './ShaderProgram';\nimport { Mesh2 } from '../geometry/2d/Mesh2';\nimport { Color } from '../math/Color' \nimport { Texture } from './Texture';\n\n/**\n * Represents a Material for use in 2D graphics\n * @export\n * @class Material2\n */\nexport class Material2\n{\n    /**\n     * Controls the visibility of the material (false = hidden)\n     * \n     * @memberof Material2\n     */\n    public visible: boolean;\n\n    /**\n     * Controls the color of the material (defaults to white)\n     * \n     * @memberof Material2\n     */\n    public color: Color;\n\n    /**\n     * Controls the draw mode of the material (one of gl.POINTS, gl.LINES,\n     * gl.LINE_STRIP, gl.LINE_LOOP, gl.TRIANGLES, gl.TRIANGLE_STRIP,\n     * gl.TRIANGLE_FAN)\n     * \n     * @memberof Material2\n     */\n    public drawMode: number;\n\n    /**\n     * Controls the texture of the material. Can be null, meaning no texture.\n     * \n     * @memberof Material2\n     */\n    public texture: Texture | null;\n\n    private readonly gl: WebGL2RenderingContext;\n\n    /**\n     * Shaders to use for all materials\n     * \n     * @constructor\n     * @memberof Material2\n     * @static\n     */\n    public static shader = new ShaderProgram(shapeVertexShader, shapeFragmentShader);\n\n    private colorUniform: WebGLUniformLocation | null;\n    private modelUniform: WebGLUniformLocation | null;\n    private layerUniform: WebGLUniformLocation | null;\n\n    private textureUniform: WebGLUniformLocation | null;\n    private useTextureUniform: WebGLUniformLocation | null;\n\n    private positionAttribute: number;\n    private colorAttribute: number;\n    private texCoordAttribute: number;\n\n    /**\n    * Constructs a new Material2, defaulting to a white textureless line loop\n    */\n    constructor()\n    {\n        this.gl  = GfxApp.getInstance().renderer.gl;\n\n        this.visible = true;\n        this.color = new Color(1, 1, 1);\n        this.drawMode = this.gl.LINE_LOOP;\n        this.texture = null;\n        \n        Material2.shader.initialize(this.gl);\n\n        this.colorUniform = Material2.shader.getUniform(this.gl, 'materialColor');\n        this.modelUniform = Material2.shader.getUniform(this.gl, 'modelMatrix');\n        this.layerUniform = Material2.shader.getUniform(this.gl, 'layer');\n\n        this.textureUniform = Material2.shader.getUniform(this.gl, 'textureImage');\n        this.useTextureUniform = Material2.shader.getUniform(this.gl, 'useTexture');\n\n        this.positionAttribute = Material2.shader.getAttribute(this.gl, 'position');\n        this.colorAttribute = Material2.shader.getAttribute(this.gl, 'color');\n        this.texCoordAttribute = Material2.shader.getAttribute(this.gl, 'texCoord');\n    }\n\n    /**\n     * Copies an existing Material2 to this one\n     * \n     * @param box - The Material2 to copy\n     */\n    copy(mat: Material2): void\n    {\n        this.visible = mat.visible;\n        this.color.copy(mat.color);\n        this.drawMode = mat.drawMode;\n        this.texture = mat.texture;\n    }\n\n    /**\n     * Draws a shape with this material and a given transform\n     * \n     * @param shape - The shape to draw with this material\n     * @param transform - The transform where the shape should be drawn\n     */\n    draw(mesh: Mesh2): void\n    {\n        if(!this.visible || mesh.vertexCount == 0)\n            return;\n\n        // Switch to this shader\n        this.gl.useProgram(Material2.shader.getProgram());\n\n        // Set the model matrix uniform\n        this.gl.uniformMatrix3fv(this.modelUniform, false, mesh.localToWorldMatrix.mat);\n\n        // Set the material property uniforms\n        this.gl.uniform4f(this.colorUniform, this.color.r, this.color.g, this.color.b, this.color.a);\n\n        // Set the layer uniform\n        this.gl.uniform1f(this.layerUniform, mesh.layer);\n\n        // Set the vertex colors\n        if(mesh.hasVertexColors)\n        {\n            this.gl.enableVertexAttribArray(this.colorAttribute);\n            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, mesh.colorBuffer);\n            this.gl.vertexAttribPointer(this.colorAttribute, 4, this.gl.FLOAT, false, 0, 0);\n        }\n        else\n        {\n            this.gl.disableVertexAttribArray(this.colorAttribute);\n            this.gl.vertexAttrib4f(this.colorAttribute, 1, 1, 1, 1);\n        }\n\n        // Set the vertex positions\n        this.gl.enableVertexAttribArray(this.positionAttribute);\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, mesh.positionBuffer);\n        this.gl.vertexAttribPointer(this.positionAttribute, 2, this.gl.FLOAT, false, 0, 0);\n\n        if(this.texture)\n        {\n            // Activate the texture in the shader\n            this.gl.uniform1i(this.useTextureUniform, 1);\n\n            // Set the texture\n            this.gl.activeTexture(this.gl.TEXTURE0 + this.texture.id)\n            this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture.texture);\n            this.gl.uniform1i(this.textureUniform, this.texture.id);\n\n            // Set the texture coordinates\n            this.gl.enableVertexAttribArray(this.texCoordAttribute);\n            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, mesh.texCoordBuffer);\n            this.gl.vertexAttribPointer(this.texCoordAttribute, 2, this.gl.FLOAT, false, 0, 0);\n        }\n        else\n        {\n            // Disable the texture in the shader\n            this.gl.uniform1i(this.useTextureUniform, 0);\n            this.gl.disableVertexAttribArray(this.texCoordAttribute);\n        }\n\n        // Draw the shape\n        this.gl.drawArrays(this.drawMode, 0, mesh.vertexCount);\n    }\n}", "import { Node2 } from \"../../core/Node2\";\nimport { Vector2 } from \"../../math/Vector2\";\nimport { Color } from \"../../math/Color\";\nimport { Material2 } from \"../../materials/Material2\";\nimport { GfxApp } from \"../../core/GfxApp\";\n\n/**\n * The base class for 2D triangle meshes.  This class extends Node2 so it can be added directly\n * to the GopherGfx 2D scene graph.  It is possible to create a new \"empty\" Mesh2 and then add\n * triangles to it.  Most of the routines in the Geometry2Factory do this.  Use those to create\n * a new Mesh2 for simple geometric shapes like circles and rectangles.  Those routines also \n * provide good examples of how to create your own custom mesh via code if you wish to create\n * something more complex via programming.\n */\nexport class Mesh2 extends Node2\n{\n    protected readonly gl: WebGL2RenderingContext;\n\n    /**\n     * Buffer that stores the position of each vertex.\n     */\n    public positionBuffer: WebGLBuffer | null;\n\n    /**\n     * Buffer that stores the color of each vertex.\n     */\n    public colorBuffer: WebGLBuffer | null;\n\n    /**\n     * Buffer that stores the texture (UV) coordinate at each vertex.\n     */\n    public texCoordBuffer: WebGLBuffer | null;\n\n    /**\n     * Array of buffers that store custom information for each vertex.\n     */\n    public customBuffers: (WebGLBuffer | null)[];\n\n    /**\n     * Number of vertices in the Mesh2.\n     */\n    public vertexCount: number;\n\n    /**\n     * Material to draw the Mesh2 with.\n     */\n    public material: Material2;\n\n    /**\n     * Flag that determines whether to use vertex colors.\n     */\n    public hasVertexColors: boolean;\n    \n    /**\n     * Construct a new 2D Mesh2\n     */\n    constructor()\n    {\n        super();\n\n        this.gl  = GfxApp.getInstance().renderer.gl;\n\n        this.positionBuffer = this.gl.createBuffer();\n        this.colorBuffer = this.gl.createBuffer();\n        this.texCoordBuffer = this.gl.createBuffer();\n        this.customBuffers = [];\n        this.vertexCount = 0;\n        this.hasVertexColors = false;\n\n        // default material\n        this.material = new Material2();\n    }\n\n    /**\n     * Draw a Mesh2 with a particular Transform (position, rotation, scale)\n     */\n    draw(): void\n    {\n        if(!this.visible)\n            return;\n\n        this.material.draw(this);\n\n        this.children.forEach((elem: Node2) => {\n            elem.draw();\n        });\n    }\n\n    /**\n     * Set the vertices of the Mesh2. Vertices should be in normalized device\n     * coordinates [-1, 1].\n     * \n     * @param vertices - Array of vertices.\n     * @param usage - Intended usage (static or dynamic) of the Mesh2's vertices.\n     */\n    setVertices(vertices: Vector2[] | number[], usage = this.gl.STATIC_DRAW): void\n    {\n        if(vertices.length > 0)\n        {\n            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.positionBuffer);\n\n            let vArray: number[];\n            if(typeof vertices[0] === 'number')\n            {\n                vArray = vertices as number[];\n                \n            }\n            else\n            {\n                vArray = [];\n                (vertices as Vector2[]).forEach((elem: Vector2) =>\n                {\n                    vArray.push(elem.x, elem.y);\n                });\n            }\n            \n            this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(vArray), usage);\n            this.vertexCount = vArray.length / 2;\n\n            this.computeBounds(vertices);\n        }\n    }\n\n    /**\n     * Set the color at each vertex of the Mesh2.\n     * \n     * @param color - Array of colors.\n     * @param usage - Intended usage (static or dynamic) of the Mesh2's vertex colors.\n     */\n    setColors(colors: Color[] | number[], usage = this.gl.STATIC_DRAW): void\n    {\n        if(colors.length > 0)\n        {\n            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.colorBuffer);\n\n            if(typeof colors[0] === 'number')\n            {\n                this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(colors as number[]), usage);\n            }\n            else\n            {\n                const cArray: number[] = [];\n                (colors as Color[]).forEach((elem: Color) =>\n                {\n                    cArray.push(elem.r, elem.g, elem.b, elem.a);\n                });\n                \n                this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(cArray), usage);\n            }\n\n            this.hasVertexColors = true;\n        }\n        else\n        {\n            this.hasVertexColors = false;\n        }\n    }\n\n    /**\n     * Set the texture (UV) coordinates at each vertex of the Mesh2.\n     * \n     * @param texCoords - Array of texture coordinates.\n     * @param usage - Intended usage (static or dynamic) of the Mesh2's UV coordinates.\n     */\n    setTextureCoordinates(texCoords: Vector2[] | number[], usage = this.gl.STATIC_DRAW): void\n    {\n        if(texCoords.length > 0)\n        {\n            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.texCoordBuffer);\n\n            if(typeof texCoords[0] === 'number')\n            {\n                this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(texCoords as number[]), usage);\n            }\n            else\n            {\n                const tArray: number[] = [];\n                (texCoords as Vector2[]).forEach((elem: Vector2) =>\n                {\n                    tArray.push(elem.x, elem.y);\n                });\n                \n                this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(tArray), usage);\n            }\n        }\n    }\n\n    /**\n     * Sets a custom buffer from an input array.\n     * \n     * @param bufferIndex - The index number of the buffer to set.\n     * @param values - Array of numerical values to store in the buffer.\n     * @param usage - Intended usage (static or dynamic) of the Mesh2's buffer.\n     */\n    setCustomBuffer(bufferIndex: number, values: number[], usage = this.gl.STATIC_DRAW): void\n    {\n        while(this.customBuffers.length <= bufferIndex)\n            this.customBuffers.push(this.gl.createBuffer());\n\n        if(values.length > 0)\n        {\n            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.customBuffers[bufferIndex]);\n            this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(values), usage);\n        }\n    }\n\n    /**\n     * Get the vertices of the Mesh2\n     * \n     * @returns - Returns the array of vertices as numbers (not Vector2 objects)\n     */\n    getVertices(): number[]\n    {\n        const vertexArray = new Float32Array(this.vertexCount * 2);\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.positionBuffer);\n        this.gl.getBufferSubData(this.gl.ARRAY_BUFFER, 0, vertexArray);\n        return [... vertexArray];\n    }\n\n    /**\n     * Get the vertex colors of the Mesh2\n     * \n     * @returns - Returns the array of colors as numbers (not Color objects)\n     */\n    getColors(): number[]\n    {\n        const colorArray = new Float32Array(this.vertexCount * 4);\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.colorBuffer);\n        this.gl.getBufferSubData(this.gl.ARRAY_BUFFER, 0, colorArray);\n        return [... colorArray];\n    }\n\n    /**\n     * Get the texture coordinates of the Mesh2\n     * \n     * @returns - Returns the array of texture (UV) coordinates as numbers (not Vector2 objects)\n     */\n    getTextureCoordinates(): number[]\n    {\n        const texCoordArray = new Float32Array(this.vertexCount * 2);\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.texCoordBuffer);\n        this.gl.getBufferSubData(this.gl.ARRAY_BUFFER, 0, texCoordArray);\n        return [... texCoordArray];\n    }\n\n    /**\n     * Get the values in one of the Mesh2's custom buffers\n     * \n     * @param bufferIndex - The index number of the buffer to get.\n     * @param numAvalues - The number of values per vertex in the buffer.\n     * @returns - Returns the array of numbers stored in the buffer\n     */\n    getCustomBuffer(bufferIndex: number, numValues: number): number[]\n    {\n        const customBufferArray = new Float32Array(this.vertexCount * numValues);\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.customBuffers[bufferIndex]);\n        this.gl.getBufferSubData(this.gl.ARRAY_BUFFER, 0, customBufferArray);\n        return [... customBufferArray];\n    }\n\n    /**\n     * Create default (white) vertex colors for the Mesh2\n     */\n    public createDefaultVertexColors(): void\n    {\n        const colors: number[] = [];\n\n        for(let i=0; i < this.vertexCount; i++)\n            colors.push(1, 1, 1, 1);\n\n        this.setColors(colors);\n    }\n\n    /**\n     * Compute the 2D Bounds (both bounding box and bounding circle) of the Mesh2.\n     * \n     * @param vertices - Vertices to include in the Mesh2. If empty, defaults to\n     * the object's current vertices.\n     */\n    public computeBounds(vertices: Vector2[] | number[] | null): void\n    {\n        if(!vertices)\n        {\n            vertices = this.getVertices();\n        } \n        \n        if(vertices.length == 0)\n            return;\n\n        this.boundingBox.computeBounds(vertices);\n        this.boundingCircle.computeBounds(vertices, this.boundingBox);\n\n        this.localBoundsDirty = true;\n        this.worldBoundsDirty = true;\n    }\n\n    public createInstance(copyTransform = true): Mesh2\n    {\n        const instance = new Mesh2();\n        instance.positionBuffer = this.positionBuffer;\n        instance.colorBuffer = this.colorBuffer;\n        instance.texCoordBuffer = this.texCoordBuffer;\n        instance.customBuffers = this.customBuffers;\n        instance.vertexCount = this.vertexCount;\n        instance.hasVertexColors = this.hasVertexColors;\n        instance.material = this.material;\n        instance.visible = this.visible;\n        instance.boundingBox = this.boundingBox;\n        instance.boundingCircle = this.boundingCircle;\n        instance.localBoundsDirty = true;\n        instance.worldBoundsDirty = true;\n        \n        if(copyTransform)\n        {\n            instance._position.copy(this._position);\n            instance._rotation = this._rotation;\n            instance._scale.copy(this._scale);\n            if(this._shear)\n            {\n                instance._shear = new Vector2();\n                instance._shear.copy(this._shear);\n            }\n            instance.localToParentMatrix.copy(this.localToParentMatrix);\n            instance.localToWorldMatrix.copy(this.localToWorldMatrix);\n            instance.localMatrixDirty = this.localMatrixDirty;\n            instance.worldMatrixDirty = true;\n            instance.layer = this.layer;\n        }\n\n        return instance;\n    }\n}", "import { Node2 } from \"../../core/Node2\";\nimport { Vector2 } from \"../../math/Vector2\";\nimport { Color } from \"../../math/Color\";\nimport { GfxApp } from \"../../core/GfxApp\";\nimport { Material2 } from \"../../materials/Material2\";\n\nexport enum LineMode2\n{\n    LINES,\n    LINE_STRIP,\n    LINE_LOOP\n}\n\n/**\n * The base class for 2D lines.  This class extends Node2 so it can be added directly\n * to the GopherGfx 2D scene graph.  The class can draw line segments, line strips,\n * and line loops.  The vertices are interpreted differently depending upon the \n * LineMode2 that is set.  WebGL only supports lines that are exactly 1 pixel\n * thick.  To draw a more substantial \"line\", you need to draw the line using triangles.\n */\nexport class Line2 extends Node2\n{\n    protected readonly gl: WebGL2RenderingContext;\n\n    public color: Color;\n    public vertexCount: number;\n    public lineMode: number;\n\n    public readonly positionBuffer: WebGLBuffer | null;\n    public readonly colorBuffer: WebGLBuffer | null;\n\n    private colorUniform: WebGLUniformLocation | null;\n    private useTextureUniform: WebGLUniformLocation | null;\n    private textureUniform: WebGLUniformLocation | null;\n    private modelUniform: WebGLUniformLocation | null;\n    private layerUniform: WebGLUniformLocation | null;\n    private positionAttribute: number;\n    private colorAttribute: number;\n    private texCoordAttribute: number;\n\n    /**\n     * Flag that determines whether to use vertex colors.\n     */\n    public hasVertexColors: boolean;\n \n    /**\n     * Creates an instance of Line2.\n     */\n    constructor(lineMode = LineMode2.LINE_STRIP)\n    {\n        super();\n\n        this.color = new Color(1, 1, 1);\n        this.vertexCount = 0;\n        this.lineMode = lineMode;\n\n        this.gl  = GfxApp.getInstance().renderer.gl;\n        this.positionBuffer = this.gl.createBuffer();\n        this.colorBuffer = this.gl.createBuffer();\n       \n        Material2.shader.initialize(this.gl);\n        this.colorUniform = Material2.shader.getUniform(this.gl, 'materialColor');\n        this.modelUniform = Material2.shader.getUniform(this.gl, 'modelMatrix');\n        this.layerUniform = Material2.shader.getUniform(this.gl, 'layer');\n        this.useTextureUniform = Material2.shader.getUniform(this.gl, 'useTexture');\n        this.textureUniform = Material2.shader.getUniform(this.gl, 'textureImage');\n        this.positionAttribute = Material2.shader.getAttribute(this.gl, 'position');\n        this.colorAttribute = Material2.shader.getAttribute(this.gl, 'color');\n        this.texCoordAttribute = Material2.shader.getAttribute(this.gl, 'texCoord');\n\n        this.hasVertexColors = false;\n    }\n\n    /**\n     * Draws the Line object\n     */\n    draw(): void\n    {\n        if(!this.visible)\n            return;\n\n        // Switch to this shader\n        this.gl.useProgram(Material2.shader.getProgram());\n\n        // Disable the texture in the shader\n        this.gl.uniform1i(this.useTextureUniform, 0);\n        this.gl.disableVertexAttribArray(this.texCoordAttribute);\n\n        // Set the model matrix uniform\n        this.gl.uniformMatrix3fv(this.modelUniform, false, this.localToWorldMatrix.mat);\n\n        // Set the material property uniforms\n        this.gl.uniform4f(this.colorUniform, this.color.r, this.color.g, this.color.b, this.color.a);\n\n        // Set the layer uniform\n        this.gl.uniform1f(this.layerUniform, this.layer);\n\n        // Set the vertex colors\n        if(this.hasVertexColors)\n        {\n            this.gl.enableVertexAttribArray(this.colorAttribute);\n            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.colorBuffer);\n            this.gl.vertexAttribPointer(this.colorAttribute, 4, this.gl.FLOAT, false, 0, 0);\n        }\n        else\n        {\n            this.gl.disableVertexAttribArray(this.colorAttribute);\n            this.gl.vertexAttrib4f(this.colorAttribute, 1, 1, 1, 1);\n        } \n\n        // Set the vertex positions\n        this.gl.enableVertexAttribArray(this.positionAttribute);\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.positionBuffer);\n        this.gl.vertexAttribPointer(this.positionAttribute, 2, this.gl.FLOAT, false, 0, 0);\n\n        // Draw the lines\n        this.gl.drawArrays(this.glLineMode(), 0, this.vertexCount);\n        \n        this.children.forEach((elem: Node2) => {\n            elem.draw();\n        });\n    }\n\n    /**\n     * Sets the vertices of the Line object\n     * \n     * @param vertices - An array of Vector2 objects or numbers representing the vertex positions\n     * @param usage - OpenGL flag specifying the expected usage of the buffer (defaults to STATIC_DRAW)\n     */\n    setVertices(vertices: Vector2[] | number[], usage = this.gl.STATIC_DRAW): void\n    {\n        if(vertices.length > 0)\n        {\n            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.positionBuffer);\n\n            let vArray: number[];\n            if(typeof vertices[0] === 'number')\n            {\n                vArray = vertices as number[];\n                \n            }\n            else\n            {\n                vArray = [];\n                (vertices as Vector2[]).forEach((elem: Vector2) =>\n                {\n                    vArray.push(elem.x, elem.y);\n                });\n            }\n            \n            this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(vArray), usage);\n            this.vertexCount = vArray.length / 2;\n        }\n    }\n\n    /**\n     * Sets the colors of the Line object\n     * \n     * @param colors - An array of Color objects or numbers representing the vertex colors\n     * @param usage - OpenGL flag specifying the expected usage of the buffer (defaults to STATIC_DRAW)\n     */\n    setColors(colors: Color[] | number[], usage = this.gl.STATIC_DRAW): void\n    {\n        if(colors.length > 0)\n        {\n            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.colorBuffer);\n\n            if(typeof colors[0] === 'number')\n            {\n                this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(colors as number[]), usage);\n            }\n            else\n            {\n                const cArray: number[] = [];\n                (colors as Color[]).forEach((elem: Color) =>\n                {\n                    cArray.push(elem.r, elem.g, elem.b, elem.a);\n                });\n                \n                this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(cArray), usage);\n            }\n\n            this.hasVertexColors = true;\n        }\n        else\n        {\n            this.hasVertexColors = false;\n        }\n    }\n\n    /**\n     * Gets the vertex positions of the Line object\n     * \n     * @returns An array of numbers representing the vertex positions\n     */\n    getVertices(): number[]\n    {\n        const vertexArray = new Float32Array(this.vertexCount * 2);\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.positionBuffer);\n        this.gl.getBufferSubData(this.gl.ARRAY_BUFFER, 0, vertexArray);\n        return [... vertexArray];\n    }\n\n    /**\n     * Gets the vertex colors of the Line object\n     * \n     * @returns An array of numbers representing the vertex colors\n     */\n    getColors(): number[]\n    {\n        const colorArray = new Float32Array(this.vertexCount * 4);\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.colorBuffer);\n        this.gl.getBufferSubData(this.gl.ARRAY_BUFFER, 0, colorArray);\n        return [... colorArray];\n    }\n\n    \n    /**\n     * Creates a default set of colors for the Line object, with each vertex having a color of white (r,g,b,a = 1,1,1,1)\n     */\n    public createDefaultVertexColors(): void\n    {\n        const colors: number[] = [];\n\n        for(let i=0; i < this.vertexCount; i++)\n            colors.push(1, 1, 1, 1);\n\n        this.setColors(colors);\n    }\n\n    /**\n     * Returns the appropriate OpenGL line mode for the current LineMode2 value\n     * \n     * @returns The OpenGL line mode corresponding to the LineMode2 value\n     */\n    public glLineMode(): number\n    {\n        if(this.lineMode == LineMode2.LINES)\n            return this.gl.LINES;\n        else if(this.lineMode == LineMode2.LINE_STRIP)\n            return this.gl.LINE_STRIP;\n        else\n            return this.gl.LINE_LOOP;  \n    }\n}\n", "import { Mesh2 } from './2d/Mesh2'\nimport { Line2, LineMode2 } from './2d/Line2'\nimport { Vector2 } from '../math/Vector2';\nimport { BoundingBox2 } from \"../math/BoundingBox2\";\n\n/**\n * This is a factory class for creating a variety of common geometries that can be drawn in a 2D scene.\n * Most of these geometries are Mesh2s, meaning they are constructed from triangles, but there are also\n * a few Line2 objects.  This factory is for creating simple 2D geometries (e.g., rectangles, circles)\n * that are easily described by a mathematical function.\n */\nexport class Geometry2Factory\n{\n    public static createBox(width = 1, height = 1): Mesh2\n    {\n        const mesh = new Mesh2();\n        \n        mesh.material.drawMode = WebGL2RenderingContext.TRIANGLE_STRIP;\n\n        const vertices: number[] = [];\n        vertices.push(-width/2, height/2);\n        vertices.push(-width/2, -height/2);\n        vertices.push(width/2, height/2);\n        vertices.push(width/2, -height/2);\n\n        const uvs: number[] = [];\n        uvs.push(0, 0);\n        uvs.push(0, 1);\n        uvs.push(1, 0);\n        uvs.push(1, 1);\n        \n        mesh.setVertices(vertices);\n        mesh.setTextureCoordinates(uvs);\n\n        return mesh;\n    }\n\n    public static createCircle(radius = 0.5, numSegments = 50): Mesh2\n    {\n        const mesh = new Mesh2();\n        \n        mesh.material.drawMode = WebGL2RenderingContext.TRIANGLE_FAN;\n\n        const vertices = [0, 0];\n        const uvs = [0.5, 0.5];\n        const angle = (Math.PI * 2) / numSegments;\n        for (let i = 0; i <= numSegments; i++) {\n            vertices.push(Math.cos(angle * i) * radius, Math.sin(angle * i) * radius);\n            uvs.push((Math.cos(angle * i) + 1) / 2, (Math.sin(angle * i) - 1) / -2);\n        }\n\n        mesh.setVertices(vertices);\n        mesh.setTextureCoordinates(uvs);\n\n        return mesh;\n    }\n\n\n    /**\n     * Creates a pie slice (technically a sector) that spans the arc from startAngle moving counter-clockwise to stopAngle.\n     * @param radius Radius of the circle the pie slice is cut from\n     * @param startAngle The starting angle for the pie slice\n     * @param stopAngle The stopping angle\n     * @param radiansPerSegment Controls the tesselation of the triangle fan, defaults to the same resolution as\n     * Geometry2Factory.createCircle(), 50 segments per 2*PI.\n     * @returns A Mesh2 triangle fan to represent the sector\n     */\n    public static createPieSlice(radius = 0.5, startAngle = 0, stopAngle = Math.PI, radiansPerSegment = Math.PI / 25): Mesh2\n    {\n        const mesh = new Mesh2();\n        \n        mesh.material.drawMode = WebGL2RenderingContext.TRIANGLE_FAN;\n\n        const vertices = [0, 0];\n        const uvs = [0.5, 0.5];\n\n        while (stopAngle < startAngle) {\n            stopAngle += 2 * Math.PI;\n        }\n        const numSegments = Math.floor(stopAngle - startAngle) / radiansPerSegment;\n        const angleInc = (stopAngle - startAngle) / numSegments;\n        let angle = startAngle;\n        for (let i = 0; i <= numSegments; i++) {\n            vertices.push(Math.cos(angle) * radius, Math.sin(angle) * radius);\n            uvs.push((Math.cos(angle) + 1) / 2, (Math.sin(angle) - 1) / -2);\n            angle += angleInc;\n        }\n        if (angle != stopAngle) {\n            // if the total angle does not divide evenly by radiansPerSegment, add one final segment\n            angle = stopAngle;\n            vertices.push(Math.cos(angle) * radius, Math.sin(angle) * radius);\n            uvs.push((Math.cos(angle) + 1) / 2, (Math.sin(angle) - 1) / -2);\n        }\n\n        mesh.setVertices(vertices);\n        mesh.setTextureCoordinates(uvs);\n\n        return mesh;\n    }\n    \n    public static createAxes(size = 1): Line2\n    {\n        const axes = new Line2(LineMode2.LINES);\n        \n        const vertices: number[] = [];\n        const colors: number[] = [];\n\n        // X axis\n        vertices.push(0, 0);\n        vertices.push(size, 0);\n        colors.push(1, 0, 0, 1);\n        colors.push(1, 0, 0, 1);\n\n        // Y axis\n        vertices.push(0, 0);\n        vertices.push(0, size);\n        colors.push(0, 1, 0, 1);\n        colors.push(0, 1, 0, 1);\n\n        axes.setVertices(vertices);\n        axes.setColors(colors);\n\n        return axes;\n    }\n\n    public static createLine(startPoint: Vector2, endPoint: Vector2): Line2\n    {\n        const line = new Line2(LineMode2.LINES);\n\n        const vertices: number[] = [];\n        vertices.push(startPoint.x, startPoint.y);\n        vertices.push(endPoint.x, endPoint.y);\n\n        line.setVertices(vertices);\n\n        return line;\n    }\n\n    public static createLinesFromBox(box: BoundingBox2): Line2\n    {\n        const line = new Line2(LineMode2.LINE_LOOP);\n\n        const vertices: number[] = [];\n        vertices.push(box.min.x, box.min.y);\n        vertices.push(box.max.x, box.min.y);\n        vertices.push(box.max.x, box.max.y);\n        vertices.push(box.min.x, box.max.y);\n\n        line.setVertices(vertices);\n\n        return line;\n    }\n}", "import { GfxApp } from '../core/GfxApp';\nimport { Mesh3 } from '../geometry/3d/Mesh3';\nimport { Camera } from '../core/Camera';\nimport { Node3 } from '../core/Node3';\nimport { LightManager } from '../lights/LightManager';\nimport { Color } from '../math/Color';\n\nexport enum Side\n{\n    FRONT,\n    BACK,\n    DOUBLE\n}\n\nexport abstract class Material3\n{\n    public visible: boolean;\n    public side: Side;\n\n    protected readonly gl: WebGL2RenderingContext;\n\n    constructor()\n    {\n        this.visible = true;\n        this.side = Side.FRONT;\n        this.gl  = GfxApp.getInstance().renderer.gl;\n    }\n\n    protected initialize(): void\n    {\n        if(this.side == Side.DOUBLE)\n        {\n            this.gl.disable(this.gl.CULL_FACE);\n            return;\n        }\n\n        this.gl.enable(this.gl.CULL_FACE);\n\n        if(this.side == Side.FRONT)\n             this.gl.cullFace(this.gl.BACK);\n        else\n            this.gl.cullFace(this.gl.FRONT);\n    }\n\n    abstract draw(object: Mesh3, camera: Camera, lightManager: LightManager): void;\n    abstract setColor(color: Color): void;\n    abstract getColor(): Color;\n}", "// @ts-ignore\nimport gouraudVertexShader from '../shaders/gouraud.vert'\n// @ts-ignore\nimport gouraudFragmentShader from '../shaders/gouraud.frag'\n\nimport { Material3 } from './Material3';\nimport { ShaderProgram } from './ShaderProgram';\nimport { Mesh3 } from '../geometry/3d/Mesh3';\nimport { Camera } from '../core/Camera';\nimport { Node3 } from '../core/Node3';\nimport { LightManager } from '../lights/LightManager';\nimport { Texture } from './Texture';\nimport { Vector3 } from '../math/Vector3'\nimport { Color } from '../math/Color' \n\nexport class GouraudMaterial extends Material3\n{\n    public texture: Texture | null;\n    public ambientColor: Color;\n    public diffuseColor: Color;\n    public specularColor: Color;\n    public shininess: number;\n\n    public static shader = new ShaderProgram(gouraudVertexShader, gouraudFragmentShader);\n\n    private kAmbientUniform: WebGLUniformLocation | null;\n    private kDiffuseUniform: WebGLUniformLocation | null;\n    private kSpecularUniform: WebGLUniformLocation | null;\n    private shininessUniform: WebGLUniformLocation | null;\n    \n    private textureUniform: WebGLUniformLocation | null;\n    private useTextureUniform: WebGLUniformLocation | null;\n\n    private eyePositionUniform: WebGLUniformLocation | null;\n    private modelUniform: WebGLUniformLocation | null;\n    private viewUniform: WebGLUniformLocation | null;\n    private projectionUniform: WebGLUniformLocation | null;\n    private normalUniform: WebGLUniformLocation | null;\n\n    private numLightsUniform: WebGLUniformLocation | null;\n    private lightTypesUniform: WebGLUniformLocation | null;\n    private lightPositionsUniform: WebGLUniformLocation | null;\n    private ambientIntensitiesUniform: WebGLUniformLocation | null;\n    private diffuseIntensitiesUniform: WebGLUniformLocation | null;\n    private specularIntensitiesUniform: WebGLUniformLocation | null;\n\n    private positionAttribute: number;\n    private normalAttribute: number;\n    private colorAttribute: number;\n    private texCoordAttribute: number;\n\n    constructor()\n    {\n        super();\n\n        this.texture = null;\n        this.ambientColor = new Color(1, 1, 1);\n        this.diffuseColor = new Color(1, 1, 1);\n        this.specularColor = new Color(0, 0, 0);\n        this.shininess = 30;\n\n        GouraudMaterial.shader.initialize(this.gl);\n\n        this.kAmbientUniform = GouraudMaterial.shader.getUniform(this.gl, 'kAmbient');\n        this.kDiffuseUniform = GouraudMaterial.shader.getUniform(this.gl, 'kDiffuse');\n        this.kSpecularUniform = GouraudMaterial.shader.getUniform(this.gl, 'kSpecular');\n        this.shininessUniform = GouraudMaterial.shader.getUniform(this.gl, 'shininess');\n\n        this.textureUniform = GouraudMaterial.shader.getUniform(this.gl, 'textureImage');\n        this.useTextureUniform = GouraudMaterial.shader.getUniform(this.gl, 'useTexture');\n\n        this.eyePositionUniform = GouraudMaterial.shader.getUniform(this.gl, 'eyePosition');\n        this.viewUniform = GouraudMaterial.shader.getUniform(this.gl, 'viewMatrix');\n        this.modelUniform = GouraudMaterial.shader.getUniform(this.gl, 'modelMatrix');\n        this.projectionUniform = GouraudMaterial.shader.getUniform(this.gl, 'projectionMatrix');\n        this.normalUniform = GouraudMaterial.shader.getUniform(this.gl, 'normalMatrix');\n\n        this.numLightsUniform = GouraudMaterial.shader.getUniform(this.gl, 'numLights');\n        this.lightTypesUniform = GouraudMaterial.shader.getUniform(this.gl, 'lightTypes');\n        this.lightPositionsUniform = GouraudMaterial.shader.getUniform(this.gl, 'lightPositions');\n        this.ambientIntensitiesUniform = GouraudMaterial.shader.getUniform(this.gl, 'ambientIntensities');\n        this.diffuseIntensitiesUniform = GouraudMaterial.shader.getUniform(this.gl, 'diffuseIntensities');\n        this.specularIntensitiesUniform = GouraudMaterial.shader.getUniform(this.gl, 'specularIntensities');\n\n        this.positionAttribute = GouraudMaterial.shader.getAttribute(this.gl, 'position');\n        this.normalAttribute = GouraudMaterial.shader.getAttribute(this.gl, 'normal');\n        this.colorAttribute = GouraudMaterial.shader.getAttribute(this.gl, 'color');\n        this.texCoordAttribute = GouraudMaterial.shader.getAttribute(this.gl, 'texCoord');   \n    }\n\n    draw(mesh: Mesh3, camera: Camera, lightManager: LightManager): void\n    {\n        if(!this.visible || mesh.triangleCount == 0)\n            return;\n\n        this.initialize();\n\n        // Switch to this shader\n        this.gl.useProgram(GouraudMaterial.shader.getProgram());\n\n        // Set the camera uniforms\n        const worldMatrix = mesh.localToWorldMatrix;\n        const cameraPosition = new Vector3();\n        cameraPosition.transformPoint(camera.localToWorldMatrix);\n        this.gl.uniform3f(this.eyePositionUniform, cameraPosition.x, cameraPosition.y, cameraPosition.z);\n        this.gl.uniformMatrix4fv(this.modelUniform, false, worldMatrix.mat);\n        this.gl.uniformMatrix4fv(this.viewUniform, false, camera.viewMatrix.mat);\n        this.gl.uniformMatrix4fv(this.projectionUniform, false, camera.projectionMatrix.mat);\n        this.gl.uniformMatrix4fv(this.normalUniform, false, worldMatrix.inverse().transpose().mat);\n\n        // Set the material property uniforms\n        this.gl.uniform3f(this.kAmbientUniform, this.ambientColor.r, this.ambientColor.g, this.ambientColor.b);\n        this.gl.uniform3f(this.kDiffuseUniform, this.diffuseColor.r, this.diffuseColor.g, this.diffuseColor.b);\n        this.gl.uniform3f(this.kSpecularUniform,this.specularColor.r, this.specularColor.g, this.specularColor.b);\n        this.gl.uniform1f(this.shininessUniform, this.shininess);\n\n        // Set the light uniforms\n        this.gl.uniform1i(this.numLightsUniform, lightManager.getNumLights());\n        this.gl.uniform1iv(this.lightTypesUniform, lightManager.lightTypes);\n        this.gl.uniform3fv(this.lightPositionsUniform, lightManager.lightPositions);\n        this.gl.uniform3fv(this.ambientIntensitiesUniform, lightManager.ambientIntensities);\n        this.gl.uniform3fv(this.diffuseIntensitiesUniform, lightManager.diffuseIntensities);\n        this.gl.uniform3fv(this.specularIntensitiesUniform, lightManager.specularIntensities);\n\n        // Set the vertex positions\n        this.gl.enableVertexAttribArray(this.positionAttribute);\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, mesh.positionBuffer);\n        this.gl.vertexAttribPointer(this.positionAttribute, 3, this.gl.FLOAT, false, 0, 0);\n\n        // Set the vertex normals\n        this.gl.enableVertexAttribArray(this.normalAttribute);\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, mesh.normalBuffer);\n        this.gl.vertexAttribPointer(this.normalAttribute, 3, this.gl.FLOAT, false, 0, 0);\n\n        // Set the vertex colors\n        if(mesh.hasVertexColors)\n        {\n            this.gl.enableVertexAttribArray(this.colorAttribute);\n            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, mesh.colorBuffer);\n            this.gl.vertexAttribPointer(this.colorAttribute, 4, this.gl.FLOAT, false, 0, 0);\n        }\n        else\n        {\n            this.gl.disableVertexAttribArray(this.colorAttribute);\n            this.gl.vertexAttrib4f(this.colorAttribute, 1, 1, 1, 1);\n        }\n\n        if(this.texture)\n        {\n            // Activate the texture in the shader\n            this.gl.uniform1i(this.useTextureUniform, 1);\n\n            // Set the texture\n            this.gl.activeTexture(this.gl.TEXTURE0 + this.texture.id)\n            this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture.texture);\n            this.gl.uniform1i(this.textureUniform, this.texture.id);\n\n            // Set the texture coordinates\n            this.gl.enableVertexAttribArray(this.texCoordAttribute);\n            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, mesh.texCoordBuffer);\n            this.gl.vertexAttribPointer(this.texCoordAttribute, 2, this.gl.FLOAT, false, 0, 0);\n        }\n        else\n        {\n            // Disable the texture in the shader\n            this.gl.uniform1i(this.useTextureUniform, 0);\n            this.gl.disableVertexAttribArray(this.texCoordAttribute);\n        }\n\n        // Draw the triangles\n        this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, mesh.indexBuffer);\n        this.gl.drawElements(this.gl.TRIANGLES, mesh.triangleCount*3, this.gl.UNSIGNED_SHORT, 0);\n    }\n\n    setColor(color: Color): void\n    {\n        this.ambientColor.copy(color);\n        this.diffuseColor.copy(color);\n        this.specularColor.copy(color);\n    }\n\n    getColor(): Color\n    {\n        return this.diffuseColor;\n    }\n}", "import { Node3 } from \"../../core/Node3\";\nimport { Vector2 } from \"../../math/Vector2\";\nimport { Vector3 } from \"../../math/Vector3\";\nimport { Color } from \"../../math/Color\";\nimport { Material3 } from \"../../materials/Material3\";\nimport { GouraudMaterial } from \"../../materials/GouraudMaterial\";\nimport { Camera } from \"../../core/Camera\";\nimport { LightManager } from \"../../lights/LightManager\";\nimport { GfxApp } from \"../../core/GfxApp\";\n\n/**\n * The base class for 3D triangle meshes.  This class extends Node3 so it can be added directly\n * to the GopherGfx 3D scene graph.  It is possible to create a new \"empty\" Mesh3 and then add\n * triangles to it.  Most of the routines in the Geometry3Factory do this.  Use those to create\n * a new Mesh3 for simple geometric shapes like spheres, cubes, etc.  Those routines also \n * provide good examples of how to create your own custom mesh via code if you wish to create\n * something more complex via programming.  Triangle meshes can also be loaded from a variety \n * of 3D file formats using the MeshLoader class.\n */\nexport class Mesh3 extends Node3\n{\n    protected readonly gl: WebGL2RenderingContext;\n\n    public positionBuffer: WebGLBuffer | null;\n    public normalBuffer: WebGLBuffer | null;\n    public colorBuffer: WebGLBuffer | null;\n    public indexBuffer: WebGLBuffer | null;\n    public texCoordBuffer: WebGLBuffer | null;\n\n    public vertexCount: number;\n    public triangleCount: number;\n\n    public positionCache: number[] | null;\n    public normalCache: number[] | null;\n    public colorCache: number[] | null;\n    public indexCache: number[] | null;\n    public texCoordCache: number[] | null;\n\n    public material: Material3;\n\n    /**\n     * Flag that determines whether to use vertex colors.\n     */\n    public hasVertexColors: boolean;\n\n    constructor()\n    {\n        super();\n\n        this.gl  = GfxApp.getInstance().renderer.gl;\n\n        this.positionBuffer = this.gl.createBuffer();\n        this.normalBuffer = this.gl.createBuffer();\n        this.colorBuffer = this.gl.createBuffer();\n        this.indexBuffer = this.gl.createBuffer();\n        this.texCoordBuffer = this.gl.createBuffer();\n\n        this.vertexCount = 0;\n        this.triangleCount = 0;\n\n        this.positionCache = null;\n        this.normalCache = null;\n        this.colorCache = null;\n        this.indexCache = null;\n        this.texCoordCache = null;\n\n        this.material = new GouraudMaterial();\n\n        this.hasVertexColors = false;\n    }\n\n    draw(parent: Node3, camera: Camera, lightManager: LightManager): void\n    {\n        if(!this.visible)\n            return;\n\n        this.material.draw(this, camera, lightManager);\n\n        this.children.forEach((elem: Node3) => {\n            elem.draw(this, camera, lightManager);\n        });\n    }\n\n    setVertices(vertices: Vector3[] | number[] | Float32Array, dynamicDraw = false): void\n    {\n        this.positionCache = null;\n\n        if(vertices.length > 0)\n        {\n            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.positionBuffer);\n\n            if(vertices instanceof Float32Array)\n            {\n                if(dynamicDraw)\n                    this.gl.bufferData(this.gl.ARRAY_BUFFER, vertices, this.gl.DYNAMIC_DRAW);\n                else\n                    this.gl.bufferData(this.gl.ARRAY_BUFFER, vertices, this.gl.STATIC_DRAW);\n\n                this.vertexCount = vertices.length / 3;\n                const vArray = Array.from(vertices);\n                this.boundingBox.computeBounds(vArray);\n                this.boundingSphere.computeBounds(vArray, this.boundingBox);\n            }\n            else if(typeof vertices[0] === 'number')\n            {\n                if(dynamicDraw)\n                    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(vertices as number[]), this.gl.DYNAMIC_DRAW);\n                else\n                    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(vertices as number[]), this.gl.STATIC_DRAW);\n                \n                this.vertexCount = vertices.length / 3;\n                this.boundingBox.computeBounds(vertices);\n                this.boundingSphere.computeBounds(vertices, this.boundingBox);\n            }\n            else\n            {\n                const vArray: number[] = [];\n                (vertices as Vector3[]).forEach((elem: Vector3) =>\n                {\n                    vArray.push(elem.x, elem.y, elem.z);\n                });\n\n                if(dynamicDraw)\n                    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(vArray), this.gl.DYNAMIC_DRAW);\n                else\n                    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(vArray), this.gl.STATIC_DRAW);\n\n                this.vertexCount = vertices.length;\n                this.boundingBox.computeBounds(vArray);\n                this.boundingSphere.computeBounds(vArray, this.boundingBox);\n            }      \n        }\n    }\n\n    setNormals(normals: Vector3[] | number[] | Float32Array, dynamicDraw = false): void\n    {\n        this.normalCache = null;\n\n        if(normals.length > 0)\n        {\n            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.normalBuffer);\n\n            if(normals instanceof Float32Array)\n            {\n                if(dynamicDraw)\n                    this.gl.bufferData(this.gl.ARRAY_BUFFER, normals, this.gl.DYNAMIC_DRAW);\n                else\n                    this.gl.bufferData(this.gl.ARRAY_BUFFER, normals, this.gl.STATIC_DRAW);\n\n            }\n            else if(typeof normals[0] === 'number')\n            {\n                if(dynamicDraw)\n                    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(normals as number[]), this.gl.DYNAMIC_DRAW);\n                else\n                    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(normals as number[]), this.gl.STATIC_DRAW);\n            }\n            else\n            {\n                const nArray: number[] = [];\n                (normals as Vector3[]).forEach((elem: Vector3) =>\n                {\n                    nArray.push(elem.x, elem.y, elem.z);\n                });\n                \n                if(dynamicDraw)\n                    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(nArray), this.gl.DYNAMIC_DRAW);\n                else\n                    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(nArray), this.gl.STATIC_DRAW);\n            }\n        }\n    }\n\n    setColors(colors: Color[] | number[] | Float32Array, dynamicDraw = false): void\n    {\n        this.colorCache = null;\n\n        if(colors.length > 0)\n        {\n            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.colorBuffer);\n\n            if(colors instanceof Float32Array)\n            {\n                if(dynamicDraw)\n                    this.gl.bufferData(this.gl.ARRAY_BUFFER, colors, this.gl.DYNAMIC_DRAW);\n                else\n                    this.gl.bufferData(this.gl.ARRAY_BUFFER, colors, this.gl.STATIC_DRAW);\n\n            }\n            else if(typeof colors[0] === 'number')\n            {\n                if(dynamicDraw)\n                    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(colors as number[]), this.gl.DYNAMIC_DRAW);\n                else\n                    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(colors as number[]), this.gl.STATIC_DRAW);\n            }\n            else\n            {\n                const cArray: number[] = [];\n                (colors as Color[]).forEach((elem: Color) =>\n                {\n                    cArray.push(elem.r, elem.g, elem.b, elem.a);\n                });\n                \n                if(dynamicDraw)\n                    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(cArray), this.gl.DYNAMIC_DRAW);\n                else\n                    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(cArray), this.gl.STATIC_DRAW);\n            }\n\n            this.hasVertexColors = true;\n        }\n        else\n        {\n            this.hasVertexColors = false;\n        }\n    }\n\n    setTextureCoordinates(texCoords: Vector2[] | number[] | Float32Array, dynamicDraw = false): void\n    {\n        this.texCoordCache = null;\n\n        if(texCoords.length > 0)\n        {\n            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.texCoordBuffer);\n\n            if(texCoords instanceof Float32Array)\n            {\n                if(dynamicDraw)\n                    this.gl.bufferData(this.gl.ARRAY_BUFFER, texCoords, this.gl.DYNAMIC_DRAW);\n                else\n                    this.gl.bufferData(this.gl.ARRAY_BUFFER, texCoords, this.gl.STATIC_DRAW);\n\n            }\n            else if(typeof texCoords[0] === 'number')\n            {\n                if(dynamicDraw)\n                    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(texCoords as number[]), this.gl.DYNAMIC_DRAW);\n                else\n                    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(texCoords as number[]), this.gl.STATIC_DRAW);\n            }\n            else\n            {\n                const tArray: number[] = [];\n                (texCoords as Vector2[]).forEach((elem: Vector2) =>\n                {\n                    tArray.push(elem.x, elem.y);\n                });\n                \n                if(dynamicDraw)\n                    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(tArray), this.gl.DYNAMIC_DRAW);\n                else\n                    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(tArray), this.gl.STATIC_DRAW);\n            }\n        }\n    }\n\n    setIndices(indices: Vector3[] | number[] | Uint16Array, dynamicDraw = false): void\n    {\n        this.indexCache = null;\n\n        if(indices.length > 0)\n        {\n            this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n\n            if(indices instanceof Uint16Array)\n            {\n                this.triangleCount = indices.length / 3;\n\n                if(dynamicDraw)\n                    this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, indices, this.gl.DYNAMIC_DRAW);\n                else\n                    this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, indices, this.gl.STATIC_DRAW);\n            }\n            else if(typeof indices[0] === 'number')\n            {\n                this.triangleCount = indices.length / 3;\n\n                if(dynamicDraw)\n                    this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices as number[]), this.gl.DYNAMIC_DRAW);\n                else\n                    this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices as number[]), this.gl.STATIC_DRAW);\n            }\n            else\n            {\n                this.triangleCount = indices.length;\n                const iArray: number[] = [];\n                (indices as Vector3[]).forEach((elem: Vector3) =>\n                {\n                    iArray.push(elem.x, elem.y, elem.z);\n                });\n                \n                if(dynamicDraw)\n                    this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(iArray), this.gl.DYNAMIC_DRAW);\n                else\n                    this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(iArray), this.gl.STATIC_DRAW);\n            }\n        }\n    }\n\n    setArrayBuffer(values: Vector3[] | number[], buffer: WebGLBuffer | null, dynamicDraw = false): void\n    {\n        if(values.length > 0)\n        {\n            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, buffer);\n\n            if(typeof values[0] === 'number')\n            {\n                if(dynamicDraw)\n                    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(values as number[]), this.gl.DYNAMIC_DRAW);\n                else\n                    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(values as number[]), this.gl.STATIC_DRAW);\n            }\n            else\n            {\n                const nArray: number[] = [];\n                (values as Vector3[]).forEach((elem: Vector3) =>\n                {\n                    nArray.push(elem.x, elem.y, elem.z);\n                });\n                \n                if(dynamicDraw)\n                    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(nArray), this.gl.DYNAMIC_DRAW);\n                else\n                    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(nArray), this.gl.STATIC_DRAW);\n            }\n        }\n    }\n\n    getVertices(): number[]\n    {\n        if(!this.positionCache)\n        {\n            const vertexArray = new Float32Array(this.vertexCount * 3);\n            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.positionBuffer);\n            this.gl.getBufferSubData(this.gl.ARRAY_BUFFER, 0, vertexArray);\n            this.positionCache = [... vertexArray];\n        }\n\n        return this.positionCache;\n    }\n\n    getNormals(): number[]\n    {\n        if(!this.normalCache)\n        {\n            const normalArray = new Float32Array(this.vertexCount * 3);\n            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.normalBuffer);\n            this.gl.getBufferSubData(this.gl.ARRAY_BUFFER, 0, normalArray);\n            this.normalCache = [... normalArray];\n        }\n\n        return this.normalCache;\n    }\n\n    getColors(): number[]\n    {\n        if(!this.colorCache)\n        {\n            const colorArray = new Float32Array(this.vertexCount * 4);\n            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.colorBuffer);\n            this.gl.getBufferSubData(this.gl.ARRAY_BUFFER, 0, colorArray);\n            this.colorCache = [... colorArray];\n        }\n\n        return this.colorCache;\n    }\n\n    getTextureCoordinates(): number[]\n    {\n        if(!this.texCoordCache)\n        {\n            const texCoordArray = new Float32Array(this.vertexCount * 2);\n            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.texCoordBuffer);\n            this.gl.getBufferSubData(this.gl.ARRAY_BUFFER, 0, texCoordArray);\n            this.texCoordCache = [... texCoordArray];\n        }\n\n        return this.texCoordCache;\n    }\n\n    getIndices(): number[]\n    {\n        if(!this.indexCache)\n        {\n            const indexArray = new Uint16Array(this.triangleCount * 3);\n            this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n            this.gl.getBufferSubData(this.gl.ELEMENT_ARRAY_BUFFER, 0, indexArray);\n            this.indexCache = [... indexArray];\n        }\n\n        return this.indexCache;\n    }\n\n    getArrayBuffer(buffer: WebGLBuffer | null): number[]\n    {\n        const valueArray = new Float32Array(this.vertexCount * 3);\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, buffer);\n        this.gl.getBufferSubData(this.gl.ARRAY_BUFFER, 0, valueArray);\n        return [... valueArray];\n    }\n\n    public createDefaultVertexColors(): void\n    {\n        const colors: number[] = [];\n\n        for(let i=0; i < this.vertexCount; i++)\n            colors.push(1, 1, 1, 1);\n\n        this.setColors(colors);\n    }\n\n    public computeBounds(vertices: Vector3[] | number[] | null): void\n    {\n        if(!vertices)\n        {\n            vertices = this.getVertices();\n        } \n        \n        if(vertices.length == 0)\n            return;\n\n        this.boundingBox.computeBounds(vertices);\n        this.boundingSphere.computeBounds(vertices, this.boundingBox);\n        \n        this.localBoundsDirty = true;\n        this.worldBoundsDirty = true;\n    }\n\n    public mergeSharedVertices(): void\n    {\n        const vArray = this.getVertices();\n        const nArray = this.getNormals();\n        const cArray = this.getColors();\n        const uvArray = this.getTextureCoordinates();\n\n        const vertices: Vector3[] = [];\n        const normals: Vector3[] = [];\n        const colors: Color[] = [];\n        const uvs: Vector2[] = [];\n        const indices = this.getIndices();\n\n        // Copy the vertices, normals, and colors into Vector3 arrays for convenience\n        for(let i=0; i < vArray.length; i+=3)\n        {\n            vertices.push(new Vector3(vArray[i], vArray[i+1], vArray[i+2]));\n            normals.push(new Vector3(nArray[i], nArray[i+1], nArray[i+2]));\n            colors.push(new Color(cArray[i], cArray[i+1], cArray[i+2]));\n        }\n\n        // Copy the uvs into a Vector2 arrays for convenience\n        for(let i=0; i < uvArray.length; i+=2)\n        {\n            uvs.push(new Vector2(uvArray[i], uvArray[i+1]));\n        }\n\n        const newVertices: Vector3[] = [];\n        const newNormals: Vector3[] = [];\n        const newColors: Color[] = [];\n        const newUVs: Vector2[] = [];\n        const newIndices: number[] = indices.slice();\n        const counts: number[] = [];\n\n        for(let i=0; i < vertices.length; i++)\n        {\n            let duplicate = false;\n            for(let j = 0; j < newVertices.length; j++)\n            {\n                if(vertices[i].equals(newVertices[j]))\n                {\n                    for(let k = 0; k < indices.length; k++)\n                    {\n                        if(indices[k] == i)\n                            newIndices[k] = j;\n                    }\n\n                    newNormals[j].add(normals[i]);\n                    newColors[j].add(colors[i]);\n                    newUVs[j].add(uvs[i]);\n                    counts[j]++;\n                    duplicate = true;\n                }   \n            }\n\n            if(!duplicate)\n            {\n                newVertices.push(vertices[i]);\n                newNormals.push(normals[i]);\n                newColors.push(colors[i]);\n                newUVs.push(uvs[i]);\n                counts.push(1);\n\n                for(let k = 0; k < indices.length; k++)\n                {\n                    if(indices[k] == i)\n                        newIndices[k] = newVertices.length-1;\n                }\n            }\n        }\n\n        for(let i=0; i < newVertices.length; i++)\n        {\n            newNormals[i].multiplyScalar(1 / counts[i]);\n            newColors[i].multiplyScalar(1 / counts[i]);\n            newUVs[i].multiplyScalar(1 / counts[i]);\n        }\n\n        this.setVertices(newVertices);\n        this.setNormals(newNormals);\n        this.setColors(newColors);\n        this.setTextureCoordinates(newUVs);\n        this.setIndices(newIndices);\n    }\n\n    public createInstance(copyTransform = true): Mesh3\n    {\n        const instance = new Mesh3();\n        instance.positionBuffer = this.positionBuffer;\n        instance.normalBuffer = this.normalBuffer;\n        instance.colorBuffer = this.colorBuffer;\n        instance.indexBuffer = this.indexBuffer;\n        instance.texCoordBuffer = this.texCoordBuffer;\n        instance.vertexCount = this.vertexCount;\n        instance.triangleCount = this.triangleCount;\n        instance.material = this.material;\n        instance.visible = this.visible;\n        instance.boundingBox = this.boundingBox;\n        instance.boundingSphere = this.boundingSphere;\n        instance.localBoundsDirty = true;\n        instance.worldBoundsDirty = true;\n\n        if(copyTransform)\n        {\n            instance._position.copy(this._position);\n            instance._rotation.copy(this._rotation);\n            instance._scale.copy(this._scale);\n            instance.localToParentMatrix.copy(this.localToParentMatrix);\n            instance.localToWorldMatrix.copy(this.localToWorldMatrix);\n            instance.localMatrixDirty = this.localMatrixDirty;\n            instance.worldMatrixDirty = true;\n        }\n\n        return instance;\n    }\n}", "// @ts-ignore\nimport unlitVertexShader from '../shaders/unlit.vert'\n// @ts-ignore\nimport unlitFragmentShader from '../shaders/unlit.frag'\n\nimport { Material3 } from './Material3';\nimport { ShaderProgram } from './ShaderProgram';\nimport { Mesh3 } from '../geometry/3d/Mesh3';\nimport { Camera } from '../core/Camera';\nimport { Node3 } from '../core/Node3';\nimport { LightManager } from '../lights/LightManager';\nimport { Texture } from './Texture';\nimport { Color } from '../math/Color' \nimport { Matrix4 } from '../math/Matrix4'\n\nexport class UnlitMaterial extends Material3\n{\n    public texture: Texture | null;\n    public color: Color;\n\n    public static shader = new ShaderProgram(unlitVertexShader, unlitFragmentShader);\n    \n    private colorUniform: WebGLUniformLocation | null;\n    private textureUniform: WebGLUniformLocation | null;\n    private useTextureUniform: WebGLUniformLocation | null;\n\n    private modelViewUniform: WebGLUniformLocation | null;\n    private projectionUniform: WebGLUniformLocation | null;\n\n    private positionAttribute: number;\n    private colorAttribute: number;\n    private texCoordAttribute: number;\n\n    constructor()\n    {\n        super();\n\n        this.texture = null;\n        this.color = new Color(1, 1, 1);\n\n        UnlitMaterial.shader.initialize(this.gl);\n\n        this.colorUniform = UnlitMaterial.shader.getUniform(this.gl, 'materialColor');\n        this.textureUniform = UnlitMaterial.shader.getUniform(this.gl, 'textureImage');\n        this.useTextureUniform = UnlitMaterial.shader.getUniform(this.gl, 'useTexture');\n\n        this.modelViewUniform = UnlitMaterial.shader.getUniform(this.gl, 'modelViewMatrix');\n        this.projectionUniform = UnlitMaterial.shader.getUniform(this.gl, 'projectionMatrix');\n\n        this.positionAttribute = UnlitMaterial.shader.getAttribute(this.gl, 'position');\n        this.colorAttribute = UnlitMaterial.shader.getAttribute(this.gl, 'color');\n        this.texCoordAttribute = UnlitMaterial.shader.getAttribute(this.gl, 'texCoord');   \n    }\n\n    draw(mesh: Mesh3, camera: Camera, lightManager: LightManager): void\n    {\n        if(!this.visible || mesh.triangleCount == 0)\n            return;\n\n        this.initialize();\n\n        // Switch to this shader\n        this.gl.useProgram(UnlitMaterial.shader.getProgram());\n\n        // Set the camera uniforms\n        this.gl.uniformMatrix4fv(this.modelViewUniform, false, Matrix4.multiply(camera.viewMatrix, mesh.localToWorldMatrix).mat);\n        this.gl.uniformMatrix4fv(this.projectionUniform, false, camera.projectionMatrix.mat);\n\n        // Set the material property uniforms\n        this.gl.uniform4f(this.colorUniform, this.color.r, this.color.g, this.color.b, this.color.a);\n\n        // Set the vertex colors\n        if(mesh.hasVertexColors)\n        {\n            this.gl.enableVertexAttribArray(this.colorAttribute);\n            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, mesh.colorBuffer);\n            this.gl.vertexAttribPointer(this.colorAttribute, 4, this.gl.FLOAT, false, 0, 0);\n        }\n        else\n        {\n            this.gl.disableVertexAttribArray(this.colorAttribute);\n            this.gl.vertexAttrib4f(this.colorAttribute, 1, 1, 1, 1);\n        }\n\n        // Set the vertex positions\n        this.gl.enableVertexAttribArray(this.positionAttribute);\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, mesh.positionBuffer);\n        this.gl.vertexAttribPointer(this.positionAttribute, 3, this.gl.FLOAT, false, 0, 0);\n\n        if(this.texture)\n        {\n            // Activate the texture in the shader\n            this.gl.uniform1i(this.useTextureUniform, 1);\n\n            // Set the texture\n            this.gl.activeTexture(this.gl.TEXTURE0 + this.texture.id)\n            this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture.texture);\n            this.gl.uniform1i(this.textureUniform, this.texture.id);\n\n            // Set the texture coordinates\n            this.gl.enableVertexAttribArray(this.texCoordAttribute);\n            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, mesh.texCoordBuffer);\n            this.gl.vertexAttribPointer(this.texCoordAttribute, 2, this.gl.FLOAT, false, 0, 0);\n        }\n        else\n        {\n            // Disable the texture in the shader\n            this.gl.uniform1i(this.useTextureUniform, 0);\n            this.gl.disableVertexAttribArray(this.texCoordAttribute);\n        }\n\n        // Draw the triangles\n        this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, mesh.indexBuffer);\n        this.gl.drawElements(this.gl.TRIANGLES, mesh.triangleCount*3, this.gl.UNSIGNED_SHORT, 0);\n    }\n\n    setColor(color: Color): void\n    {\n        this.color.copy(color);\n    }\n\n    getColor(): Color\n    {\n        return this.color;\n    }\n}", "import { Node3 } from \"../../core/Node3\";\nimport { Vector3 } from \"../../math/Vector3\";\nimport { Color } from \"../../math/Color\";\nimport { Camera } from \"../../core/Camera\";\nimport { LightManager } from \"../../lights/LightManager\";\nimport { GfxApp } from \"../../core/GfxApp\";\nimport { BoundingBox3 } from \"../../math/BoundingBox3\";\nimport { UnlitMaterial } from '../../materials/UnlitMaterial';\nimport { Matrix4 } from \"../../math/Matrix4\";\n\nexport enum LineMode3\n{\n    LINES,\n    LINE_STRIP,\n    LINE_LOOP\n}\n\n/**\n * The base class for 3D lines.  This class extends Node3 so it can be added directly\n * to the GopherGfx 3D scene graph.  The class can draw line segments, line strips,\n * and line loops.  The vertices are interpreted differently depending upon the \n * LineMode3 that is set.  WebGL only supports lines that are exactly 1 pixel\n * thick.  These can look a bit strange in 3D scenes because the thickness of the\n * line does not vary with the depth from the camera.  So, the lines that this \n * class can draw are most useful as quick debugging aids.  To draw a more substantial \n * \"line\" that actually behaves like it has some thickness in your 3D scene, you \n * need to construct your line using triangles.  \n */\nexport class Line3 extends Node3\n{\n    protected readonly gl: WebGL2RenderingContext;\n\n    public color: Color;\n    public vertexCount: number;\n    public lineMode: number;\n\n    public readonly positionBuffer: WebGLBuffer | null;\n    public readonly colorBuffer: WebGLBuffer | null;\n\n    private colorUniform: WebGLUniformLocation | null;\n    private useTextureUniform: WebGLUniformLocation | null;\n    private textureUniform: WebGLUniformLocation | null;\n    private modelViewUniform: WebGLUniformLocation | null;\n    private projectionUniform: WebGLUniformLocation | null;\n    private positionAttribute: number;\n    private colorAttribute: number;\n    private texCoordAttribute: number;\n\n    /**\n     * Flag that determines whether to use vertex colors.\n     */\n    public hasVertexColors: boolean;\n    \n    constructor(lineMode = LineMode3.LINE_STRIP)\n    {\n        super();\n\n        this.color = new Color(1, 1, 1);\n        this.vertexCount = 0;\n        this.lineMode = lineMode;\n\n        this.gl  = GfxApp.getInstance().renderer.gl;\n        this.positionBuffer = this.gl.createBuffer();\n        this.colorBuffer = this.gl.createBuffer();\n\n        UnlitMaterial.shader.initialize(this.gl);\n        this.colorUniform = UnlitMaterial.shader.getUniform(this.gl, 'materialColor');\n        this.modelViewUniform = UnlitMaterial.shader.getUniform(this.gl, 'modelViewMatrix');\n        this.projectionUniform = UnlitMaterial.shader.getUniform(this.gl, 'projectionMatrix');\n        this.useTextureUniform = UnlitMaterial.shader.getUniform(this.gl, 'useTexture');\n        this.textureUniform = UnlitMaterial.shader.getUniform(this.gl, 'textureImage');\n        this.positionAttribute = UnlitMaterial.shader.getAttribute(this.gl, 'position');\n        this.colorAttribute = UnlitMaterial.shader.getAttribute(this.gl, 'color');\n        this.texCoordAttribute = UnlitMaterial.shader.getAttribute(this.gl, 'texCoord');   \n\n        this.hasVertexColors = false;\n    }\n\n    createFromBox(box: BoundingBox3)\n    {      \n         const vertices: number[] = [];\n\n         // Bottom rectangle\n         vertices.push(box.max.x, box.min.y, box.max.z);\n         vertices.push(box.max.x, box.min.y, box.min.z);\n         vertices.push(box.min.x, box.min.y, box.min.z);\n         vertices.push(box.min.x, box.min.y, box.max.z);\n         vertices.push(box.max.x, box.min.y, box.max.z);\n         vertices.push(box.min.x, box.min.y, box.max.z);\n         vertices.push(box.max.x, box.min.y, box.min.z);\n         vertices.push(box.min.x, box.min.y, box.min.z);\n\n         // Top rectangle\n         vertices.push(box.max.x, box.max.y, box.max.z);\n         vertices.push(box.max.x, box.max.y, box.min.z);\n         vertices.push(box.min.x, box.max.y, box.min.z);\n         vertices.push(box.min.x, box.max.y, box.max.z);\n         vertices.push(box.max.x, box.max.y, box.max.z);\n         vertices.push(box.min.x, box.max.y, box.max.z);\n         vertices.push(box.max.x, box.max.y, box.min.z);\n         vertices.push(box.min.x, box.max.y, box.min.z);\n         \n         // Sides\n         vertices.push(box.max.x, box.min.y, box.max.z);\n         vertices.push(box.max.x, box.max.y, box.max.z);\n         vertices.push(box.max.x, box.min.y, box.min.z);\n         vertices.push(box.max.x, box.max.y, box.min.z);\n         vertices.push(box.min.x, box.min.y, box.min.z);\n         vertices.push(box.min.x, box.max.y, box.min.z);\n         vertices.push(box.min.x, box.min.y, box.max.z);\n         vertices.push(box.min.x, box.max.y, box.max.z);\n\n         this.setVertices(vertices);\n\n         this.lineMode = LineMode3.LINES;\n    }\n\n    draw(parent: Node3, camera: Camera, lightManager: LightManager): void\n    {\n        if(!this.visible)\n            return;\n\n        // Switch to this shader\n        this.gl.useProgram(UnlitMaterial.shader.getProgram());\n\n        // Disable the texture in the shader\n        this.gl.uniform1i(this.useTextureUniform, 0);\n        this.gl.disableVertexAttribArray(this.texCoordAttribute);\n\n        // Set the camera uniforms\n        this.gl.uniformMatrix4fv(this.modelViewUniform, false, Matrix4.multiply(camera.viewMatrix, this.localToWorldMatrix).mat);\n        this.gl.uniformMatrix4fv(this.projectionUniform, false, camera.projectionMatrix.mat);\n\n        // Set the material property uniforms\n        this.gl.uniform4f(this.colorUniform, this.color.r, this.color.g, this.color.b, this.color.a);\n\n        // Set the vertex colors\n        if(this.hasVertexColors)\n        {\n            this.gl.enableVertexAttribArray(this.colorAttribute);\n            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.colorBuffer);\n            this.gl.vertexAttribPointer(this.colorAttribute, 4, this.gl.FLOAT, false, 0, 0);\n        }\n        else\n        {\n            this.gl.disableVertexAttribArray(this.colorAttribute);\n            this.gl.vertexAttrib4f(this.colorAttribute, 1, 1, 1, 1);\n        } \n\n        // Set the vertex positions\n        this.gl.enableVertexAttribArray(this.positionAttribute);\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.positionBuffer);\n        this.gl.vertexAttribPointer(this.positionAttribute, 3, this.gl.FLOAT, false, 0, 0);\n\n        // Draw the lines\n        this.gl.drawArrays(this.glLineMode(), 0, this.vertexCount);\n\n        this.children.forEach((elem: Node3) => {\n            elem.draw(this, camera, lightManager);\n        });\n    }\n\n    setVertices(vertices: Vector3[] | number[], usage = this.gl.STATIC_DRAW): void\n    {\n        if(vertices.length > 0)\n        {\n            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.positionBuffer);\n\n            let vArray: number[];\n            if(typeof vertices[0] === 'number')\n            {\n                vArray = vertices as number[];\n                \n            }\n            else\n            {\n                vArray = [];\n                (vertices as Vector3[]).forEach((elem: Vector3) =>\n                {\n                    vArray.push(elem.x, elem.y, elem.z);\n                });\n            }\n            \n            this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(vArray), usage);\n            this.vertexCount = vArray.length / 3;\n\n            this.boundingBox.computeBounds(vArray);\n            this.boundingSphere.computeBounds(vArray, this.boundingBox);\n        }\n    }\n\n    setColors(colors: Color[] | number[], usage = this.gl.STATIC_DRAW): void\n    {\n        if(colors.length > 0)\n        {\n            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.colorBuffer);\n\n            if(typeof colors[0] === 'number')\n            {\n                this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(colors as number[]), usage);\n            }\n            else\n            {\n                const cArray: number[] = [];\n                (colors as Color[]).forEach((elem: Color) =>\n                {\n                    cArray.push(elem.r, elem.g, elem.b, elem.a);\n                });\n                \n                this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(cArray), usage);\n            }\n\n            this.hasVertexColors = true;\n        }\n        else\n        {\n            this.hasVertexColors = false;\n        }\n    }\n\n    getVertices(): number[]\n    {\n        const vertexArray = new Float32Array(this.vertexCount * 3);\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.positionBuffer);\n        this.gl.getBufferSubData(this.gl.ARRAY_BUFFER, 0, vertexArray);\n        return [... vertexArray];\n    }\n\n    getColors(): number[]\n    {\n        const colorArray = new Float32Array(this.vertexCount * 4);\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.colorBuffer);\n        this.gl.getBufferSubData(this.gl.ARRAY_BUFFER, 0, colorArray);\n        return [... colorArray];\n    }\n\n    public createDefaultVertexColors(): void\n    {\n        const colors: number[] = [];\n\n        for(let i=0; i < this.vertexCount; i++)\n            colors.push(1, 1, 1, 1);\n\n        this.setColors(colors);\n    }\n\n    public glLineMode(): number\n    {\n        if(this.lineMode == LineMode3.LINES)\n            return this.gl.LINES;\n        else if(this.lineMode == LineMode3.LINE_STRIP)\n            return this.gl.LINE_STRIP;\n        else\n            return this.gl.LINE_LOOP;  \n    }\n}", "import { Mesh3 } from './3d/Mesh3'\nimport { Line3, LineMode3 } from './3d/Line3'\nimport { Vector3 } from '../math/Vector3';\nimport { Quaternion } from '../math/Quaternion';\n\n/**\n * This is a factory class for creating a variety of common geometries that can be drawn in a 3D scene.\n * Most of these geometries are Mesh3s, meaning they are constructed from triangles, but there are also\n * a few Line3 objects.  If you have a really complex 3D model, like an animated character, that geometry\n * will probably be stored in a 3D model file that can be loaded with the MeshLoader class.  In contrast\n * this factory is for creating simple geometries (cubes, spheres, cylinders, cones) that can be easily \n * described by a mathematical function.\n */\nexport class Geometry3Factory\n{\n    public static createBox(width = 1, height = 1, depth = 1): Mesh3\n    {\n        const vertices: number[] = [];\n\n        // Front face\n        vertices.push(-width/2, -height/2, depth/2);\n        vertices.push(width/2, -height/2, depth/2);\n        vertices.push(width/2, height/2, depth/2);\n        vertices.push(-width/2, height/2, depth/2);\n\n        // Back face\n        vertices.push(-width/2, -height/2, -depth/2);\n        vertices.push(width/2, -height/2, -depth/2);\n        vertices.push(width/2, height/2, -depth/2);\n        vertices.push(-width/2, height/2, -depth/2);\n\n        // Left face\n        vertices.push(-width/2, -height/2, -depth/2);\n        vertices.push(-width/2, -height/2, depth/2);\n        vertices.push(-width/2, height/2, depth/2);\n        vertices.push(-width/2, height/2, -depth/2);\n\n        // Left face\n        vertices.push(width/2, -height/2, -depth/2);\n        vertices.push(width/2, -height/2, depth/2);\n        vertices.push(width/2, height/2, depth/2);\n        vertices.push(width/2, height/2, -depth/2);\n\n        // Top face\n        vertices.push(-width/2, height/2, depth/2);\n        vertices.push(width/2, height/2, depth/2);\n        vertices.push(width/2, height/2, -depth/2);\n        vertices.push(-width/2, height/2, -depth/2);\n\n        // Bottom face\n        vertices.push(-width/2, -height/2, depth/2);\n        vertices.push(width/2, -height/2, depth/2);\n        vertices.push(width/2, -height/2, -depth/2);\n        vertices.push(-width/2, -height/2, -depth/2);\n\n\n        const normals: number[] = [];\n\n        // Front face\n        normals.push(0, 0, 1);\n        normals.push(0, 0, 1);\n        normals.push(0, 0, 1);\n        normals.push(0, 0, 1);\n\n        // Back face\n        normals.push(0, 0, -1);\n        normals.push(0, 0, -1);\n        normals.push(0, 0, -1);\n        normals.push(0, 0, -1);\n\n        // Left face\n        normals.push(-1, 0, 0);\n        normals.push(-1, 0, 0);\n        normals.push(-1, 0, 0);\n        normals.push(-1, 0, 0);\n\n        // Right face\n        normals.push(1, 0, 0);\n        normals.push(1, 0, 0);\n        normals.push(1, 0, 0);\n        normals.push(1, 0, 0);\n\n        // Top face\n        normals.push(0, 1, 0);\n        normals.push(0, 1, 0);\n        normals.push(0, 1, 0);\n        normals.push(0, 1, 0);\n\n        // Bottom face\n        normals.push(0, -1, 0);\n        normals.push(0, -1, 0);\n        normals.push(0, -1, 0);\n        normals.push(0, -1, 0);\n\n\n        const indices: number[] = [];\n\n        // Front face\n        indices.push(0, 1, 2);\n        indices.push(2, 3, 0);\n\n        // Back face\n        indices.push(4, 6, 5);\n        indices.push(6, 4, 7);\n\n        // Left face\n        indices.push(8, 9, 10);\n        indices.push(10, 11, 8);\n\n        // Right face\n        indices.push(12, 14, 13);\n        indices.push(14, 12, 15);\n\n        // Top face\n        indices.push(16, 17, 18);\n        indices.push(18, 19, 16);\n\n        // Bottom face\n        indices.push(20, 22, 21);\n        indices.push(22, 20, 23);\n\n\n        const uvs: number[] = [];\n\n        // Front face\n        uvs.push(0, 1);\n        uvs.push(1, 1);\n        uvs.push(1, 0);\n        uvs.push(0, 0);\n\n        // Back face\n        uvs.push(1, 1);\n        uvs.push(0, 1);\n        uvs.push(0, 0);\n        uvs.push(1, 0);\n\n        // Left face\n        uvs.push(0, 1);\n        uvs.push(1, 1);\n        uvs.push(1, 0);\n        uvs.push(0, 0);\n\n        // Right face\n        uvs.push(1, 1);\n        uvs.push(0, 1);\n        uvs.push(0, 0);\n        uvs.push(1, 0);\n\n        // Top face\n        uvs.push(0, 1);\n        uvs.push(1, 1);\n        uvs.push(1, 0);\n        uvs.push(0, 0);\n\n        // Bottom face\n        uvs.push(1, 1);\n        uvs.push(0, 1);\n        uvs.push(0, 0);\n        uvs.push(1, 0);\n\n\n        const mesh = new Mesh3();\n        mesh.setVertices(vertices);\n        mesh.setNormals(normals);\n        mesh.setIndices(indices);\n        mesh.setTextureCoordinates(uvs);\n        return mesh;\n    }\n\n    public static createBoxLine(startPoint: Vector3, endPoint: Vector3, thickness: number): Mesh3\n    {\n        const mesh = this.createBox();\n\n        const midpoint = Vector3.add(startPoint, endPoint);\n        midpoint.multiplyScalar(0.5);\n        mesh.position.copy(midpoint);\n\n        mesh.rotation.lookAt(midpoint, endPoint, Vector3.UP);\n\n        mesh.scale.set(thickness, thickness, Vector3.distanceBetween(startPoint, endPoint));\n    \n        return mesh;\n    }\n\n    public static createCone(radius = 1, height = 1, numSegments = 8): Mesh3\n    {\n        const vertices: number[] = [];\n\n        const angle = (Math.PI * 2) / numSegments;\n\n        // Top vertex\n        vertices.push(0, height/2, 0);\n\n        // Side vertices\n        for(let i=0; i <= numSegments; i++)\n        {\n            vertices.push(Math.cos(angle*i) * radius, -height/2, Math.sin(angle*i) * radius);\n        }\n\n        // Bottom center vertex\n        vertices.push(0, -height/2, 0);\n\n        // Bottom vertices\n        for(let i=0; i <= numSegments; i++)\n        {\n            vertices.push(Math.cos(angle*i) * radius, -height/2, Math.sin(angle*i) * radius);\n        }\n\n\n        const normals: number[] = [];\n\n        // // Top vertex\n        normals.push(0, 1, 0);\n\n        // // Side normals\n        for(let i=0; i <= numSegments; i++)\n        {\n            normals.push(Math.cos(angle*i), 0, Math.sin(angle*i));\n        }\n\n        // Bottom center vertex\n        normals.push(0, -1, 0);\n\n        // Bottom normals\n        for(let i=0; i <= numSegments; i++)\n        {\n            normals.push(0, -1, 0);\n        }\n\n\n        const indices: number[] = [];\n\n        // Side triangles\n        for(let i=0; i < numSegments; i++)\n        {\n            indices.push(0, i+2, i+1);\n        }\n\n        const startIndex = numSegments+2;\n\n        // Bottom triangles\n        for(let i=0; i < numSegments; i++)\n        {\n            indices.push(startIndex, startIndex+i+1, startIndex+i+2);\n        }\n\n\n        const uvs: number[] = [];\n\n        // Top vertex\n        uvs.push(0.5, 0);\n\n        // Side vertex\n        for(let i=0; i <= numSegments; i++)\n        {\n            uvs.push(i / numSegments, 1);\n        }\n\n        // Bottom center vertex\n        uvs.push(0.5, 0.5);\n\n        // Bottom vertices\n        for(let i=0; i <= numSegments; i++)\n        {\n            uvs.push((Math.cos(angle*i) + 1) / 2, (Math.sin(angle*i) - 1) / -2);\n        }\n\n\n        const mesh = new Mesh3();\n        mesh.setVertices(vertices);\n        mesh.setNormals(normals);\n        mesh.setIndices(indices);\n        mesh.setTextureCoordinates(uvs);\n        return mesh;\n    }\n\n    public static createCylinder(numSegments = 20, radius = 1, height = 1): Mesh3\n    {\n        const vertices: number[] = [];\n        const normals: number[] = [];\n        const indices: number[] = [];\n        const uvs: number[] = [];\n\n        // Initialize variables for the cylinder circumference\n        const angleIncrement = (Math.PI * 2) / numSegments;\n        const numVerticesX = numSegments + 1;\n\n        // Create the cylinder barrel vertices\n        for(let i=0; i < numVerticesX; i++)\n        {\n            const angle = i * angleIncrement;\n\n            vertices.push(Math.cos(angle) * radius, height/2, Math.sin(angle) * radius);\n            vertices.push(Math.cos(angle) * radius, -height/2, Math.sin(angle) * radius);\n\n            normals.push(Math.cos(angle), 0, Math.sin(angle));\n            normals.push(Math.cos(angle), 0, Math.sin(angle));\n\n            uvs.push(1 - i / numSegments, 0);\n            uvs.push(1 - i / numSegments, 1);\n        }\n\n        // Create the cylinder barrel triangles\n        for(let i=0; i < numSegments; i++)\n        {\n            const angle = i * angleIncrement;\n\n            indices.push(i*2, i*2+2, i*2+1);\n            indices.push(i*2+1, i*2+2, i*2+3);\n        }\n\n        // Create a single vertex and normal at center for the top disc\n        const topCenterIndex = vertices.length / 3;\n        vertices.push(0, height/2, 0);\n        normals.push(0, 1, 0);\n        uvs.push(0.5, 0);\n        \n        // Create the top disc vertices\n        for(let i=0; i < numVerticesX; i++)\n        {\n            const angle = i * angleIncrement;\n\n            vertices.push(Math.cos(angle) * radius, height/2, Math.sin(angle) * radius);\n            normals.push(0, 1, 0);\n            uvs.push(1 - i / numSegments, 0);\n        }\n\n        // Create the top disc triangles\n        for(let i=0; i < numSegments; i++)\n        {\n            // Create a triangle from the center to the two added vertices\n            indices.push(topCenterIndex, topCenterIndex+i+2, topCenterIndex+i+1);\n        }\n\n        // Create a single vertex and normal at center for the bottom disc\n        const bottomCenterIndex = vertices.length / 3;\n        vertices.push(0, -height/2, 0);\n        normals.push(0, -1, 0);\n        uvs.push(0.5, 1);\n        \n        // Create the bottom disc vertices\n        for(let i=0; i < numVerticesX; i++)\n        {\n            const angle = i * angleIncrement;\n\n            vertices.push(Math.cos(angle) * radius, -height/2, Math.sin(angle) * radius);\n            normals.push(0, -1, 0);\n            uvs.push(1 - i / numSegments, 1);\n        }\n\n        // Create the bottom disc triangles\n        for(let i=0; i < numSegments; i++)\n        {\n            // Create a triangle from the center to the two added vertices\n            indices.push(bottomCenterIndex, bottomCenterIndex+i+1, bottomCenterIndex+i+2);\n        }\n\n\n        const mesh = new Mesh3();\n        mesh.setVertices(vertices);\n        mesh.setNormals(normals);\n        mesh.setIndices(indices);\n        mesh.setTextureCoordinates(uvs);\n        return mesh;\n    }\n\n    public static createPlane(width = 1, height = 1): Mesh3\n    {\n        const vertices: number[] = [];\n\n        vertices.push(-width/2, -height/2, 0);\n        vertices.push(width/2, -height/2, 0);\n        vertices.push(width/2, height/2, 0);\n        vertices.push(-width/2, height/2,0);\n\n\n        const normals: number[] = [];\n\n        // Back face\n        normals.push(0, 0, -1);\n        normals.push(0, 0, -1);\n        normals.push(0, 0, -1);\n        normals.push(0, 0, -1);\n        \n\n        const indices: number[] = [];\n\n        indices.push(0, 2, 1);\n        indices.push(2, 0, 3);\n\n\n        const uvs: number[] = [];\n\n        uvs.push(1, 1);\n        uvs.push(0, 1);\n        uvs.push(0, 0);\n        uvs.push(1, 0);\n\n\n        const mesh = new Mesh3();\n        mesh.setVertices(vertices);\n        mesh.setNormals(normals);\n        mesh.setIndices(indices);\n        mesh.setTextureCoordinates(uvs);\n        return mesh;\n    }\n\n    public static createSphere(radius = 1, subdivisions=2): Mesh3\n    {\n        // Based on approach from \n        // https://www.danielsieger.com/blog/2021/01/03/generating-platonic-solids.html\n        // https://www.danielsieger.com/blog/2021/03/27/generating-spheres.html\n\n\n        let vertices: Vector3[] = [];\n        let indices: number[] = [];\n        const normals: Vector3[] = [];\n        const texCoords: number[] = [];\n\n        const phi = (1 + Math.sqrt(5)) * 0.5; // golden ratio\n        const a = 1;\n        const b = 1 / phi;\n\n        vertices.push(new Vector3(0, b, -a));\n        vertices.push(new Vector3(b, a, 0));\n        vertices.push(new Vector3(-b, a, 0));\n        vertices.push(new Vector3(0, b, a));\n        vertices.push(new Vector3(0, -b, a));\n        vertices.push(new Vector3(-a, 0, b));\n        vertices.push(new Vector3(0, -b, -a));\n        vertices.push(new Vector3(a, 0, -b));\n        vertices.push(new Vector3(a, 0, b));\n        vertices.push(new Vector3(-a, 0, -b));\n        vertices.push(new Vector3(b, -a, 0));\n        vertices.push(new Vector3(-b, -a, 0));\n\n        // Project to unit sphere\n        for(let i=0; i < vertices.length; i++)\n        {\n            vertices[i].normalize();\n        }\n\n        indices.push(2, 1, 0);\n        indices.push(1, 2, 3);\n        indices.push(5, 4, 3);\n        indices.push(4, 8, 3);\n        indices.push(7, 6, 0);\n        indices.push(6, 9, 0);\n        indices.push(11, 10, 4);\n        indices.push(10, 11, 6);\n        indices.push(9, 5, 2);\n        indices.push(5, 9, 11);\n        indices.push(8, 7, 1);\n        indices.push(7, 8, 10);\n        indices.push(2, 5, 3);\n        indices.push(8, 1, 3);\n        indices.push(9, 2, 0);\n        indices.push(1, 7, 0);\n        indices.push(11, 9, 6);\n        indices.push(7, 10, 6);\n        indices.push(5, 11, 4);\n        indices.push(10, 8, 4);\n\n        for(let div=0; div < subdivisions; div++)\n        {\n            const newIndices: number[] = [];\n            for(let i=0; i < indices.length / 3; i++)\n            {\n                const index = i*3;\n                const centroids = this.createCentroids(vertices, indices[index], indices[index+1], indices[index+2]);\n                vertices.push(...centroids);\n\n                const triangles = this.subdivide(indices[index], indices[index+1], indices[index+2], \n                    vertices.length - 3, vertices.length - 2, vertices.length - 1);\n                    newIndices.push(... triangles);\n            }\n            indices = newIndices;\n        }\n\n        // Scale by the radius\n        for(let i=0; i < vertices.length; i++)\n        {\n            vertices[i].multiplyScalar(radius);\n        }\n\n        [vertices, indices] = this.mergeSphereVertices(vertices, indices);\n        \n        // Compute texture coordinates\n        for(let i=0; i < vertices.length; i++)\n        {\n            normals.push(Vector3.normalize(vertices[i]));\n\n            const v = 1 - (vertices[i].y + radius) / (2 * radius);\n\n            const direction = new Vector3(vertices[i].x, 0, vertices[i].z);\n            direction.normalize();\n\n            let angle = Math.acos(Vector3.FORWARD.dot(direction));\n            if(direction.x > 0)\n                 angle = Math.PI * 2 - angle;\n\n            const u = angle / (Math.PI * 2);\n            texCoords.push(u, v);\n        }\n        \n        const indicesLength = indices.length;\n\n        // Fix the texture seam by duplicating the vertices at the vertical edge of the sphere\n        for(let i=0; i < indicesLength; i+=3)\n        {\n            if(this.isSeamVertex(i, vertices, indices))\n            {\n                if(this.isEndVertex(i+1, vertices, indices) && this.isEndVertex(i+2, vertices, indices))\n                {\n                    vertices.push(Vector3.copy(vertices[indices[i]]));\n                    normals.push(Vector3.normalize(vertices[indices[i]]));\n                    texCoords.push(1, texCoords[indices[i]*2+1]);\n\n                    indices[i] = vertices.length-1;\n                }\n                else if(this.isEndVertex(i+1, vertices, indices))\n                {\n                    vertices.push(Vector3.copy(vertices[indices[i]]));\n                    normals.push(Vector3.normalize(vertices[indices[i]]));\n                    texCoords.push(1, texCoords[indices[i]*2+1]);\n\n                    vertices.push(Vector3.copy(vertices[indices[i+2]]));\n                    normals.push(Vector3.normalize(vertices[indices[i+2]]));\n                    texCoords.push(1, texCoords[indices[i+2]*2+1]);\n\n                    indices[i] = vertices.length-2;\n                    indices[i+2] = vertices.length-1;\n                }\n                else if(this.isEndVertex(i+2, vertices, indices))\n                {\n                    vertices.push(Vector3.copy(vertices[indices[i]]));\n                    normals.push(Vector3.normalize(vertices[indices[i]]));\n                    texCoords.push(1, texCoords[indices[i]*2+1]);\n\n                    vertices.push(Vector3.copy(vertices[indices[i+1]]));\n                    normals.push(Vector3.normalize(vertices[indices[i+1]]));\n                    texCoords.push(1, texCoords[indices[i+1]*2+1]);\n\n                    indices[i] = vertices.length-2;\n                    indices[i+1] = vertices.length-1;\n                }\n            }\n            else if(this.isSeamVertex(i+1, vertices, indices))\n            { \n                if(this.isEndVertex(i, vertices, indices) && this.isEndVertex(i+2, vertices, indices))\n                {\n                    vertices.push(Vector3.copy(vertices[indices[i+1]]));\n                    normals.push(Vector3.normalize(vertices[indices[i+1]]));\n                    texCoords.push(1, texCoords[indices[i+1]*2+1]);\n\n                    indices[i+1] = vertices.length-1;\n                }\n                else if(this.isEndVertex(i, vertices, indices))\n                {\n                    vertices.push(Vector3.copy(vertices[indices[i+1]]));\n                    normals.push(Vector3.normalize(vertices[indices[i+1]]));\n                    texCoords.push(1, texCoords[indices[i+1]*2+1]);\n\n                    vertices.push(Vector3.copy(vertices[indices[i+2]]));\n                    normals.push(Vector3.normalize(vertices[indices[i+2]]));\n                    texCoords.push(1, texCoords[indices[i+2]*2+1]);\n\n                    indices[i+1] = vertices.length-2;\n                    indices[i+2] = vertices.length-1;\n                }\n                else if(this.isEndVertex(i+2, vertices, indices))\n                {\n                    vertices.push(Vector3.copy(vertices[indices[i]]));\n                    normals.push(Vector3.normalize(vertices[indices[i]]));\n                    texCoords.push(1, texCoords[indices[i]*2+1]);\n\n                    vertices.push(Vector3.copy(vertices[indices[i+1]]));\n                    normals.push(Vector3.normalize(vertices[indices[i+1]]));\n                    texCoords.push(1, texCoords[indices[i+1]*2+1]);\n\n                    indices[i] = vertices.length-2;\n                    indices[i+1] = vertices.length-1;\n                }\n            }\n            else if(this.isSeamVertex(i+2, vertices, indices))\n            {\n                if(this.isEndVertex(i, vertices, indices) && this.isEndVertex(i+1, vertices, indices))\n                {\n                    vertices.push(Vector3.copy(vertices[indices[i+2]]));\n                    normals.push(Vector3.normalize(vertices[indices[i+2]]));\n                    texCoords.push(1, texCoords[indices[i+2]*2+1]);\n\n                    indices[i+2] = vertices.length-1;\n                }\n                else if(this.isEndVertex(i, vertices, indices))\n                {\n                    vertices.push(Vector3.copy(vertices[indices[i+1]]));\n                    normals.push(Vector3.normalize(vertices[indices[i+1]]));\n                    texCoords.push(1, texCoords[indices[i+1]*2+1]);\n\n                    vertices.push(Vector3.copy(vertices[indices[i+2]]));\n                    normals.push(Vector3.normalize(vertices[indices[i+2]]));\n                    texCoords.push(1, texCoords[indices[i+2]*2+1]);\n\n                    indices[i+1] = vertices.length-2;\n                    indices[i+2] = vertices.length-1;\n                }\n                else if(this.isEndVertex(i+1, vertices, indices))\n                {\n                    vertices.push(Vector3.copy(vertices[indices[i]]));\n                    normals.push(Vector3.normalize(vertices[indices[i]]));\n                    texCoords.push(1, texCoords[indices[i]*2+1]);\n\n                    vertices.push(Vector3.copy(vertices[indices[i+2]]));\n                    normals.push(Vector3.normalize(vertices[indices[i+2]]));\n                    texCoords.push(1, texCoords[indices[i+2]*2+1]);\n\n                    indices[i] = vertices.length-2;\n                    indices[i+2] = vertices.length-1;\n                }\n            }\n        }\n\n\n        const mesh = new Mesh3();\n        mesh.setVertices(vertices);\n        mesh.setNormals(normals);\n        mesh.setIndices(indices);\n        mesh.setTextureCoordinates(texCoords);\n        return mesh;\n    }\n\n    private static isEndVertex(i: number, vertices: Vector3[], indices: number[]): boolean\n    {\n        if(vertices[indices[i]].x > 0)\n            return true;\n        else\n            return false;\n    }\n\n    private static isSeamVertex(i: number, vertices: Vector3[], indices: number[]): boolean\n    {\n        if(vertices[indices[i]].x == 0 && vertices[indices[i]].z <= 0)\n            return true;\n        else\n            return false;\n    }\n\n    private static createCentroids(vertices: Vector3[], v1: number, v2: number, v3: number): Vector3[]\n    {\n        const centroids: Vector3[] = [];\n\n        const centroid1 = Vector3.add(vertices[v1], vertices[v2]);\n        centroid1.divideScalar(2);\n        centroid1.normalize();\n        centroids.push(centroid1);\n\n        const centroid2 = Vector3.add(vertices[v2], vertices[v3]);\n        centroid2.divideScalar(2);\n        centroid2.normalize();\n        centroids.push(centroid2);\n\n        const centroid3 = Vector3.add(vertices[v3], vertices[v1]);\n        centroid3.divideScalar(2);\n        centroid3.normalize();\n        centroids.push(centroid3);\n\n        return centroids;\n    }\n\n    private static subdivide(v1: number, v2: number, v3: number, c1: number, c2: number, c3: number): number[]\n    {\n        const triangles: number[] = [];\n        triangles.push(v1, c1, c3);\n        triangles.push(v2, c2, c1);\n        triangles.push(v3, c3, c2);\n        triangles.push(c1, c2, c3);\n        return triangles;\n    }\n\n    private static mergeSphereVertices(vertices: Vector3[], indices: number[]): [Vector3[], number[]]\n    {\n        const newVertices: Vector3[] = [];\n        const newIndices: number[] = [];\n\n        indices.forEach((elem: number) => {\n            newIndices.push(elem);\n        });\n\n        for(let i=0; i < vertices.length; i++)\n        {\n            let duplicate = false;\n            for(let j = 0; j < newVertices.length; j++)\n            {\n                if(vertices[i].equals(newVertices[j]))\n                {\n                    for(let k = 0; k < indices.length; k++)\n                    {\n                        if(indices[k] == i)\n                            newIndices[k] = j;\n                    }\n\n                    duplicate = true;\n                }   \n            }\n\n            if(!duplicate)\n            {\n                newVertices.push(vertices[i]);\n\n                for(let k = 0; k < indices.length; k++)\n                {\n                    if(indices[k] == i)\n                        newIndices[k] = newVertices.length-1;\n                }\n            }\n        }\n\n        return [newVertices, newIndices];\n    }\n\n    public static createLine(startPoint: Vector3, endPoint: Vector3): Line3\n    {\n        const line = new Line3(LineMode3.LINES);\n\n        const vertices: number[] = [];\n        vertices.push(startPoint.x, startPoint.y, startPoint.z);\n        vertices.push(endPoint.x, endPoint.y, endPoint.z);\n\n        line.setVertices(vertices);\n\n        return line;\n    }\n\n    public static createAxes(size = 1): Line3\n    {\n        const axes = new Line3(LineMode3.LINES);\n        \n        const vertices: number[] = [];\n        const colors: number[] = [];\n\n         // X axis\n         vertices.push(0, 0, 0);\n         vertices.push(size, 0, 0);\n         colors.push(1, 0, 0, 1);\n         colors.push(1, 0, 0, 1);\n\n         // Y axis\n         vertices.push(0, 0, 0);\n         vertices.push(0, size, 0);\n         colors.push(0, 1, 0, 1);\n         colors.push(0, 1, 0, 1);\n\n         // Z axis\n         vertices.push(0, 0, 0);\n         vertices.push(0, 0, size);\n         colors.push(0, 0, 1, 1);\n         colors.push(0, 0, 1, 1);\n\n         axes.setVertices(vertices);\n         axes.setColors(colors);\n\n         return axes;\n    }\n}", "// @ts-ignore\nimport morphVertexShader from '../shaders/morph.vert'\n// @ts-ignore\nimport morphFragmentShader from '../shaders/morph.frag'\n\nimport { Material3 } from './Material3';\nimport { ShaderProgram } from './ShaderProgram';\nimport { MorphMesh3 } from '../geometry/3d/MorphMesh3';\nimport { Mesh3 } from '../geometry/3d/Mesh3';\nimport { Camera } from '../core/Camera';\nimport { Node3 } from '../core/Node3';\nimport { LightManager } from '../lights/LightManager';\nimport { Texture } from './Texture';\nimport { Vector3 } from '../math/Vector3'\nimport { Color } from '../math/Color' \n\nexport class MorphMaterial extends Material3\n{\n    public static shader = new ShaderProgram(morphVertexShader, morphFragmentShader);\n    private static wireframeBuffers: Map<Mesh3, WebGLBuffer> = new Map();\n\n    public texture: Texture | null;\n    public ambientColor: Color;\n    public diffuseColor: Color;\n    public specularColor: Color;\n    public shininess: number;\n\n    private kAmbientUniform: WebGLUniformLocation | null;\n    private kDiffuseUniform: WebGLUniformLocation | null;\n    private kSpecularUniform: WebGLUniformLocation | null;\n    private shininessUniform: WebGLUniformLocation | null;\n    \n    private textureUniform: WebGLUniformLocation | null;\n    private useTextureUniform: WebGLUniformLocation | null;\n\n    private eyePositionUniform: WebGLUniformLocation | null;\n    private modelUniform: WebGLUniformLocation | null;\n    private viewUniform: WebGLUniformLocation | null;\n    private projectionUniform: WebGLUniformLocation | null;\n    private normalUniform: WebGLUniformLocation | null;\n\n    private numLightsUniform: WebGLUniformLocation | null;\n    private lightTypesUniform: WebGLUniformLocation | null;\n    private lightPositionsUniform: WebGLUniformLocation | null;\n    private ambientIntensitiesUniform: WebGLUniformLocation | null;\n    private diffuseIntensitiesUniform: WebGLUniformLocation | null;\n    private specularIntensitiesUniform: WebGLUniformLocation | null;\n\n    private positionAttribute: number;\n    private normalAttribute: number;\n    private colorAttribute: number;\n    private texCoordAttribute: number;\n\n    private morphAlphaUniform: WebGLUniformLocation | null;\n    private morphTargetPositionAttribute: number;\n    private morphTargetNormalAttribute: number;\n\n    public wireframe: boolean;\n\n    constructor()\n    {\n        super();\n\n        this.texture = null;\n        this.ambientColor = new Color(1, 1, 1);\n        this.diffuseColor = new Color(1, 1, 1);\n        this.specularColor = new Color(0, 0, 0);\n        this.shininess = 30;\n\n        MorphMaterial.shader.initialize(this.gl);\n\n        this.kAmbientUniform = MorphMaterial.shader.getUniform(this.gl, 'kAmbient');\n        this.kDiffuseUniform = MorphMaterial.shader.getUniform(this.gl, 'kDiffuse');\n        this.kSpecularUniform = MorphMaterial.shader.getUniform(this.gl, 'kSpecular');\n        this.shininessUniform = MorphMaterial.shader.getUniform(this.gl, 'shininess');\n\n        this.textureUniform = MorphMaterial.shader.getUniform(this.gl, 'textureImage');\n        this.useTextureUniform = MorphMaterial.shader.getUniform(this.gl, 'useTexture');\n\n        this.eyePositionUniform = MorphMaterial.shader.getUniform(this.gl, 'eyePosition');\n        this.viewUniform = MorphMaterial.shader.getUniform(this.gl, 'viewMatrix');\n        this.modelUniform = MorphMaterial.shader.getUniform(this.gl, 'modelMatrix');\n        this.projectionUniform = MorphMaterial.shader.getUniform(this.gl, 'projectionMatrix');\n        this.normalUniform = MorphMaterial.shader.getUniform(this.gl, 'normalMatrix');\n\n        this.numLightsUniform = MorphMaterial.shader.getUniform(this.gl, 'numLights');\n        this.lightTypesUniform = MorphMaterial.shader.getUniform(this.gl, 'lightTypes');\n        this.lightPositionsUniform = MorphMaterial.shader.getUniform(this.gl, 'lightPositions');\n        this.ambientIntensitiesUniform = MorphMaterial.shader.getUniform(this.gl, 'ambientIntensities');\n        this.diffuseIntensitiesUniform = MorphMaterial.shader.getUniform(this.gl, 'diffuseIntensities');\n        this.specularIntensitiesUniform = MorphMaterial.shader.getUniform(this.gl, 'specularIntensities');\n\n        this.positionAttribute = MorphMaterial.shader.getAttribute(this.gl, 'position');\n        this.normalAttribute = MorphMaterial.shader.getAttribute(this.gl, 'normal');\n        this.colorAttribute = MorphMaterial.shader.getAttribute(this.gl, 'color');\n        this.texCoordAttribute = MorphMaterial.shader.getAttribute(this.gl, 'texCoord');   \n\n        this.morphAlphaUniform = MorphMaterial.shader.getUniform(this.gl, 'morphAlpha');\n        this.morphTargetPositionAttribute = MorphMaterial.shader.getAttribute(this.gl, 'morphTargetPosition');\n        this.morphTargetNormalAttribute = MorphMaterial.shader.getAttribute(this.gl, 'morphTargetNormal');   \n\n        this.wireframe = false;\n    }\n\n    draw(mesh: Mesh3, camera: Camera, lightManager: LightManager): void\n    {\n        if(!(mesh instanceof MorphMesh3) || !this.visible || mesh.triangleCount == 0)\n            return;\n\n        // Initialize all the gl parameters for this shader\n        this.initialize();\n\n        // Switch to this shader\n        this.gl.useProgram(MorphMaterial.shader.getProgram());\n\n        // Set the camera uniforms\n        const worldMatrix = mesh.localToWorldMatrix;\n        const cameraPosition = new Vector3();\n        cameraPosition.transformPoint(camera.localToWorldMatrix);\n        this.gl.uniform3f(this.eyePositionUniform, cameraPosition.x, cameraPosition.y, cameraPosition.z);\n        this.gl.uniformMatrix4fv(this.modelUniform, false, worldMatrix.mat);\n        this.gl.uniformMatrix4fv(this.viewUniform, false, camera.viewMatrix.mat);\n        this.gl.uniformMatrix4fv(this.projectionUniform, false, camera.projectionMatrix.mat);\n        this.gl.uniformMatrix4fv(this.normalUniform, false, worldMatrix.inverse().transpose().mat);\n\n        // Set the material property uniforms\n        this.gl.uniform3f(this.kAmbientUniform, this.ambientColor.r, this.ambientColor.g, this.ambientColor.b);\n        this.gl.uniform3f(this.kDiffuseUniform, this.diffuseColor.r, this.diffuseColor.g, this.diffuseColor.b);\n        this.gl.uniform3f(this.kSpecularUniform,this.specularColor.r, this.specularColor.g, this.specularColor.b);\n        this.gl.uniform1f(this.shininessUniform, this.shininess);\n\n        // Set the light uniforms\n        this.gl.uniform1i(this.numLightsUniform, lightManager.getNumLights());\n        this.gl.uniform1iv(this.lightTypesUniform, lightManager.lightTypes);\n        this.gl.uniform3fv(this.lightPositionsUniform, lightManager.lightPositions);\n        this.gl.uniform3fv(this.ambientIntensitiesUniform, lightManager.ambientIntensities);\n        this.gl.uniform3fv(this.diffuseIntensitiesUniform, lightManager.diffuseIntensities);\n        this.gl.uniform3fv(this.specularIntensitiesUniform, lightManager.specularIntensities);\n\n        // Set the vertex positions\n        this.gl.enableVertexAttribArray(this.positionAttribute);\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, mesh.positionBuffer);\n        this.gl.vertexAttribPointer(this.positionAttribute, 3, this.gl.FLOAT, false, 0, 0);\n\n        // Set the vertex normals\n        this.gl.enableVertexAttribArray(this.normalAttribute);\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, mesh.normalBuffer);\n        this.gl.vertexAttribPointer(this.normalAttribute, 3, this.gl.FLOAT, false, 0, 0);\n\n        // Set the vertex colors\n        if(mesh.hasVertexColors)\n        {\n            this.gl.enableVertexAttribArray(this.colorAttribute);\n            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, mesh.colorBuffer);\n            this.gl.vertexAttribPointer(this.colorAttribute, 4, this.gl.FLOAT, false, 0, 0);\n        }\n        else\n        {\n            this.gl.disableVertexAttribArray(this.colorAttribute);\n            this.gl.vertexAttrib4f(this.colorAttribute, 1, 1, 1, 1);\n        }\n\n        // Update the morph targets\n        this.gl.uniform1f(this.morphAlphaUniform, mesh.morphAlpha);\n        if(mesh.morphAlpha > 0)\n        {\n            // Set the morph target positions\n            this.gl.enableVertexAttribArray(this.morphTargetPositionAttribute);\n            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, mesh.morphTargetPositionBuffer);\n            this.gl.vertexAttribPointer(this.morphTargetPositionAttribute, 3, this.gl.FLOAT, false, 0, 0);\n\n            // Set the morph target normals\n            this.gl.enableVertexAttribArray(this.morphTargetNormalAttribute);\n            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, mesh.morphTargetNormalBuffer);\n            this.gl.vertexAttribPointer(this.morphTargetNormalAttribute, 3, this.gl.FLOAT, false, 0, 0);\n        }\n        else\n        {\n            this.gl.disableVertexAttribArray(this.morphTargetPositionAttribute);\n            this.gl.disableVertexAttribArray(this.morphTargetNormalAttribute);\n        }\n\n        if(this.wireframe)\n        {\n            // Disable the texture in the shader\n            this.gl.uniform1i(this.useTextureUniform, 0);\n            this.gl.disableVertexAttribArray(this.texCoordAttribute);\n\n            if(!MorphMaterial.wireframeBuffers.get(mesh))\n            {\n                this.updateWireframeBuffer(mesh);\n            }\n\n            this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, MorphMaterial.wireframeBuffers.get(mesh) as WebGLBuffer);\n            this.gl.drawElements(this.gl.LINES, mesh.triangleCount * 6, this.gl.UNSIGNED_SHORT, 0);\n        }\n        else\n        {\n            if(this.texture)\n            {\n                // Activate the texture in the shader\n                this.gl.uniform1i(this.useTextureUniform, 1);\n\n                // Set the texture\n                this.gl.activeTexture(this.gl.TEXTURE0 + this.texture.id)\n                this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture.texture);\n                this.gl.uniform1i(this.textureUniform, this.texture.id);\n\n                // Set the texture coordinates\n                this.gl.enableVertexAttribArray(this.texCoordAttribute);\n                this.gl.bindBuffer(this.gl.ARRAY_BUFFER, mesh.texCoordBuffer);\n                this.gl.vertexAttribPointer(this.texCoordAttribute, 2, this.gl.FLOAT, false, 0, 0);\n            }\n            else\n            {\n                // Disable the texture in the shader\n                this.gl.uniform1i(this.useTextureUniform, 0);\n                this.gl.disableVertexAttribArray(this.texCoordAttribute);\n            }\n\n            // Draw the triangles\n            this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, mesh.indexBuffer);\n            this.gl.drawElements(this.gl.TRIANGLES, mesh.triangleCount*3, this.gl.UNSIGNED_SHORT, 0);\n        }\n    }\n\n    public updateWireframeBuffer(mesh: Mesh3): void\n    {\n        let wireframeBuffer: WebGLBuffer | null | undefined;\n        wireframeBuffer = MorphMaterial.wireframeBuffers.get(mesh);\n\n        if(!wireframeBuffer)\n        {\n            wireframeBuffer = this.gl.createBuffer();\n            \n            if(wireframeBuffer)\n                MorphMaterial.wireframeBuffers.set(mesh, wireframeBuffer);\n        }\n\n        const indexArray = new Uint16Array(mesh.triangleCount * 3);\n        this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, mesh.indexBuffer);\n        this.gl.getBufferSubData(this.gl.ELEMENT_ARRAY_BUFFER, 0, indexArray);\n        const indices = [... indexArray];\n\n        const wireframeIndices: number[] = [];\n        for(let i=0; i < mesh.triangleCount; i++)\n        {\n            wireframeIndices.push(indices[i*3]);\n            wireframeIndices.push(indices[i*3+1]);\n\n            wireframeIndices.push(indices[i*3+1]);\n            wireframeIndices.push(indices[i*3+2]);\n\n            wireframeIndices.push(indices[i*3+2]);\n            wireframeIndices.push(indices[i*3]);\n        }\n\n        this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, wireframeBuffer);\n        this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(wireframeIndices), this.gl.STATIC_DRAW);\n    }\n\n    setColor(color: Color): void\n    {\n        this.ambientColor.copy(color);\n        this.diffuseColor.copy(color);\n        this.specularColor.copy(color);\n    }\n\n    getColor(): Color\n    {\n        return this.diffuseColor;\n    }\n}", "import { Mesh3 } from \"./Mesh3\";\nimport { BoundingBox3 } from \"../../math/BoundingBox3\";\nimport { BoundingSphere } from \"../../math/BoundingSphere\";\nimport { Vector3 } from \"../../math/Vector3\";\nimport { MorphMaterial } from \"../../materials/MorphMaterial\";\n\nexport class MorphMesh3 extends Mesh3\n{\n    public morphAlpha: number;\n    public morphTargetBoundingBox: BoundingBox3;\n    public morphTargetBoundingSphere: BoundingSphere;\n    public material: MorphMaterial;\n\n    public morphTargetPositionBuffer: WebGLBuffer | null;\n    public morphTargetNormalBuffer: WebGLBuffer | null;\n\n    constructor()\n    {\n        // Call the superclass constructor\n        super();\n\n        this.morphAlpha = 0;\n\n        this.morphTargetBoundingBox = new BoundingBox3();\n        this.morphTargetBoundingSphere = new BoundingSphere();\n        this.material = new MorphMaterial();\n\n        this.morphTargetPositionBuffer = this.gl.createBuffer();\n        this.morphTargetNormalBuffer = this.gl.createBuffer();\n    }\n\n    setMorphTargetVertices(vertices: Vector3[] | number[], dynamicDraw = false, computeBounds = true): void\n    {\n        if(vertices.length > 0)\n        {\n            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.morphTargetPositionBuffer);\n\n            if(typeof vertices[0] === 'number')\n            {\n                if(dynamicDraw)\n                    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(vertices as number[]), this.gl.DYNAMIC_DRAW);\n                else\n                    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(vertices as number[]), this.gl.STATIC_DRAW);\n\n                this.morphTargetBoundingBox.computeBounds(vertices);\n                this.morphTargetBoundingSphere.computeBounds(vertices, this.morphTargetBoundingBox);\n            }\n            else\n            {\n                const vArray: number[] = [];\n                (vertices as Vector3[]).forEach((elem: Vector3) =>\n                {\n                    vArray.push(elem.x, elem.y, elem.z);\n                });\n\n                if(dynamicDraw)\n                    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(vArray), this.gl.DYNAMIC_DRAW);\n                else\n                    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(vArray), this.gl.STATIC_DRAW);\n\n                this.morphTargetBoundingBox.computeBounds(vArray);\n                this.morphTargetBoundingSphere.computeBounds(vArray, this.morphTargetBoundingBox);\n            }\n        }\n    }\n\n    setMorphTargetNormals(normals: Vector3[] | number[], dynamicDraw = false): void\n    {\n        if(normals.length > 0)\n        {\n            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.morphTargetNormalBuffer);\n\n            if(typeof normals[0] === 'number')\n            {\n                if(dynamicDraw)\n                    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(normals as number[]), this.gl.DYNAMIC_DRAW);\n                else\n                    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(normals as number[]), this.gl.STATIC_DRAW);\n            }\n            else\n            {\n                const nArray: number[] = [];\n                (normals as Vector3[]).forEach((elem: Vector3) =>\n                {\n                    nArray.push(elem.x, elem.y, elem.z);\n                });\n                \n                if(dynamicDraw)\n                    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(nArray), this.gl.DYNAMIC_DRAW);\n                else\n                    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(nArray), this.gl.STATIC_DRAW);\n            }\n        }\n    }\n\n}", "// @ts-ignore\nimport particleVertexShader from '../../shaders/particles2.vert'\n// @ts-ignore\nimport particleFragmentShader from '../../shaders/particles2.frag'\n\nimport { Mesh2 } from './Mesh2'\nimport { Node2 } from '../../core/Node2'\nimport { ShaderProgram } from '../../materials/ShaderProgram';\nimport { GfxApp } from '../../core/GfxApp';\nimport { Vector2 } from '../../math/Vector2';\n\n/**\n * Represents a 2D particle system\n */\nexport class Particles2 extends Node2\n{\n    /**\n     * The template shape used to render each particle.\n     */\n    public readonly baseParticle: Mesh2;\n\n    /**\n     * The number of particles to render.\n     */\n    public readonly numParticles: number;\n\n    /**\n     * Array containing positions for each particle instance.\n     */\n    public particlePositions: Vector2[];\n\n    /**\n     * Array containing sizes for each particle instance.\n     */\n    public particleSizes: number[];\n\n    public static shader = new ShaderProgram(particleVertexShader, particleFragmentShader);\n\n    private readonly gl: WebGL2RenderingContext;\n\n    private colorUniform: WebGLUniformLocation | null;\n    private modelUniform: WebGLUniformLocation | null;\n    private layerUniform: WebGLUniformLocation | null;\n\n    private textureUniform: WebGLUniformLocation | null;\n    private useTextureUniform: WebGLUniformLocation | null;\n\n    private particlePositionAttribute: number;\n    private particleSizeAttribute: number;\n\n    private vertPositionAttribute: number;\n    private vertColorAttribute: number;\n    private texCoordAttribute: number;\n\n    private particlePositionBuffer: WebGLBuffer | null;\n    private particleSizeBuffer: WebGLBuffer | null;\n\n    /**\n     * Create a new instance of a particle system.\n     * \n     * @param baseParticle The template shape for each particle\n     */\n    constructor(baseParticle: Mesh2, numParticles: number)\n    {\n        super();\n\n        this.gl  = GfxApp.getInstance().renderer.gl;\n\n        this.baseParticle = baseParticle;\n        this.numParticles = numParticles;\n\n        this.particlePositions = [];\n        this.particleSizes = [];\n\n        for(let i=0; i < this.numParticles; i++)\n        {\n            this.particlePositions.push(new Vector2());\n            this.particleSizes.push(1);\n        }\n\n        this.particlePositionBuffer = this.gl.createBuffer();\n        this.particleSizeBuffer = this.gl.createBuffer();\n\n        Particles2.shader.initialize(this.gl);\n\n        this.colorUniform = Particles2.shader.getUniform(this.gl, 'materialColor');\n        this.modelUniform = Particles2.shader.getUniform(this.gl, 'modelMatrix');\n        this.layerUniform = Particles2.shader.getUniform(this.gl, 'layer');\n\n        this.textureUniform = Particles2.shader.getUniform(this.gl, 'textureImage');\n        this.useTextureUniform = Particles2.shader.getUniform(this.gl, 'useTexture');\n\n        this.particlePositionAttribute = Particles2.shader.getAttribute(this.gl, 'particlePosition');\n        this.particleSizeAttribute = Particles2.shader.getAttribute(this.gl, 'particleSize');\n\n        this.vertPositionAttribute = Particles2.shader.getAttribute(this.gl, 'vertPosition');\n        this.vertColorAttribute = Particles2.shader.getAttribute(this.gl, 'vertColor');\n        this.texCoordAttribute = Particles2.shader.getAttribute(this.gl, 'texCoord');\n\n        const particlePositionArray: number[] = [];\n        for(let i=0; i < this.particlePositions.length; i++)\n                particlePositionArray.push(this.particlePositions[i].x, this.particlePositions[i].y);\n    \n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.particlePositionBuffer);\n        this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(particlePositionArray), this.gl.DYNAMIC_DRAW);\n    \n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.particleSizeBuffer);\n        this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(this.particleSizes), this.gl.DYNAMIC_DRAW);\n    }\n\n    /**\n     * @returns The template shape used to render each particle.\n     */\n    getBaseParticle(): Mesh2\n    {\n        return this.baseParticle;\n    }\n\n    /**\n     * Update the particle positions and/or sizes\n     * \n     * @param updatePositions - Whether to update the particle positions (defaults to true)\n     * @param updateSizes - Whether to update the particle sizes (defaults to false)\n     */\n    update(updatePositions = true, updateSizes = false): void\n    {\n        if(updatePositions)\n        {\n            const particlePositionArray: number[] = [];\n            for(let i=0; i < this.particlePositions.length; i++)\n                particlePositionArray.push(this.particlePositions[i].x, this.particlePositions[i].y);\n\n            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.particlePositionBuffer);\n            this.gl.bufferSubData(this.gl.ARRAY_BUFFER, 0, new Float32Array(particlePositionArray));\n        }\n        \n        if(updateSizes)\n        {\n            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.particleSizeBuffer);\n            this.gl.bufferSubData(this.gl.ARRAY_BUFFER, 0, new Float32Array(this.particleSizes));\n        }\n    }\n\n    /**\n     * Draw the particle system\n     */\n    draw(): void\n    {\n        if(!this.visible)\n            return;\n\n         // Switch to this shader\n         this.gl.useProgram(Particles2.shader.getProgram());\n\n         // Set the model matrix uniform\n         this.gl.uniformMatrix3fv(this.modelUniform, false, this.localToWorldMatrix.mat);\n \n         // Set the material property uniforms\n         this.gl.uniform4f(this.colorUniform, \n            this.baseParticle.material.color.r, \n            this.baseParticle.material.color.g, \n            this.baseParticle.material.color.b, \n            this.baseParticle.material.color.a);\n \n         // Set the layer uniform\n         this.gl.uniform1f(this.layerUniform, this.layer);\n\n         // Set the particle positions\n         this.gl.enableVertexAttribArray(this.particlePositionAttribute);\n         this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.particlePositionBuffer);\n         this.gl.vertexAttribPointer(this.particlePositionAttribute, 2, this.gl.FLOAT, false, 0, 0);\n         this.gl.vertexAttribDivisor(this.particlePositionAttribute, 1);\n\n         // Set the particle sizes\n         this.gl.enableVertexAttribArray(this.particleSizeAttribute);\n         this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.particleSizeBuffer);\n         this.gl.vertexAttribPointer(this.particleSizeAttribute, 1, this.gl.FLOAT, false, 0, 0);\n         this.gl.vertexAttribDivisor(this.particleSizeAttribute, 1);\n \n         // Set the vertex colors\n        if(this.baseParticle.hasVertexColors)\n        {\n            this.gl.enableVertexAttribArray(this.vertColorAttribute);\n            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.baseParticle.colorBuffer);\n            this.gl.vertexAttribPointer(this.vertColorAttribute, 4, this.gl.FLOAT, false, 0, 0);\n        }\n        else\n        {\n            this.gl.disableVertexAttribArray(this.vertColorAttribute);\n            this.gl.vertexAttrib4f(this.vertColorAttribute, 1, 1, 1, 1);\n        }\n\n \n         // Set the vertex positions\n         this.gl.enableVertexAttribArray(this.vertPositionAttribute);\n         this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.baseParticle.positionBuffer);\n         this.gl.vertexAttribPointer(this.vertPositionAttribute, 2, this.gl.FLOAT, false, 0, 0);\n \n         if(this.baseParticle.material.texture)\n         {\n             // Activate the texture in the shader\n             this.gl.uniform1i(this.useTextureUniform, 1);\n \n             // Set the texture\n             this.gl.activeTexture(this.gl.TEXTURE0 + this.baseParticle.material.texture.id)\n             this.gl.bindTexture(this.gl.TEXTURE_2D, this.baseParticle.material.texture.texture);\n             this.gl.uniform1i(this.textureUniform, this.baseParticle.material.texture.id);\n \n             // Set the texture coordinates\n             this.gl.enableVertexAttribArray(this.texCoordAttribute);\n             this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.baseParticle.texCoordBuffer);\n             this.gl.vertexAttribPointer(this.texCoordAttribute, 2, this.gl.FLOAT, false, 0, 0);\n         }\n         else\n         {\n             // Disable the texture in the shader\n             this.gl.uniform1i(this.useTextureUniform, 0);\n             this.gl.disableVertexAttribArray(this.texCoordAttribute);\n         }\n \n        // Draw the shape\n        this.gl.drawArraysInstanced(this.baseParticle.material.drawMode, 0, this.baseParticle.vertexCount, this.numParticles);\n\n        // Reset the divisors so it doesn't break other shaders\n        this.gl.vertexAttribDivisor(this.particlePositionAttribute, 0);\n        this.gl.vertexAttribDivisor(this.particleSizeAttribute, 0);\n\n        this.children.forEach((elem: Node2) => {\n            elem.draw();\n        });\n    }\n}", "import { Camera } from '../core/Camera';\nimport { Quaternion } from '../math/Quaternion';\nimport { Vector2 } from '../math/Vector2';\nimport { Vector3 } from '../math/Vector3';\n\nexport class OrbitControls\n{\n    public camera: Camera;\n    public zoomable: boolean;\n    public rotationSpeedX: number;\n    public rotationSpeedY: number;\n    public zoomSpeed: number;\n    public mouseButton: number;\n\n    // Camera parameters\n    private targetPoint: Vector3;\n    private distance: number;\n    private cameraOrbitX: Quaternion;\n    private cameraOrbitY: Quaternion;\n    private rotationDirection: Vector3;\n    private zoomDirection: number;\n    private mouseDrag: boolean;\n    private mouseMovement: Vector2;\n\n/**\n * Constructs an instance of the OrbitControls class\n * \n * @param camera - The camera to be controlled by the OrbitControls object\n * @param distance - The distance of the camera from the target point\n * @param zoomable - Flag indicating whether the camera should be able to zoom\n */\n    constructor(camera: Camera, distance = 1, zoomable = true)\n    {\n        this.camera = camera;\n        this.zoomable = zoomable;\n        this.distance = distance;\n\n        this.rotationSpeedX = Math.PI / 4;\n        this.rotationSpeedY = Math.PI / 4;\n        this.zoomSpeed = .25;\n        this.mouseButton = 0;\n\n        this.targetPoint = new Vector3();\n        this.cameraOrbitX = new Quaternion();\n        this.cameraOrbitY = new Quaternion();\n        this.rotationDirection = new Vector3();\n        this.zoomDirection = 0;\n        this.mouseDrag = false;\n        this.mouseMovement = new Vector2();\n\n        window.addEventListener('mousedown', (event: MouseEvent) => {this.onMouseDown(event)});\n        window.addEventListener('mouseup', (event: MouseEvent) => {this.onMouseUp(event)});\n        window.addEventListener('mousemove', (event: MouseEvent) => {this.onMouseMove(event)});\n        window.addEventListener('wheel', (event: WheelEvent) => {this.onMouseWheel(event)});\n\n        this.updateCamera();\n    }\n\n/**\n * Sets the target point which the camera will orbit around\n * \n * @param targetPoint - The point around which the camera will orbit \n */\n    setTargetPoint(targetPoint: Vector3): void\n    {\n        this.targetPoint.copy(targetPoint);\n        this.updateCamera();\n    }\n\n/**\n * Sets the distance of the camera from the target point\n * \n * @param distance - The distance of the camera from the target point\n */\n    setDistance(distance: number): void\n    {\n        this.distance = distance;\n        this.updateCamera();\n    }\n\n/**\n * Sets the rotation angles of the camera around the target point\n * \n * @param orbitX - The rotation angle around the horizontal axis\n * @param orbitY - The rotation angle around the vertical axis\n */\n    setOrbit(orbitX: number, orbitY: number): void\n    {\n        this.cameraOrbitX.setRotationX(orbitX);\n        this.cameraOrbitY.setRotationY(orbitY);\n        this.updateCamera();\n    }\n\n/**\n * Listens for mouse down events and sets the mouse drag flag to true if necessary\n * \n * @param event - The mouse down event\n */    \n    onMouseDown(event: MouseEvent): void \n    {\n        if(this.mouseButton == event.button && (event.target! as Element).localName == \"canvas\")\n            this.mouseDrag = true;\n    }\n\n/**\n * Listens for mouse up events and sets the mouse drag flag to false \n * \n * @param event - The mouse up event\n */      \n    onMouseUp(event: MouseEvent): void\n    {\n        if(this.mouseButton == event.button)\n            this.mouseDrag = false;\n    }\n\n    \n/**\n * onMouseMove updates the mouseMovement vector with the movementX and movementY properties of the mouse event\n * \n * @param event - The mouse event\n */\n    onMouseMove(event: MouseEvent): void\n    {\n        if(this.mouseDrag)\n        {\n            this.mouseMovement.x = -event.movementY;\n            this.mouseMovement.y = -event.movementX;\n        }\n    }\n\n/**\n * onMouseWheel updates the zoomDirection if the OrbitControls is zoomable\n * \n * @param event - The mouse wheel event\n */    \n    onMouseWheel(event: WheelEvent): void \n    {\n        if(this.zoomable)\n        {\n            this.zoomDirection += event.deltaY;\n        }\n    }\n\n/**\n * update updates the cameraOrbitX, cameraOrbitY and distance according to the mouse movement, \n * rotation and zoom direction\n * \n * @param deltaTime - The change in time since the last update\n */    \n    update(deltaTime: number): void\n    {\n        this.rotationDirection.x += this.mouseMovement.x;\n        this.rotationDirection.y += this.mouseMovement.y;\n        this.mouseMovement.x = 0;\n        this.mouseMovement.y = 0;\n\n        this.cameraOrbitX.multiply(Quaternion.makeRotationX(this.rotationDirection.x * this.rotationSpeedX * deltaTime));\n        this.cameraOrbitY.multiply(Quaternion.makeRotationY(this.rotationDirection.y * this.rotationSpeedY * deltaTime));\n        this.distance += this.zoomDirection * this.zoomSpeed * deltaTime;\n\n        // Reset the cumulative parameters\n        this.rotationDirection.set(0, 0, 0);\n        this.zoomDirection = 0;\n\n        this.updateCamera();\n    }\n\n/**\n * Updates the camera's rotation and position based on OrbitControls' current state\n */\n    private updateCamera(): void \n    {\n        this.camera.rotation.copy(this.cameraOrbitY);\n        this.camera.rotation.multiply(this.cameraOrbitX);\n        this.camera.position.set(0, 0, this.distance);\n        this.camera.position.rotate(this.camera.rotation);\n        this.camera.position.add(this.targetPoint);\n\n    }\n\n/**\n * Freezes the camera's rotation, position, and zoom\n */\n    freeze(): void\n    {\n        this.mouseDrag = false;\n        this.mouseMovement.set(0, 0);\n        this.zoomDirection = 0;\n    }\n}", "import { Camera } from '../core/Camera';\nimport { Vector3 } from '../math/Vector3';\nimport { Quaternion } from '../math/Quaternion';\nimport { Vector2 } from '../math/Vector2';\n\nexport class FirstPersonControls\n{\n    public camera: Camera;\n    \n    public translationSpeed: number;\n    public rotationSpeed: number;\n    public mouseButton: number;\n    public flyMode: boolean;\n    public hasMoved: boolean;\n\n    // Camera parameters\n    private moveDirection: Vector3;\n    private rotationDirection: Vector3;\n    private mouseDrag: boolean;\n    private mouseMovement: Vector2;\n\n    private targetOrbitX: Quaternion;\n    private targetOrbitY: Quaternion;\n\n/**\n * Constructs an instance of the FirstPersonControls class.\n * \n * @param camera - The camera object to use with the controls\n */    \n    constructor(camera: Camera)\n    {\n        this.camera = camera;\n\n        this.mouseButton = 0;\n        this.translationSpeed = 2;\n        this.rotationSpeed = Math.PI / 4;\n        this.flyMode = true;\n        this.hasMoved = false;\n\n        this.moveDirection = new Vector3();\n        this.rotationDirection = new Vector3();\n        this.mouseDrag = false;\n        this.mouseMovement = new Vector2();\n\n        this.targetOrbitX = new Quaternion();\n        this.targetOrbitY = new Quaternion();\n\n        window.addEventListener('mousedown', (event: MouseEvent) => {this.onMouseDown(event)});\n        window.addEventListener('mouseup', (event: MouseEvent) => {this.onMouseUp(event)});\n        window.addEventListener('mousemove', (event: MouseEvent) => {this.onMouseMove(event)});\n        window.addEventListener('keydown', (event: KeyboardEvent) => {this.onKeyDown(event)});\n        window.addEventListener('keyup', (event: KeyboardEvent) => {this.onKeyUp(event)});  \n    }\n\n/**\n * Handles the mousedown event, setting a flag to indicate that the mouse is being dragged.\n * \n * @param event - The mouse event object\n */\n    onMouseDown(event: MouseEvent): void \n    {\n        if(this.mouseButton == event.button && (event.target! as Element).localName == \"canvas\")\n            this.mouseDrag = true;\n    }\n\n/**\n * Handles the mouseup event, setting a flag to indicate that the mouse is no longer being dragged.\n * \n * @param event - The mouse event object\n */\n    onMouseUp(event: MouseEvent): void\n    {\n        if(this.mouseButton == event.button)\n            this.mouseDrag = false;\n    }\n\n/**\n * Handles the mousemove event, updating the mouseMovement vector with the movement of the mouse.\n * \n * @param event - The mouse event object\n */    \n    onMouseMove(event: MouseEvent): void\n    {\n        if(this.mouseDrag)\n        {\n            this.mouseMovement.x = -event.movementY;\n            this.mouseMovement.y = -event.movementX;\n        }\n    }\n\n/**\n * Handles the keydown event, updating the moveDirection vector based on the key pressed.\n * \n * @param event - The keyboard event object\n */\n    onKeyDown(event: KeyboardEvent): void \n    {\n        if(event.key == 'w')\n        {\n            this.moveDirection.z = -1;\n        }\n        else if(event.key == 's')\n        {\n            this.moveDirection.z = 1;\n        }\n        else if(event.key == 'a')\n        {\n            this.moveDirection.x = -1;\n        }\n        else if(event.key == 'd')\n        {\n            this.moveDirection.x = 1;\n        }\n    }\n\n/**\n * Handles the keyup event, updating the moveDirection vector based on the key released.\n * \n * @param event - The keyboard event object\n */    \n    onKeyUp(event: KeyboardEvent): void \n    {\n        if(event.key == 'w' && this.moveDirection.z == -1)\n        {\n            this.moveDirection.z = 0;\n        }\n        if(event.key == 's' && this.moveDirection.z == 1)\n        {\n            this.moveDirection.z = 0;\n        }\n        else if(event.key == 'a' && this.moveDirection.x == -1)\n        {\n            this.moveDirection.x = 0;\n        }\n        else if(event.key == 'd' && this.moveDirection.x == 1)\n        {\n            this.moveDirection.x = 0;\n        }\n    }\n\n/**\n * Updates the FirstPersonControls object\n * \n * @param deltaTime - The amount of time since the last update\n */\n    update(deltaTime: number): void\n    {\n        this.rotationDirection.x += this.mouseMovement.x;\n        this.rotationDirection.y += this.mouseMovement.y;\n        this.mouseMovement.x = 0;\n        this.mouseMovement.y = 0;\n\n        // Prevent the camera from rotating upside-down\n        const newTargetOrbitX = Quaternion.multiply(this.targetOrbitX, Quaternion.makeRotationX(this.rotationDirection.x * this.rotationSpeed * deltaTime));\n        const testVector = new Vector3(0, 0, -1);\n        testVector.rotate(newTargetOrbitX);\n        if(testVector.z < 0)\n            this.targetOrbitX.copy(newTargetOrbitX);\n\n        // Set the yaw target\n        this.targetOrbitY.multiply(Quaternion.makeRotationY(this.rotationDirection.y * this.rotationSpeed * deltaTime));\n\n        // Reset the cumulative rotation direction\n        this.rotationDirection.set(0, 0, 0);\n        \n        // Compute the look target and aim the camera accordignly\n        const target = new Vector3(0, 0, -1);\n        target.rotate(this.targetOrbitX);\n        target.rotate(this.targetOrbitY);\n        target.add(this.camera.position);\n        this.camera.lookAt(target, Vector3.UP);\n        \n        // Translate the camera based on the keyboard input\n        if(this.moveDirection.length() == 0)\n        {\n            this.hasMoved = false;\n        }\n        else\n        {\n            const moveDirectionNormalized = Vector3.normalize(this.moveDirection);\n            if(this.flyMode)\n            {\n                moveDirectionNormalized.multiplyScalar(this.translationSpeed * deltaTime);\n                const translation = Vector3.rotate(moveDirectionNormalized, this.camera.rotation);\n                this.camera.position.add(translation);\n            }\n            else\n            {\n                const translation = Vector3.rotate(moveDirectionNormalized, this.camera.rotation);\n                translation.y = 0;\n                translation.normalize();\n                translation.multiplyScalar(this.translationSpeed * deltaTime);\n                this.camera.position.add(translation);\n            }\n            this.hasMoved = true;\n        }\n    }\n\n/**\n * Freezes the FirstPersonControls object\n */\n    freeze(): void\n    {\n        this.mouseDrag = false;\n        this.mouseMovement.x = 0;\n        this.mouseMovement.y = 0;\n        this.moveDirection.set(0, 0, 0);\n    }\n}", "import { Vector3 } from \"./Vector3\"\n\nexport class Plane3 \n{\n    public point: Vector3;\n    public normal: Vector3;\n\n/**\n * Constructs a new Plane object\n * \n * @param point - The point on the plane (defaults to Vector3(0, 0, 0))\n * @param normal - The normal vector of the plane (defaults to Vector3(0, 0, -1))\n */\n    constructor(point = new Vector3(), normal = new Vector3(0, 0, -1))\n    {\n        this.point = point.clone();\n        this.normal = Vector3.normalize(normal);\n    }\n\n/**\n * Calculates the distance between a point and this Plane\n * \n * @param point - The point to calculate the distance to\n * @returns The distance between the point and this Plane\n */\n    distanceTo(point: Vector3): number\n    {\n        return this.normal.dot(point) - this.point.dot(this.normal);\n    }\n\n\n/**\n * Projects the given point onto the Plane \n * \n * @param point - The point to be projected onto the Plane\n * @returns The projected point on the Plane\n */\n    project(point: Vector3): Vector3\n    {\n        const target = new Vector3(this.normal.x, this.normal.y, this.normal.z);\n        target.multiplyScalar(-this.distanceTo(point));\n        target.add(point);\n\n        return target;\n    }\n}", "import { Vector3 } from './Vector3'\nimport { Plane3 } from './Plane3'\nimport { BoundingBox3 } from './BoundingBox3'\nimport { BoundingSphere } from './BoundingSphere'\nimport { Vector2 } from './Vector2';\nimport { Camera } from '../core/Camera'\nimport { Mesh3 } from '../geometry/3d/Mesh3'\nimport { Node3 } from '../core/Node3'\n\nexport class Ray3\n{\n    public origin: Vector3;\n    public direction: Vector3;\n\n    /**\n     * Constructor of the Ray3 class\n     * \n     * @param origin - The origin of the ray\n     * @param direction - The direction of the ray\n     */\n    constructor(origin = new Vector3(), direction = new Vector3(0, 0, -1))\n    {\n        this.origin = origin;\n        this.direction = direction;\n    }\n\n    /**\n     * Create a copy of the ray\n     * @returns Ray3 object containing a copy of the original ray\n     */\n    clone(): Ray3\n    {\n        const ray = new Ray3();\n        ray.origin.copy(this.origin);\n        ray.direction.copy(this.direction);\n        return ray;\n    }\n        \n    \n    /**\n     * Sets the origin and direction of the Ray\n     * \n     * @param origin - The origin of the Ray\n     * @param direction - The direction of the Ray\n     */\n    set(origin: Vector3, direction: Vector3): void\n    {\n        this.origin = origin;\n        this.direction = direction;\n    }\n\n    /**\n     * Sets the Ray based on the device coordinates and camera\n     * \n     * @param deviceCoords - A Vector2 containing the device coordinates\n     * @param camera - The Camera used to set the Ray\n     */\n    setPickRay(deviceCoords: Vector2, camera: Camera): void\n    {\n        const worldMatrix = camera.localToWorldMatrix;\n        this.origin.copy(worldMatrix.getTranslation());\n        this.direction.set(deviceCoords.x, deviceCoords.y, -1);\n        this.direction.transformPoint(camera.projectionMatrix.inverse());\n        this.direction.transformVector(worldMatrix);\n        this.direction.normalize();\n    }\n\n    /**\n     * Checks if the Ray intersects a Plane\n     * Reference: https://www.scratchapixel.com/lessons/3d-basic-rendering/minimal-ray-tracer-rendering-simple-shapes/ray-plane-and-ray-disk-intersection\n     * \n     * @param plane - The Plane to check for intersection\n     * @returns A Vector3 containing the intersection point or null if there is no intersection\n     */\n    intersectsPlane(plane: Plane3): Vector3 | null\n    {\n\n        // This method assumes the normals are unit vectors\n        const denominator = this.direction.dot(plane.normal);\n\n        if(Math.abs(denominator) > 0.000001)\n        {\n            const rayOriginToPlanePoint = Vector3.subtract(plane.point, this.origin);\n            const t = rayOriginToPlanePoint.dot(plane.normal) / denominator;\n            \n            if(t > 0)\n            {\n                const intersectionPoint = Vector3.multiplyScalar(this.direction, t);\n                intersectionPoint.add(this.origin);\n                return intersectionPoint;\n            }\n        }\n        \n        return null;\n    }\n    \n    /**\n     * Checks if the Ray intersects a Sphere\n     * Reference: https://www.scratchapixel.com/lessons/3d-basic-rendering/minimal-ray-tracer-rendering-simple-shapes/ray-sphere-intersection\n     * \n     * @param sphere - The Sphere to check for intersection\n     * @returns A Vector3 containing the intersection point or null if there is no intersection\n     */\n    intersectsSphere(sphere: BoundingSphere): Vector3 | null\n    {\n\n        const l = Vector3.subtract(sphere.center, this.origin);\n        const tca = l.dot(this.direction);\n        const radiusSquared = sphere.radius * sphere.radius;\n\n        const d2 = l.dot(l) - tca * tca;\n        if(d2 > radiusSquared)\n            return null;\n\n        const thc = Math.sqrt(radiusSquared - d2);\n        const t0 = tca - thc;\n        const t1 = tca + thc;\n\n        if(t0 < 0 && t1 < 0)\n            return null;\n        \n        const intersection = this.direction.clone();\n\n        if(t0 < t1)\n            intersection.multiplyScalar(t0);\n        else\n            intersection.multiplyScalar(t1);\n        \n        intersection.add(this.origin);\n\n        return intersection;\n    }\n\n    /**\n     * Checks if the Ray intersects a Box\n     * Reference: https://www.scratchapixel.com/lessons/3d-basic-rendering/minimal-ray-tracer-rendering-simple-shapes/ray-box-intersection\n     * \n     * @param box - The Box to check for intersection\n     * @returns A Vector3 containing the intersection point or null if there is no intersection\n     */\n    intersectsBox(box: BoundingBox3): Vector3 | null\n    {\n        let tmin = (box.min.x - this.origin.x) / this.direction.x; \n        let tmax = (box.max.x - this.origin.x) / this.direction.x; \n    \n        if (tmin > tmax)\n        {\n            const temp = tmin;\n            tmin = tmax;\n            tmax = temp;\n        } \n    \n        let tymin = (box.min.y - this.origin.y) / this.direction.y; \n        let tymax = (box.max.y - this.origin.y) / this.direction.y; \n    \n        if (tymin > tymax)\n        {\n            const temp = tymin;\n            tymin = tymax;\n            tymax = temp;\n        } \n    \n        if ((tmin > tymax) || (tymin > tmax)) \n            return null; \n    \n        if (tymin > tmin) \n            tmin = tymin; \n    \n        if (tymax < tmax) \n            tmax = tymax; \n    \n        let tzmin = (box.min.z - this.origin.z) / this.direction.z; \n        let tzmax = (box.max.z - this.origin.z) / this.direction.z; \n    \n        if (tzmin > tzmax) \n        {\n            const temp = tzmin;\n            tzmin = tzmax;\n            tzmax = temp;\n        } \n    \n        if ((tmin > tzmax) || (tzmin > tmax)) \n            return null; \n    \n        if (tzmin > tmin) \n            tmin = tzmin; \n    \n        if (tzmax < tmax) \n            tmax = tzmax; \n\n        const intersectionPoint = Vector3.multiplyScalar(this.direction, tmin);\n        intersectionPoint.add(this.origin);\n        return intersectionPoint;\n    }\n\n    /**\n     * Checks if the Ray intersects an Axis-Aligned Bounding Box\n     * \n     * @param transform - The Transform of the Axis-Aligned Bounding Box\n     * @returns A Vector3 containing the intersection point or null if there is no intersection\n     */\n    intersectsAxisAlignedBoundingBox(transform: Node3): Vector3 | null\n    {\n        return this.intersectsBox(transform.worldBoundingBox);\n    }\n\n    /**\n     * Checks if the Ray intersects an Oriented Bounding Box\n     * \n     * @param transform - The Transform of the Oriented Bounding Box\n     * @returns A Vector3 containing the intersection point or null if there is no intersection\n     */\n    intersectsOrientedBoundingBox(transform: Node3): Vector3 | null\n    {\n        const localIntersection = this.createLocalRay(transform).intersectsBox(transform.boundingBox);\n        if(localIntersection)\n        {\n            localIntersection.transformPoint(transform.localToWorldMatrix);\n        }\n        return localIntersection;\n    }\n\n    /**\n     * Computes the intersection between a ray and an oriented bounding sphere\n     * \n     * @param transform - The transformation of the bounding sphere \n     * @returns The intersection point if the ray intersects the bounding sphere, otherwise null\n     */\n    intersectsOrientedBoundingSphere(transform: Node3): Vector3 | null\n    {\n        return this.intersectsSphere(transform.worldBoundingSphere);\n    }\n\n    /**\n     * Computes a brute force intersection test between a ray and a mesh \n     * \n     * @param mesh - The mesh to test the intersection against\n     * @returns The intersection point if the ray intersects the mesh, otherwise null\n     */\n    intersectsMesh3(mesh: Mesh3): Vector3 | null\n    { \n        const localRay = this.createLocalRay(mesh);\n\n        // If we do not intersect the bounding box, then there is no\n        // need to load the vertices from GPU memory and conduct\n        // an intersection test with each triangle in the mesh.\n        if(!localRay.intersectsBox(mesh.boundingBox))\n            return null;\n\n        const vertices = mesh.getVertices();\n        const indices = mesh.getIndices();\n\n        const result = localRay.intersectsTriangles(vertices, indices);\n\n        if(result)\n            result.transformPoint(mesh.localToWorldMatrix);\n\n        return result;\n    }\n\n    \n    /**\n     * Computes the intersection between a ray and a series of triangles \n     * \n     * @param vertices - Array of either Vector3 objects or numbers representing the vertex positions\n     * @param indices - Array of indices representing the triangle faces\n     * @returns The intersection point if the ray intersects the triangles, otherwise null\n     */\n    intersectsTriangles(vertices: Vector3[] | number[], indices: number[]): Vector3 | null\n    {\n        let positions: Vector3[];\n        if(typeof vertices[0] === 'number')\n        {\n            positions = [];\n\n            const vArray = vertices as number[]\n            for(let i=0; i < vertices.length; i+=3)\n            {\n                positions.push(new Vector3(vArray[i], vArray[i+1], vArray[i+2]));\n            }\n        }\n        else\n        {\n            positions = vertices as Vector3[];\n        }\n\n        const results = [];\n        for(let i=0; i < indices.length; i+=3)\n        {\n            const intersection = this.intersectsTriangle(positions[indices[i]], positions[indices[i+1]], positions[indices[i+2]]);\n            \n            if(intersection)\n                results.push(intersection);\n        }\n\n        if(results.length == 0)\n        {\n            return null;\n        }\n        else if(results.length == 1)\n        {\n            return results[0];\n        }\n        else\n        {\n            let closestPoint = 0;\n            let closestDistance = this.origin.distanceTo(results[0]);\n            for(let i=1; i < results.length; i++)\n            {\n                const distance = this.origin.distanceTo(results[i]);\n                if(distance < closestDistance)\n                {\n                    closestPoint = i;\n                    closestDistance = distance;\n                }\n            }\n\n            return results[closestPoint];\n        }\n    }\n\n    /**\n     * Implementation of the M\u00F6ller\u2013Trumbore triangle intersection algorithm\n     * https://en.wikipedia.org/wiki/M%C3%B6ller%E2%80%93Trumbore_intersection_algorithm\n     * \n     * @param vertex0 - Vector3 object representing the first vertex of the triangle\n     * @param vertex1 - Vector3 object representing the second vertex of the triangle\n     * @param vertex2 - Vector3 object representing the third vertex of the triangle\n     * @returns The intersection point if the ray intersects the triangle, otherwise null\n     */\n    intersectsTriangle(vertex0: Vector3, vertex1: Vector3, vertex2: Vector3): Vector3 | null\n    {\n        const EPSILON = 0.0000001;\n\n        const edge1 = Vector3.subtract(vertex1, vertex0);\n        const edge2 = Vector3.subtract(vertex2, vertex0);\n        const h = Vector3.cross(this.direction, edge2);\n        const a = edge1.dot(h);\n    \n        if (a > -EPSILON && a < EPSILON) \n        {\n            // This ray is parallel to this triangle.\n            return null;    \n        }\n\n        const f = 1.0 / a;\n        const s = Vector3.subtract(this.origin, vertex0);\n        const u = f * (s.dot(h));\n        if (u < 0.0 || u > 1.0)\n        {\n            return null;\n        }\n\n        const q = Vector3.cross(s, edge1);\n        const v = f * this.direction.dot(q);\n        if (v < 0.0 || u + v > 1.0) \n        {\n            return null;\n        }\n\n        // At this stage we can compute t to find out where the intersection point is on the line.\n        const t = f * edge2.dot(q);\n\n        // ray intersection\n        if (t > EPSILON) \n        {\n            const intersection = this.direction.clone();\n            intersection.multiplyScalar(t);\n            intersection.add(this.origin);\n            return intersection;\n        }\n\n        return null;\n    }\n\n    /**\n     * Creates a new Ray object in the local space of a given Transform\n     * \n     * @param transform - The Transform object to create the local ray from\n     * @returns The ray in the local space of the Transform\n     */\n    createLocalRay(transform: Node3): Ray3\n    {\n        const localRay = this.clone();\n        const inverseWorldMatrix = transform.localToWorldMatrix.inverse();\n        localRay.origin.transformPoint(inverseWorldMatrix);\n        localRay.direction.transformVector(inverseWorldMatrix);\n        localRay.direction.normalize();\n        return localRay;\n    } \n}", "import { GfxApp } from '../core/GfxApp';\nimport { Node3 } from '../core/Node3';\nimport { Geometry3Factory } from '../geometry/Geometry3Factory';\nimport { Line3 } from '../geometry/3d/Line3';\nimport { Mesh3 } from '../geometry/3d/Mesh3';\nimport { UnlitMaterial } from '../materials/UnlitMaterial';\nimport { Color } from '../math/Color';\nimport { Plane3 } from '../math/Plane3';\nimport { Ray3 } from '../math/Ray3'\nimport { Vector2 } from '../math/Vector2';\nimport { Vector3 } from '../math/Vector3';\n\nexport class TransformWidget extends Node3\n{\n    public axes: Line3;\n    public thickAxes: Mesh3[];\n    \n    private deviceCoords: Vector2;\n    private currentAxis: number;\n    private selectionPlane: Plane3;\n\n    /**\n * Constructor for the TransformWidget class\n * \n * @param lineLength - The length of each line in the axes, default = 1 \n * @param selectionWidth - The width of each selected axis line\n * @param triggerDistance - The maximum distance from the axis line that can trigger selection\n */\n    constructor(lineLength = 1, selectionWidth = 0.01, triggerDistance = 0.05)\n    {\n        super();\n\n        this.currentAxis = -1;\n        this.deviceCoords = new Vector2();\n        this.selectionPlane = new Plane3();\n\n        this.axes = Geometry3Factory.createAxes(lineLength);\n        this.add(this.axes);\n\n        this.thickAxes = [];\n        this.thickAxes.push(Geometry3Factory.createBox(lineLength, selectionWidth, selectionWidth));\n        this.thickAxes.push(Geometry3Factory.createBox(selectionWidth, lineLength, selectionWidth));\n        this.thickAxes.push(Geometry3Factory.createBox(selectionWidth, selectionWidth, lineLength));\n\n        this.thickAxes[0].position.set(lineLength/2, 0, 0);\n        this.thickAxes[1].position.set(0, lineLength/2, 0);\n        this.thickAxes[2].position.set(0, 0, lineLength/2);\n\n        this.thickAxes[0].material = new UnlitMaterial();\n        this.thickAxes[1].material = new UnlitMaterial();\n        this.thickAxes[2].material = new UnlitMaterial();\n\n        this.thickAxes[0].material.setColor(new Color(1, 0, 0));\n        this.thickAxes[1].material.setColor(new Color(0, 1, 0));\n        this.thickAxes[2].material.setColor(new Color(0, 0, 1));\n\n        this.thickAxes[0].boundingBox.max.y = triggerDistance;\n        this.thickAxes[0].boundingBox.max.z = triggerDistance;\n\n        this.thickAxes[1].boundingBox.max.x = triggerDistance;\n        this.thickAxes[1].boundingBox.max.z = triggerDistance;\n\n        this.thickAxes[2].boundingBox.max.x = triggerDistance;\n        this.thickAxes[2].boundingBox.max.y = triggerDistance;\n\n        this.add(this.thickAxes[0]);\n        this.add(this.thickAxes[1]);\n        this.add(this.thickAxes[2]);\n\n        window.addEventListener('mousedown', (event: MouseEvent) => {this.onMouseDown(event)});\n        window.addEventListener('mouseup', (event: MouseEvent) => {this.onMouseUp(event)});\n        window.addEventListener('mousemove', (event: MouseEvent) => {this.onMouseMove(event)});\n    }\n\n/**\n * Updates the TransformWidget based on the deltaTime value\n *\n * @param deltaTime - The amount of time that has passed since the last update\n */\n    update(deltaTime: number): void\n    {\n        const ray = new Ray3();\n        ray.setPickRay(this.deviceCoords, GfxApp.getInstance().camera);\n\n        if(this.currentAxis == -1)\n        {\n            this.thickAxes[0].visible = false;\n            this.thickAxes[1].visible = false;\n            this.thickAxes[2].visible = false;\n            \n            if(ray.intersectsOrientedBoundingBox(this.thickAxes[0]))\n            {\n                this.thickAxes[0].visible = true;\n            }\n            else if(ray.intersectsOrientedBoundingBox(this.thickAxes[1]))\n            {\n                this.thickAxes[1].visible = true;\n            }\n            else if(ray.intersectsOrientedBoundingBox(this.thickAxes[2]))\n            {\n                this.thickAxes[2].visible = true;\n            }\n        }\n        else if(this.currentAxis == 0)\n        {\n            const projectedPosition = ray.intersectsPlane(this.selectionPlane);\n            if(projectedPosition)\n            {\n                const translation = new Vector3(projectedPosition.x - this.selectionPlane.point.x, 0, 0);\n                translation.rotate(this.rotation);\n                this.position.add(translation);\n                this.selectionPlane.point = projectedPosition;\n            }\n        }\n        else if(this.currentAxis == 1)\n        {\n            const projectedPosition = ray.intersectsPlane(this.selectionPlane);\n            if(projectedPosition)\n            {\n                const translation = new Vector3(0, projectedPosition.y - this.selectionPlane.point.y, 0);\n                translation.rotate(this.rotation);\n                this.position.add(translation);\n                this.selectionPlane.point = projectedPosition;\n            }\n        }\n        else if(this.currentAxis == 2)\n        {\n            const projectedPosition = ray.intersectsPlane(this.selectionPlane);\n            if(projectedPosition)\n            {\n                const translation = new Vector3(0, 0, projectedPosition.z - this.selectionPlane.point.z);\n                translation.rotate(this.rotation);\n                this.position.add(translation);\n                this.selectionPlane.point = projectedPosition;\n            }\n        }\n    }\n\n/**\n * Handles a mouse down event, checking for intersection with the thickAxes and setting currentAxis if one is found\n * \n * @param event - The MouseEvent\n */\n    onMouseDown(event: MouseEvent): void \n    {\n        this.deviceCoords = GfxApp.getInstance().getNormalizedDeviceCoordinates(event.x, event.y);\n\n        const ray = new Ray3();\n        ray.setPickRay( this.deviceCoords, GfxApp.getInstance().camera);\n\n        if(this.currentAxis == -1)\n        {\n            const xAxisPosition = ray.intersectsOrientedBoundingBox(this.thickAxes[0]);\n            if(xAxisPosition)\n            {\n                this.selectionPlane.point = xAxisPosition;\n                this.selectionPlane.normal = this.rotation.rotate(new Vector3(0, 0, 1));\n                this.currentAxis = 0;\n                return;\n            }\n\n            const yAxisPosition = ray.intersectsOrientedBoundingBox(this.thickAxes[1]);\n            if(yAxisPosition)\n            {\n                this.selectionPlane.point = yAxisPosition;\n                this.selectionPlane.normal = this.rotation.rotate(new Vector3(0, 0, 1));\n                this.currentAxis = 1;\n                return;\n            }\n\n            const zAxisPosition = ray.intersectsOrientedBoundingBox(this.thickAxes[2]);\n            if(zAxisPosition)\n            {\n                this.selectionPlane.point = zAxisPosition;\n                this.selectionPlane.normal = this.rotation.rotate(new Vector3(1, 0, 0));\n                this.currentAxis = 2;\n                return;\n            }\n        }\n    }\n\n/**\n * Handles a mouse up event, resetting the currentAxis\n * \n * @param event - The MouseEvent\n */    \n    onMouseUp(event: MouseEvent): void\n    {\n        this.currentAxis = -1;\n    }\n    \n/**\n * Handles a mouse move event, updating the deviceCoords\n * \n * @param event - The MouseEvent\n */\n    onMouseMove(event: MouseEvent): void\n    {\n        this.deviceCoords = GfxApp.getInstance().getNormalizedDeviceCoordinates(event.x, event.y);\n    }\n\n/**\n * Checks if the TransformWidget is currently selected\n * \n * @returns True if the TransformWidget is selected, false otherwise\n */\n    isSelected(): boolean\n    {\n        return this.currentAxis >= 0;\n    }\n}", "import { Vector3 } from \"../math/Vector3\";\nimport { Color } from \"../math/Color\";\nimport { LightManager } from \"./LightManager\";\nimport { Node3 } from \"../core/Node3\";\n\nexport enum LightType\n{\n    POINT = 0,\n    DIRECTIONAL\n}\n\nexport abstract class Light extends Node3\n{\n    public ambientIntensity: Vector3;\n    public diffuseIntensity: Vector3;\n    public specularIntensity: Vector3;\n\n    protected readonly type: LightType;\n\n    constructor(type: LightType, ambientIntensity: Vector3 | Color, diffuseIntensity: Vector3 | Color, specularIntensity: Vector3 | Color)\n    {\n        super();\n\n        this.type = type;\n\n        if(ambientIntensity instanceof Vector3)\n            this.ambientIntensity = new Vector3(ambientIntensity.x, ambientIntensity.y, ambientIntensity.z);\n        else\n            this.ambientIntensity = new Vector3(ambientIntensity.r, ambientIntensity.g, ambientIntensity.b);\n\n        if(diffuseIntensity instanceof Vector3)\n            this.diffuseIntensity = new Vector3(diffuseIntensity.x, diffuseIntensity.y, diffuseIntensity.z);\n        else\n            this.diffuseIntensity = new Vector3(diffuseIntensity.r, diffuseIntensity.g, diffuseIntensity.b);\n\n        if(specularIntensity instanceof Vector3)\n            this.specularIntensity = new Vector3(specularIntensity.x, specularIntensity.y, specularIntensity.z);\n        else\n            this.specularIntensity = new Vector3(specularIntensity.r, specularIntensity.g, specularIntensity.b);\n    }\n\n    getType(): LightType\n    {\n        return this.type;\n    }\n\n    setLights(lightManager: LightManager): void\n    {\n        lightManager.addLight(this);\n        super.setLights(lightManager);\n    }\n}", "import { Color } from \"../math/Color\";\nimport { Vector3 } from \"../math/Vector3\";\nimport { Light, LightType } from \"./Light\";\n\n/**\n * Creates a new ambient light that can be added to the scene, for example:\n * ```\n * const a = new AmbientLight();\n * a.ambientIntensity = new Vector3(0.3, 0.3, 0.3);\n * this.scene.add(a);\n * ```\n */\nexport class AmbientLight extends Light\n{\n    constructor(intensity: Vector3 | Color = new Vector3(0.5, 0.5, 0.5))\n    {\n        super(LightType.POINT, intensity, Vector3.ZERO, Vector3.ZERO);\n    }\n}", "import { Color } from \"../math/Color\";\nimport { Vector3 } from \"../math/Vector3\";\nimport { Light, LightType } from \"./Light\";\n\n/**\n * Creates a new directional light that can be added to the scene, for example:\n * ```\n * const d = new DirectionalLight();\n * d.diffuseIntensity = new Vector3(0.3, 0.3, 0.3);\n * d.specularIntensity = new Vector3(0.3, 0.3, 0.3);\n * this.scene.add(d);\n * ```\n */\nexport class DirectionalLight extends Light\n{\n    constructor(intensity: Vector3 | Color = new Vector3(0.5, 0.5, 0.5))\n    {\n        super(LightType.DIRECTIONAL, Vector3.ZERO, intensity, intensity);\n    }\n}", "import { Color } from \"../math/Color\";\nimport { Vector3 } from \"../math/Vector3\";\nimport { Light, LightType } from \"./Light\";\n\n/**\n * Creates a new point light that can be added to the scene, for example:\n * ```\n * const p = new PointLight();\n * p.diffuseIntensity = new Vector3(0.3, 0.3, 0.3);\n * p.specularIntensity = new Vector3(0.3, 0.3, 0.3);\n * this.scene.add(p);\n * ```\n */\nexport class PointLight extends Light\n{\n    constructor(intensity: Vector3 | Color = new Vector3(0.5, 0.5, 0.5))\n    {\n        super(LightType.POINT, Vector3.ZERO, intensity, intensity);\n    }\n}", "import { GfxApp } from '../core/GfxApp';\n\nexport class TextFile\n{\n    data: string;\n\n/**\n * Creates a new instance of the TextFile class\n */\n    constructor()\n    {\n        this.data = '';\n    }\n}\n\nexport class TextFileLoader\n{\n/**\n * Loads a text file located at the specified filename\n * \n * @param filename - The path to the text file to be loaded\n * @param callback - An optional callback function to be invoked when the file is loaded\n * @returns The TextFile object containing the loaded file's data\n */\n    static load(filename: string, callback: ((loadedFile: TextFile) => void) | null = null): TextFile\n    {\n        GfxApp.getInstance().assetManager.requestedAssets.push(filename);\n\n        const textFile = new TextFile();\n\n        fetch(filename).then((response: Response) => {\n            if(!response.ok)\n                throw new Error();\n            return response.blob();\n        })\n        .then((data: Blob) => {\n            data.text().then((text: string) => {\n                textFile.data = text;\n                if(callback)\n                {\n                    callback(textFile);\n                }\n                GfxApp.getInstance().assetManager.loadedAssets.push(filename);\n            });\n        })\n        .catch(() => {\n            GfxApp.getInstance().assetManager.errorAssets.push(filename);\n            console.error('Unable to download file: ' + filename);\n        });\n\n        return textFile;\n    }\n}", "export class StringParser\n{\n    private readonly tokens: string[][];\n    private line: number;\n    private token: number;\n\n/**\n * Constructs a StringParser object from the given data string\n * \n * @param data - The string to be parsed\n */\n    constructor(data: string)\n    {\n        this.tokens = [];\n        this.line = 0;\n        this.token = 0;\n\n        // Trim whitespace from each line\n        const lines = data.split('\\n');\n        for(let i=0; i < lines.length; i++)\n        {\n            this.tokens.push(lines[i].trim().split(/\\s+/));\n        }\n\n        // Remove empty strings\n        for(let i=0; i < this.tokens.length; i++)\n        {\n            if(this.tokens[i].length == 1 && this.tokens[i][0] == '')\n            {\n                this.tokens.splice(i, 1);\n                i--;\n            }\n        }\n    }\n\n\n/**\n * Checks the next token in the string without consuming it\n * \n * @returns The next token in the string\n */\n    peek(): string\n    {\n        return this.tokens[this.line][this.token];\n    }\n\n/**\n * Consumes the current token if it matches the expected token\n * \n * @param token - The expected token\n * @returns True if the current token matches the expected token and was consumed, false otherwise\n */    \n    expect(token: string): boolean\n    {\n        if(this.peek() == token)\n        {\n            this.readToken();\n            return true;\n        }\n        else\n        {\n            return false;\n        }\n    }\n\n/**\n * Consumes the current line\n */    \n    consumeLine(): void\n    {\n        this.line++;\n        this.token = 0;\n    }\n\n/**\n * Checks if the parser has reached the end of the string\n * \n * @returns True if the parser has reached the end of the string, false otherwise\n */\n    done(): boolean\n    {\n        return this.line >= this.tokens.length;\n    }\n\n/**\n * Reads and consumes the next token in the string\n * \n * @returns The next token in the string\n */\n    readToken(): string\n    {\n        const nextToken = this.tokens[this.line][this.token];\n        this.token++;\n\n        if(this.token >= this.tokens[this.line].length)\n        {\n            this.line++;\n            this.token = 0;\n        }\n\n        return nextToken;\n    }\n\n/**\n * Reads and consumes the next token in the string as a number\n * \n * @returns The next token in the string as a number\n */\n    readNumber(): number\n    {\n        return Number(this.readToken());\n    }\n\n/**\n * Reads and consumes the rest of the current line\n * \n * @returns The rest of the current line as an array of strings\n */\n    readLine(): string[]\n    {\n        const nextLine = [];\n        for(let i=this.token; i < this.tokens[this.line].length; i++)\n        {\n            nextLine.push(this.tokens[this.line][i]);\n        }\n\n        this.line++;\n        this.token = 0;\n\n        return nextLine;\n    }\n}", "export class FileWriter\n{\n    static saveAscii(filename: string, text: string) \n    {\n        const element = document.createElement('a');\n        element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));\n        element.setAttribute('download', filename);\n    \n        element.style.display = 'none';\n        document.body.appendChild(element);\n    \n        element.click();\n    \n        document.body.removeChild(element);\n    }\n\n    static saveBinary(filename: string, data: ArrayBuffer) \n    {\n        const blob = new Blob([data], {type: \"application/octet-stream\"});\n        const url = URL.createObjectURL(blob);\n\n        const element = document.createElement('a');\n        element.setAttribute('href', url);\n        element.setAttribute('download', filename);\n    \n        element.style.display = 'none';\n        document.body.appendChild(element);\n    \n        element.click();\n    \n        document.body.removeChild(element);\n\n        // Release the reference to the blob\n        URL.revokeObjectURL(url);\n    }\n}", "import { Mesh3 } from '../geometry/3d/Mesh3'\nimport { Node3 } from '../core/Node3'\nimport { Color } from '../math/Color'\nimport { StringParser } from './StringParser';\nimport { Document, Node, Primitive } from '@gltf-transform/core';\n\nexport class MeshParser\n{\n    /**\n     * Parses the contents of an OBJ file and stores the data in a given Mesh object\n     * \n     * @param obj - The contents of the object file as a string\n     * @param mesh - The Mesh object to store the data\n     */\n    static parseOBJ(obj: string, mesh: Mesh3)\n    {\n        const parser = new StringParser(obj);\n        const vertices: number[] = [];\n        const colors: number[] = [];\n        const normals: number[] = [];\n        const indices: number[] = [];\n        const uvs: number[] = [];\n\n        while(!parser.done())\n        {\n            const nextToken = parser.readToken();\n\n            if(nextToken == 'v')\n                this.parseOBJVertex(parser.readLine(), vertices, colors);\n            else if(nextToken == 'vn')\n                this.parseOBJNormal(parser.readLine(), normals);\n            else if(nextToken == 'vt')\n                this.parseOBJTextureCoordinate(parser.readLine(), uvs);\n            else if(nextToken == 'f')\n                this.parseOBJFace(parser.readLine(), indices);\n            else\n                parser.consumeLine();\n        }\n\n        mesh.setVertices(vertices);\n        mesh.setNormals(normals);\n        mesh.setIndices(indices);\n\n        if(colors.length > 0)\n            mesh.setColors(colors);\n\n        // If we have per vertex UVs, asign them to the mesh\n        if(uvs.length / 2 == vertices.length / 3)\n            mesh.setTextureCoordinates(uvs);\n    }\n\n    /**\n     * Parses a vertex line from an OBJ file\n     * \n     * @param line - The line containing the vertex data\n     * @param vertices - The array to store the vertex positions\n     * @param colors - The array to store the vertex colors\n     */\n    private static parseOBJVertex(line: string[], vertices: number[], colors: number[])\n    {\n        vertices.push(Number(line[0]));\n        vertices.push(Number(line[1]));\n        vertices.push(Number(line[2]));\n\n        if(line.length > 3)\n        {\n            colors.push(Number(line[3]));\n            colors.push(Number(line[4]));\n            colors.push(Number(line[5]));\n            colors.push(1);\n        }\n    }\n\n    /**\n     * Parses a normal line from an OBJ file\n     * \n     * @param line - The normal line to be parsed\n     * @param normals - An array to store the normal coordinates\n     */    \n    private static parseOBJNormal(line: string[], normals: number[])\n    {\n        normals.push(Number(line[0]));\n        normals.push(Number(line[1]));\n        normals.push(Number(line[2]));\n    }\n\n    /**\n     * Parses a texture coordinate line from an OBJ file\n     * \n     * @param line - The texture coordinate line to be parsed\n     * @param uvs - An array to store the texture coordinates\n     */\n    private static parseOBJTextureCoordinate(line: string[], uvs: number[])\n    {\n        uvs.push(Number(line[0]));\n        uvs.push(Number(line[1]));\n    }\n\n    /**\n     * Parses a face line from an OBJ file\n     * \n     * @param line - The face line to be parsed\n     * @param indices - An array to store the face indices\n     */\n    private static parseOBJFace(line: string[], indices: number[])\n    {\n        for(let i=0; i < 3; i++)\n        {\n            const index = line[i].split('/');\n            indices.push(Number(index[0])-1);\n        }\n    }\n\n\n\n\n    /**\n     * Parses the contents of a PLY file and stores the data in a given Mesh object\n     * This function works for both ASCII or binary PLY files.\n     * \n     * @param ply - The contents of the PLY file as an ArrayBuffer\n     * @param mesh - The Mesh object to store the data\n     */\n    static parsePLY(ply: ArrayBuffer, mesh: Mesh3): void\n    {\n        const buffer = new Uint8Array(ply);\n        const decoder = new TextDecoder();\n\n        // Extract the header\n        let done = false;\n        let header = '';\n        let currentByte = 0;\n        const windowLength = 512;\n        while(!done)\n        {\n            const headerBuffer = buffer.subarray(currentByte, currentByte + windowLength);\n            currentByte += windowLength;\n            header += decoder.decode(headerBuffer);\n            const endOfHeader = header.indexOf('end_header');\n            if(endOfHeader > 0)\n            {\n                header = header.substring(0, endOfHeader + 10);\n                currentByte = endOfHeader + 11;\n                done = true;\n            }\n        }\n\n        // Parse the header\n        const headerParser = new StringParser(header);\n\n        if(headerParser.readToken() != 'ply' || headerParser.readToken() != 'format')\n        {\n            console.error('Unable to parse PLY');\n            return;\n        }\n\n        const format = headerParser.readToken();\n        headerParser.consumeLine();\n        \n        if(format == 'ascii')\n        {\n            const dataBuffer = buffer.subarray(currentByte);\n            const dataParser = new StringParser(decoder.decode(dataBuffer));\n            this.parsePLYAscii(headerParser, dataParser, mesh);\n        }\n        else if(format == 'binary_little_endian')\n        {\n            this.parsePLYBinary(headerParser, new DataView(ply, currentByte), mesh, true);\n        }\n        else if(format == 'binary_big_endian')\n        {\n            this.parsePLYBinary(headerParser, new DataView(ply, currentByte), mesh, false);\n        }\n        else\n        {\n            console.error('Unable to parse PLY');\n            return;\n        }\n    }\n\n    private static parsePLYAscii(headerParser: StringParser, dataParser: StringParser, mesh: Mesh3): void\n    {\n        let numVertices = 0;\n        let numFaces = 0;\n        const vertices: number[] = [];\n        const colors: number[] = [];\n        const normals: number[] = [];\n        const indices: number[] = [];\n        const uvs: number[] = [];\n        \n        while(!headerParser.done())\n        {\n            const nextToken = headerParser.readToken();\n\n            if(nextToken == 'element')\n            {\n                const line = headerParser.readLine();\n                if(line[0] == 'vertex')\n                {\n                    numVertices = Number(line[1]);\n\n                    let xIndex = -1;\n                    let yIndex = -1;\n                    let zIndex = -1;\n                    let nxIndex = -1;\n                    let nyIndex = -1;\n                    let nzIndex = -1;\n                    let uIndex = -1;\n                    let vIndex = -1;\n                    let redIndex = -1;\n                    let greenIndex = -1;\n                    let blueIndex = -1;\n                    let alphaIndex = -1;\n\n                    let propertyIndex = 0;\n                    while(headerParser.peek() == 'property')\n                    { \n                        const propertyLine = headerParser.readLine();\n                        if(propertyLine[1] == 'float')\n                        {\n                            if(propertyLine[2] == 'x')\n                                xIndex = propertyIndex;\n                            else if(propertyLine[2] == 'y')\n                                yIndex = propertyIndex;\n                            else if(propertyLine[2] == 'z')\n                                zIndex = propertyIndex;\n                            else if(propertyLine[2] == 'nx')\n                                nxIndex = propertyIndex;\n                            else if(propertyLine[2] == 'ny')\n                                nyIndex = propertyIndex;\n                            else if(propertyLine[2] == 'nz')\n                                nzIndex = propertyIndex;\n                            else if(propertyLine[2] == 'texture_u')\n                                uIndex = propertyIndex;\n                            else if(propertyLine[2] == 'texture_v')\n                                vIndex = propertyIndex;\n                        }\n                        else if(propertyLine[1] == 'uchar')\n                        {\n                            if(propertyLine[2] == 'red')\n                                redIndex = propertyIndex;\n                            else if(propertyLine[2] == 'green')\n                                greenIndex = propertyIndex;\n                            else if(propertyLine[2] == 'blue')\n                                blueIndex = propertyIndex;\n                            else if(propertyLine[2] == 'alpha')\n                                alphaIndex = propertyIndex;\n                        }\n\n                        propertyIndex++;\n                    }\n\n                    const properties: number[] = [];\n                    for(let i=0; i < propertyIndex; i++)\n                    {\n                        properties.push(0);\n                    }\n\n                    for(let i=0; i < numVertices; i++)\n                    {\n                        for(let j=0; j < propertyIndex; j++)\n                            properties[j] = dataParser.readNumber();\n\n                        if(xIndex >= 0 && yIndex >= 0 && zIndex >= 0)\n                            vertices.push(properties[xIndex], properties[yIndex], properties[zIndex]);\n\n                        if(nxIndex >= 0 && nyIndex >= 0 && nzIndex >= 0)\n                            normals.push(properties[nxIndex], properties[nyIndex], properties[nzIndex]);\n\n                        if(uIndex >= 0 && vIndex >= 0)\n                            uvs.push(properties[uIndex], properties[vIndex]);\n\n                        if(redIndex >= 0 && greenIndex >= 0 && blueIndex >= 0)\n                        {\n                            if(alphaIndex >= 0)\n                                colors.push(properties[redIndex] / 255, properties[greenIndex] / 255, properties[blueIndex] / 255, properties[alphaIndex] / 255);\n                            else\n                                colors.push(properties[redIndex] / 255, properties[greenIndex] / 255, properties[blueIndex] / 255, 1);\n                        }\n                    }\n                }\n                else if(line[0] == 'face')\n                {\n                    numFaces = Number(line[1]);\n\n                    while(headerParser.peek() == 'property')\n                    {\n                        const propertyLine = headerParser.readLine();\n                        if  (propertyLine[1] == 'list' && \n                            (propertyLine[2] == 'uchar' || propertyLine[2] == 'char') && \n                            (propertyLine[3] == 'int' || propertyLine[3] == 'uint') && \n                            (propertyLine[4] == 'vertex_indices' || propertyLine[4] == 'vertex_index'))\n                        {\n                            for(let i=0; i < numFaces; i++)\n                            {\n                                const numFaceIndices = dataParser.readNumber();\n                                for(let j=0; j < numFaceIndices; j++)\n                                    indices.push(dataParser.readNumber());\n                            }\n                        }\n                    }\n                }\n                else\n                {\n                    console.error('Unable to parse PLY');\n                    return;\n                }\n            }\n            else\n            {\n                headerParser.consumeLine();\n            }\n        }\n\n        mesh.setVertices(vertices);\n        mesh.setColors(colors);\n        mesh.setNormals(normals);\n        mesh.setIndices(indices);\n\n        // If we have per vertex UVs, asign them to the mesh\n        if(uvs.length / 2 == vertices.length / 3)\n            mesh.setTextureCoordinates(uvs);\n    }\n\n    private static parsePLYBinary(headerParser: StringParser, data: DataView, mesh: Mesh3, little_endian = true): void\n    {\n        let numVertices = 0;\n        let numFaces = 0;\n        const vertices: number[] = [];\n        const colors: number[] = [];\n        const normals: number[] = [];\n        const indices: number[] = [];\n        const uvs: number[] = [];\n\n        let totalBytes = 0;\n        while(!headerParser.done())\n        {\n            const nextToken = headerParser.readToken();\n\n            if(nextToken == 'element')\n            {\n                const line = headerParser.readLine();\n                if(line[0] == 'vertex')\n                {\n                    const vertexStart = totalBytes;\n\n                    numVertices = Number(line[1]);\n\n                    let propertyBytes = 0;\n                    let xBytes = -1;\n                    let yBytes = -1;\n                    let zBytes = -1;\n                    let nxBytes = -1;\n                    let nyBytes = -1;\n                    let nzBytes = -1;\n                    let uBytes = -1;\n                    let vBytes = -1;\n                    let redBytes = -1;\n                    let greenBytes = -1;\n                    let blueBytes = -1;\n                    let alphaBytes = -1;\n\n                    while(headerParser.peek() == 'property')\n                    { \n                        const propertyLine = headerParser.readLine();\n                        if(propertyLine[1] == 'float')\n                        {\n                            if(propertyLine[2] == 'x')\n                                xBytes = propertyBytes;\n                            else if(propertyLine[2] == 'y')\n                                yBytes = propertyBytes;\n                            else if(propertyLine[2] == 'z')\n                                zBytes = propertyBytes;\n                            else if(propertyLine[2] == 'nx')\n                                nxBytes = propertyBytes;\n                            else if(propertyLine[2] == 'ny')\n                                nyBytes = propertyBytes;\n                            else if(propertyLine[2] == 'nz')\n                                nzBytes = propertyBytes;\n                            else if(propertyLine[2] == 'texture_u')\n                                uBytes = propertyBytes;\n                            else if(propertyLine[2] == 'texture_v')\n                                vBytes = propertyBytes;\n\n                            propertyBytes+=4;\n                        }\n                        else if(propertyLine[1] == 'uchar' || propertyLine[1] == 'char')\n                        {\n                            if(propertyLine[2] == 'red')\n                                redBytes = propertyBytes;\n                            else if(propertyLine[2] == 'green')\n                                greenBytes = propertyBytes;\n                            else if(propertyLine[2] == 'blue')\n                                blueBytes = propertyBytes;\n                            else if(propertyLine[2] == 'alpha')\n                                alphaBytes = propertyBytes;\n\n                            propertyBytes+=1;\n                        }  \n                        else if(propertyLine[1] == 'short' || propertyLine[1] == 'ushort')\n                        {\n                            propertyBytes+=2;\n                        }\n                        else if(propertyLine[1] == 'int' || propertyLine[1] == 'uint')\n                        {\n                            propertyBytes+=4;\n                        }\n                        else if(propertyLine[1] == 'double')\n                        {\n                            propertyBytes+=8;\n                        }\n                    }\n\n                    for(let i=0; i < numVertices; i++)\n                    {\n                        if(xBytes >= 0 && yBytes >= 0 && zBytes >= 0)\n                        {\n                            vertices.push(data.getFloat32(vertexStart + i*propertyBytes + xBytes, little_endian));\n                            vertices.push(data.getFloat32(vertexStart + i*propertyBytes + yBytes, little_endian));\n                            vertices.push(data.getFloat32(vertexStart + i*propertyBytes + zBytes, little_endian));\n                        }\n\n                        if(nxBytes >= 0 && nyBytes >= 0 && nzBytes >= 0)\n                        {\n                            normals.push(data.getFloat32(vertexStart + i*propertyBytes + nxBytes, little_endian));\n                            normals.push(data.getFloat32(vertexStart + i*propertyBytes + nyBytes, little_endian));\n                            normals.push(data.getFloat32(vertexStart + i*propertyBytes + nzBytes, little_endian));\n                        }\n\n                        if(uBytes >= 0 && vBytes >= 0)\n                        {\n                            uvs.push(data.getFloat32(vertexStart + i*propertyBytes + uBytes, little_endian));\n                            uvs.push(data.getFloat32(vertexStart + i*propertyBytes + vBytes, little_endian));\n                        }\n\n                        if(redBytes >= 0 && greenBytes >= 0 && blueBytes >= 0)\n                        {\n                            if(alphaBytes >= 0)\n                                colors.push(data.getUint8(vertexStart + i*propertyBytes + redBytes) / 255, \n                                    data.getUint8(vertexStart + i*propertyBytes + greenBytes) / 255, \n                                    data.getUint8(vertexStart + i*propertyBytes + blueBytes) / 255, \n                                    data.getUint8(vertexStart + i*propertyBytes + alphaBytes) / 255);\n                            else\n                                colors.push(data.getUint8(vertexStart + i*propertyBytes + redBytes) / 255, \n                                    data.getUint8(vertexStart+ i*propertyBytes + greenBytes) / 255, \n                                    data.getUint8(vertexStart + i*propertyBytes + blueBytes) / 255, \n                                    1);\n                        }\n                    }\n\n                    totalBytes += numVertices * propertyBytes;\n                }\n                else if(line[0] == 'face')\n                {\n                    numFaces = Number(line[1]);\n                    let faceBytes = totalBytes;\n\n                    while(headerParser.peek() == 'property')\n                    {\n                        const propertyLine = headerParser.readLine();\n                        if  (propertyLine[1] == 'list' && \n                            (propertyLine[2] == 'uchar' || propertyLine[2] == 'char') && \n                            (propertyLine[3] == 'int' || propertyLine[3] == 'uint') && \n                            (propertyLine[4] == 'vertex_indices' || propertyLine[4] == 'vertex_index'))\n                        {\n                            for(let i=0; i < numFaces; i++)\n                            {\n                                const numFaceIndices = data.getUint8(faceBytes);\n                                faceBytes+=1;\n\n                                for(let j=0; j < numFaceIndices; j++)\n                                {\n                                    indices.push(data.getUint32(faceBytes, little_endian));\n                                    faceBytes+=4;\n                                }\n                            }\n                        }\n                        else if(propertyLine[1] == 'uchar' || propertyLine[1] == 'char')\n                        {\n                            faceBytes+=1;\n                        }  \n                        else if(propertyLine[1] == 'short' || propertyLine[1] == 'ushort')\n                        {\n                            faceBytes+=2;\n                        }\n                        else if(propertyLine[1] == 'int' || propertyLine[1] == 'uint' || propertyLine[1] == 'float')\n                        {\n                            faceBytes+=4;\n                        }\n                        else if(propertyLine[1] == 'double')\n                        {\n                            faceBytes+=8;\n                        }\n                    }\n                }\n                else\n                {\n                    console.error('Unable to parse PLY');\n                    return;\n                }\n            }\n            else\n            {\n                headerParser.consumeLine();\n            }\n        }\n\n        mesh.setVertices(vertices);\n        mesh.setColors(colors);\n        mesh.setNormals(normals);\n        mesh.setIndices(indices);\n\n        // If we have per vertex UVs, asign them to the mesh\n        if(uvs.length / 2 == vertices.length / 3)\n            mesh.setTextureCoordinates(uvs);\n    }\n\n\n\n\n    /**\n     * Parses the contents of a GLTF file and stores the scene in a Node3 object\n     * \n     * @param document - The contents of the GLTF file\n     * @param transform - The transform to store the data\n     */\n    static parseGLTF(document: Document, transform: Node3): void\n    {\n        const root = document.getRoot();\n        root.listNodes().forEach((node) => {\n            this.parseGLTFRecursive(node, transform);\n        });\n    }\n\n    /**\n     * Recusrively parses a node in the GLTF file and stores the data in a Node3 object\n     * \n     * @param node - The current node to parse in the GLTF file\n     * @param transform - The transform to store the data\n     */\n    private static parseGLTFRecursive(node: Node, parentTransform: Node3): void\n    {\n        let transform: Node3;\n\n        const gltfMesh = node.getMesh();\n        if(gltfMesh)\n        {\n            const primitives = gltfMesh.listPrimitives();\n\n            if(primitives.length == 1)\n            { \n                transform = this.parseGLTFPrimitive(primitives[0]);\n            }\n            else if(primitives.length > 1)\n            {\n                transform = new Node3();\n\n                primitives.forEach((primitive) => {\n                    transform.add(this.parseGLTFPrimitive(primitive));\n                });\n            }\n            else\n            {\n                transform = new Node3();\n            }\n        }\n        else\n        {\n            transform = new Node3();\n        }   \n\n        const position = node.getTranslation();\n        const rotation = node.getRotation();\n        const scale = node.getScale();\n\n        transform.position.set(position[0], position[1], position[2]);\n        transform.rotation.set(rotation[0], rotation[1], rotation[2], rotation[3]);\n        transform.scale.set(scale[0], scale[1], scale[2]);\n        \n        parentTransform.add(transform);\n    \n        node.listChildren().forEach((child) => {\n            this.parseGLTFRecursive(child, transform);\n        });\n    }\n\n    private static parseGLTFPrimitive(primitive: Primitive): Mesh3\n    {\n        const positions = primitive.getAttribute('POSITION');\n        const normals = primitive.getAttribute('NORMAL');\n        const colors = primitive.getAttribute('COLOR_0');\n        const uvs = primitive.getAttribute('TEXCOORD_0');\n        const indices = primitive.getIndices();\n        const material = primitive.getMaterial();\n\n        const mesh = new Mesh3();\n\n        if(positions)\n        {\n            mesh.setVertices(positions.getArray() as Float32Array);\n        }\n\n        if(normals)\n        {\n            mesh.setNormals(normals.getArray() as Float32Array);\n        }\n        \n        if(colors)\n        {\n            mesh.setColors(colors.getArray() as Float32Array);\n        }\n\n        if(uvs)\n        {\n            mesh.setTextureCoordinates(uvs.getArray() as Float32Array);\n        }\n\n        if(indices)\n        {\n            mesh.setIndices(indices.getArray() as Uint16Array);\n        }\n\n        if(material)\n        {\n            const materialColor = material.getBaseColorFactor();\n            mesh.material.setColor(new Color(materialColor[0], materialColor[1], materialColor[2], materialColor[3]));\n        }\n        \n        return mesh;\n    }\n}", "import type { Graph } from './graph.js';\nimport type { GraphNode } from './graph-node.js';\nimport type { GraphEdge } from './graph-edge.js';\n\nexport interface BaseEvent {\n\ttype: string;\n\t[attachment: string]: unknown;\n}\n\nexport interface GraphEvent extends BaseEvent {\n\ttarget: Graph<GraphNode>;\n}\n\nexport interface GraphNodeEvent extends BaseEvent {\n\ttarget: GraphNode;\n}\n\nexport interface GraphEdgeEvent extends BaseEvent {\n\ttarget: GraphEdge<GraphNode, GraphNode>;\n}\n\nexport type EventListener<E> = (event: E) => void;\n\nexport class EventDispatcher<T extends BaseEvent> {\n\tprivate _listeners = {} as Record<string, EventListener<T>[]>;\n\n\taddEventListener(type: string, listener: EventListener<T>): this {\n\t\tconst listeners = this._listeners;\n\n\t\tif (listeners[type] === undefined) {\n\t\t\tlisteners[type] = [] as EventListener<T>[];\n\t\t}\n\n\t\tif (listeners[type].indexOf(listener) === -1) {\n\t\t\tlisteners[type].push(listener);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\tremoveEventListener(type: string, listener: EventListener<T>): this {\n\t\tif (this._listeners === undefined) return this;\n\n\t\tconst listeners = this._listeners;\n\t\tconst listenerArray = listeners[type];\n\n\t\tif (listenerArray !== undefined) {\n\t\t\tconst index = listenerArray.indexOf(listener);\n\n\t\t\tif (index !== -1) {\n\t\t\t\tlistenerArray.splice(index, 1);\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t}\n\n\tdispatchEvent(event: T): this {\n\t\tif (this._listeners === undefined) return this;\n\n\t\tconst listeners = this._listeners;\n\t\tconst listenerArray = listeners[event.type];\n\n\t\tif (listenerArray !== undefined) {\n\t\t\t// Make a copy, in case listeners are removed while iterating.\n\t\t\tconst array = listenerArray.slice(0);\n\n\t\t\tfor (let i = 0, l = array.length; i < l; i++) {\n\t\t\t\tarray[i].call(this, event as T);\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t}\n\n\tdispose(): void {\n\t\tfor (const key in this._listeners) {\n\t\t\tdelete this._listeners[key];\n\t\t}\n\t}\n}\n", "import { EventDispatcher, GraphEdgeEvent } from './event-dispatcher.js';\nimport { GraphNode } from './graph-node.js';\n\n/**\n * Represents a connection between two {@link GraphNode} resources in a {@link Graph}.\n *\n * The left node is considered the owner, and the right node the resource. The\n * owner is responsible for being able find and remove a reference to a resource, given\n * that link. The resource does not hold a reference to the link or to the owner,\n * although that reverse lookup can be done on the graph.\n */\nexport class GraphEdge<Parent extends GraphNode, Child extends GraphNode> extends EventDispatcher<GraphEdgeEvent> {\n\tprivate _disposed = false;\n\n\tconstructor(\n\t\tprivate readonly _name: string,\n\t\tprivate readonly _parent: Parent,\n\t\tprivate _child: Child,\n\t\tprivate _attributes: Record<string, unknown> = {}\n\t) {\n\t\tsuper();\n\t\tif (!_parent.isOnGraph(_child)) {\n\t\t\tthrow new Error('Cannot connect disconnected graphs.');\n\t\t}\n\t}\n\n\t/** Name. */\n\tgetName(): string {\n\t\treturn this._name;\n\t}\n\n\t/** Owner node. */\n\tgetParent(): Parent {\n\t\treturn this._parent;\n\t}\n\n\t/** Resource node. */\n\tgetChild(): Child {\n\t\treturn this._child;\n\t}\n\n\t/**\n\t * Sets the child node.\n\t *\n\t * @internal Only {@link Graph} implementations may safely call this method directly. Use\n\t * \t{@link Property.swap} or {@link Graph.swapChild} instead.\n\t */\n\tsetChild(child: Child): this {\n\t\tthis._child = child;\n\t\treturn this;\n\t}\n\n\t/** Attributes of the graph node relationship. */\n\tgetAttributes(): Record<string, unknown> {\n\t\treturn this._attributes;\n\t}\n\n\t/** Destroys a (currently intact) edge, updating both the graph and the owner. */\n\tdispose(): void {\n\t\tif (this._disposed) return;\n\t\tthis._disposed = true;\n\t\tthis.dispatchEvent({ type: 'dispose', target: this });\n\t\tsuper.dispose();\n\t}\n\n\t/** Whether this link has been destroyed. */\n\tisDisposed(): boolean {\n\t\treturn this._disposed;\n\t}\n}\n", "import { EventDispatcher, GraphEdgeEvent, GraphEvent, GraphNodeEvent } from './event-dispatcher.js';\nimport { GraphEdge } from './graph-edge.js';\nimport { GraphNode } from './graph-node.js';\n\n/**\n * A graph manages a network of {@link GraphNode} nodes, connected\n * by {@link @Link} edges.\n */\nexport class Graph<T extends GraphNode> extends EventDispatcher<GraphEvent | GraphNodeEvent | GraphEdgeEvent> {\n\tprivate _emptySet: Set<GraphEdge<T, T>> = new Set();\n\n\tprivate _edges: Set<GraphEdge<T, T>> = new Set();\n\tprivate _parentEdges: Map<T, Set<GraphEdge<T, T>>> = new Map();\n\tprivate _childEdges: Map<T, Set<GraphEdge<T, T>>> = new Map();\n\n\t/** Returns a list of all parent->child edges on this graph. */\n\tpublic listEdges(): GraphEdge<T, T>[] {\n\t\treturn Array.from(this._edges);\n\t}\n\n\t/** Returns a list of all edges on the graph having the given node as their child. */\n\tpublic listParentEdges(node: T): GraphEdge<T, T>[] {\n\t\treturn Array.from(this._childEdges.get(node) || this._emptySet);\n\t}\n\n\t/** Returns a list of parent nodes for the given child node. */\n\tpublic listParents(node: T): T[] {\n\t\treturn this.listParentEdges(node).map((edge) => edge.getParent());\n\t}\n\n\t/** Returns a list of all edges on the graph having the given node as their parent. */\n\tpublic listChildEdges(node: T): GraphEdge<T, T>[] {\n\t\treturn Array.from(this._parentEdges.get(node) || this._emptySet);\n\t}\n\n\t/** Returns a list of child nodes for the given parent node. */\n\tpublic listChildren(node: T): T[] {\n\t\treturn this.listChildEdges(node).map((edge) => edge.getChild());\n\t}\n\n\tpublic disconnectParents(node: T, filter?: (n: T) => boolean): this {\n\t\tlet edges = this.listParentEdges(node);\n\t\tif (filter) {\n\t\t\tedges = edges.filter((edge) => filter(edge.getParent()));\n\t\t}\n\t\tedges.forEach((edge) => edge.dispose());\n\t\treturn this;\n\t}\n\n\t/**\n\t * Creates a {@link GraphEdge} connecting two {@link GraphNode} instances. Edge is returned\n\t * for the caller to store.\n\t * @param a Owner\n\t * @param b Resource\n\t */\n\tpublic createEdge<A extends T, B extends T>(\n\t\tname: string,\n\t\ta: A,\n\t\tb: B,\n\t\tattributes?: Record<string, unknown>\n\t): GraphEdge<A, B> {\n\t\treturn this._registerEdge(new GraphEdge(name, a, b, attributes)) as GraphEdge<A, B>;\n\t}\n\n\t/**********************************************************************************************\n\t * Internal.\n\t */\n\n\t/** @hidden */\n\tprivate _registerEdge(edge: GraphEdge<T, T>): GraphEdge<T, T> {\n\t\tthis._edges.add(edge);\n\n\t\tconst parent = edge.getParent();\n\t\tif (!this._parentEdges.has(parent)) this._parentEdges.set(parent, new Set());\n\t\tthis._parentEdges.get(parent)!.add(edge);\n\n\t\tconst child = edge.getChild();\n\t\tif (!this._childEdges.has(child)) this._childEdges.set(child, new Set());\n\t\tthis._childEdges.get(child)!.add(edge);\n\n\t\tedge.addEventListener('dispose', () => this._removeEdge(edge));\n\t\treturn edge;\n\t}\n\n\t/**\n\t * Removes the {@link GraphEdge} from the {@link Graph}. This method should only\n\t * be invoked by the onDispose() listener created in {@link _registerEdge()}. The\n\t * public method of removing an edge is {@link GraphEdge.dispose}.\n\t */\n\tprivate _removeEdge(edge: GraphEdge<T, T>): this {\n\t\tthis._edges.delete(edge);\n\t\tthis._parentEdges.get(edge.getParent())!.delete(edge);\n\t\tthis._childEdges.get(edge.getChild())!.delete(edge);\n\t\treturn this;\n\t}\n}\n", "import type { Ref, RefMap } from './constants.js';\nimport { GraphEdge } from './graph-edge.js';\n\nexport function isRef(value: Ref | unknown): boolean {\n\treturn value instanceof GraphEdge;\n}\n\nexport function isRefList(value: Ref[] | unknown): boolean {\n\treturn Array.isArray(value) && value[0] instanceof GraphEdge;\n}\n\nexport function isRefMap(value: RefMap | unknown): boolean {\n\treturn !!(isPlainObject(value) && getFirstValue(value) instanceof GraphEdge);\n}\n\nfunction getFirstValue(value: Record<string, unknown>): unknown {\n\tfor (const key in value) {\n\t\treturn value[key];\n\t}\n}\n\nfunction isPlainObject(value: unknown): value is Record<string, unknown> {\n\treturn Boolean(value) && Object.getPrototypeOf(value) === Object.prototype;\n}\n", "/* eslint-disable @typescript-eslint/no-explicit-any */\n/* eslint-disable @typescript-eslint/ban-types */\nimport { LiteralKeys, Nullable, Ref, RefMap, RefKeys, RefListKeys, RefMapKeys } from './constants.js';\nimport { BaseEvent, EventDispatcher, GraphNodeEvent } from './event-dispatcher.js';\nimport { Graph } from './graph.js';\nimport { GraphEdge } from './graph-edge.js';\nimport { isRef, isRefList, isRefMap } from './utils.js';\n\n// References:\n// - https://stackoverflow.com/a/70163679/1314762\n// - https://stackoverflow.com/a/70201805/1314762\n\ntype GraphNodeAttributesInternal<Parent extends GraphNode, Attributes extends {}> = {\n\t[Key in keyof Attributes]: Attributes[Key] extends GraphNode\n\t\t? GraphEdge<Parent, Attributes[Key]>\n\t\t: Attributes[Key] extends GraphNode[]\n\t\t? GraphEdge<Parent, Attributes[Key][number]>[]\n\t\t: Attributes[Key] extends { [key: string]: GraphNode }\n\t\t? Record<string, GraphEdge<Parent, Attributes[Key][string]>>\n\t\t: Attributes[Key];\n};\n\nexport const $attributes = Symbol('attributes');\nexport const $immutableKeys = Symbol('immutableKeys');\n\n/**\n * Represents a node in a {@link Graph}.\n */\nexport abstract class GraphNode<Attributes extends {} = {}> extends EventDispatcher<GraphNodeEvent> {\n\tprivate _disposed = false;\n\n\t/**\n\t * Internal graph used to search and maintain references.\n\t * @hidden\n\t */\n\tprotected readonly graph: Graph<GraphNode>;\n\n\t/**\n\t * Attributes (literal values and GraphNode references) associated with this instance. For each\n\t * GraphNode reference, the attributes stores a {@link GraphEdge}. List and Map references are\n\t * stored as arrays and dictionaries of edges.\n\t * @internal\n\t */\n\tprotected readonly [$attributes]: GraphNodeAttributesInternal<this, Attributes>;\n\n\t/**\n\t * Attributes included with `getDefaultAttributes` are considered immutable, and cannot be\n\t * modifed by `.setRef()`, `.copy()`, or other GraphNode methods. Both the edges and the\n\t * properties will be disposed with the parent GraphNode.\n\t *\n\t * Currently, only single-edge references (getRef/setRef) are supported as immutables.\n\t *\n\t * @internal\n\t */\n\tprotected readonly [$immutableKeys]: Set<string>;\n\n\tconstructor(graph: Graph<GraphNode>) {\n\t\tsuper();\n\t\tthis.graph = graph;\n\t\tthis[$immutableKeys] = new Set();\n\t\tthis[$attributes] = this._createAttributes();\n\t}\n\n\t/**\n\t * Returns default attributes for the graph node. Subclasses having any attributes (either\n\t * literal values or references to other graph nodes) must override this method. Literal\n\t * attributes should be given their default values, if any. References should generally be\n\t * initialized as empty (Ref  null, RefList  [], RefMap  {}) and then modified by setters.\n\t *\n\t * Any single-edge references (setRef) returned by this method will be considered immutable,\n\t * to be owned by and disposed with the parent node. Multi-edge references (addRef, removeRef,\n\t * setRefMap) cannot be returned as default attributes.\n\t */\n\tprotected getDefaults(): Nullable<Attributes> {\n\t\treturn {} as Nullable<Attributes>;\n\t}\n\n\t/**\n\t * Constructs and returns an object used to store a graph nodes attributes. Compared to the\n\t * default Attributes interface, this has two distinctions:\n\t *\n\t * 1. Slots for GraphNode<T> objects are replaced with slots for GraphEdge<this, GraphNode<T>>\n\t * 2. GraphNode<T> objects provided as defaults are considered immutable\n\t *\n\t * @internal\n\t */\n\tprivate _createAttributes(): GraphNodeAttributesInternal<this, Attributes> {\n\t\tconst defaultAttributes = this.getDefaults();\n\t\tconst attributes = {} as GraphNodeAttributesInternal<this, Attributes>;\n\t\tfor (const key in defaultAttributes) {\n\t\t\tconst value = defaultAttributes[key] as any;\n\t\t\tif (value instanceof GraphNode) {\n\t\t\t\tconst ref = this.graph.createEdge(key, this, value);\n\t\t\t\tref.addEventListener('dispose', () => value.dispose());\n\t\t\t\tthis[$immutableKeys].add(key);\n\t\t\t\tattributes[key] = ref as any;\n\t\t\t} else {\n\t\t\t\tattributes[key] = value as any;\n\t\t\t}\n\t\t}\n\t\treturn attributes;\n\t}\n\n\t/** @internal Returns true if two nodes are on the same {@link Graph}. */\n\tpublic isOnGraph(other: GraphNode): boolean {\n\t\treturn this.graph === other.graph;\n\t}\n\n\t/** Returns true if the node has been permanently removed from the graph. */\n\tpublic isDisposed(): boolean {\n\t\treturn this._disposed;\n\t}\n\n\t/**\n\t * Removes both inbound references to and outbound references from this object. At the end\n\t * of the process the object holds no references, and nothing holds references to it. A\n\t * disposed object is not reusable.\n\t */\n\tpublic dispose(): void {\n\t\tif (this._disposed) return;\n\t\tthis.graph.listChildEdges(this).forEach((edge) => edge.dispose());\n\t\tthis.graph.disconnectParents(this);\n\t\tthis._disposed = true;\n\t\tthis.dispatchEvent({ type: 'dispose' });\n\t}\n\n\t/**\n\t * Removes all inbound references to this object. At the end of the process the object is\n\t * considered 'detached': it may hold references to child resources, but nothing holds\n\t * references to it. A detached object may be re-attached.\n\t */\n\tpublic detach(): this {\n\t\tthis.graph.disconnectParents(this);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Transfers this object's references from the old node to the new one. The old node is fully\n\t * detached from this parent at the end of the process.\n\t *\n\t * @hidden\n\t */\n\tpublic swap(old: GraphNode, replacement: GraphNode): this {\n\t\tfor (const attribute in this[$attributes]) {\n\t\t\tconst value = this[$attributes][attribute] as Ref | Ref[] | RefMap;\n\t\t\tif (isRef(value)) {\n\t\t\t\tconst ref = value as Ref;\n\t\t\t\tif (ref.getChild() === old) {\n\t\t\t\t\tthis.setRef(attribute as any, replacement, ref.getAttributes());\n\t\t\t\t}\n\t\t\t} else if (isRefList(value)) {\n\t\t\t\tconst refs = value as Ref[];\n\t\t\t\tconst ref = refs.find((ref) => ref.getChild() === old);\n\t\t\t\tif (ref) {\n\t\t\t\t\tconst refAttributes = ref.getAttributes();\n\t\t\t\t\tthis.removeRef(attribute as any, old).addRef(attribute as any, replacement, refAttributes);\n\t\t\t\t}\n\t\t\t} else if (isRefMap(value)) {\n\t\t\t\tconst refMap = value as RefMap;\n\t\t\t\tfor (const key in refMap) {\n\t\t\t\t\tconst ref = refMap[key];\n\t\t\t\t\tif (ref.getChild() === old) {\n\t\t\t\t\t\tthis.setRefMap(attribute as any, key, replacement, ref.getAttributes());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**********************************************************************************************\n\t * Literal attributes.\n\t */\n\n\t/** @hidden */\n\tprotected get<K extends LiteralKeys<Attributes>>(attribute: K): Attributes[K] {\n\t\treturn this[$attributes][attribute] as Attributes[K];\n\t}\n\n\t/** @hidden */\n\tprotected set<K extends LiteralKeys<Attributes>>(attribute: K, value: Attributes[K]): this {\n\t\t(this[$attributes][attribute] as Attributes[K]) = value;\n\t\treturn this.dispatchEvent({ type: 'change', attribute });\n\t}\n\n\t/**********************************************************************************************\n\t * Ref: 1:1 graph node references.\n\t */\n\n\t/** @hidden */\n\tprotected getRef<K extends RefKeys<Attributes>>(attribute: K): (GraphNode & Attributes[K]) | null {\n\t\tconst ref = this[$attributes][attribute] as Ref;\n\t\treturn ref ? (ref.getChild() as GraphNode & Attributes[K]) : null;\n\t}\n\n\t/** @hidden */\n\tprotected setRef<K extends RefKeys<Attributes>>(\n\t\tattribute: K,\n\t\tvalue: (GraphNode & Attributes[K]) | null,\n\t\tattributes?: Record<string, unknown>\n\t): this {\n\t\tif (this[$immutableKeys].has(attribute as string)) {\n\t\t\tthrow new Error(`Cannot overwrite immutable attribute, \"${attribute as string}\".`);\n\t\t}\n\n\t\tconst prevRef = this[$attributes][attribute] as Ref;\n\t\tif (prevRef) prevRef.dispose(); // TODO(cleanup): Possible duplicate event.\n\n\t\tif (!value) return this;\n\n\t\tconst ref = this.graph.createEdge(attribute as string, this, value, attributes);\n\t\tref.addEventListener('dispose', () => {\n\t\t\tdelete this[$attributes][attribute];\n\t\t\tthis.dispatchEvent({ type: 'change', attribute });\n\t\t});\n\t\t(this[$attributes][attribute] as Ref) = ref;\n\n\t\treturn this.dispatchEvent({ type: 'change', attribute });\n\t}\n\n\t/**********************************************************************************************\n\t * RefList: 1:many graph node references.\n\t */\n\n\t/** @hidden */\n\tprotected listRefs<K extends RefListKeys<Attributes>>(attribute: K): GraphNode[] & Attributes[K] {\n\t\tconst refs = this[$attributes][attribute] as Ref[];\n\t\treturn refs.map((ref) => ref.getChild()) as GraphNode[] & Attributes[K];\n\t}\n\n\t/** @hidden */\n\tprotected addRef<K extends RefListKeys<Attributes>>(\n\t\tattribute: K,\n\t\tvalue: GraphNode & Attributes[K][keyof Attributes[K]],\n\t\tattributes?: Record<string, unknown>\n\t): this {\n\t\tconst ref = this.graph.createEdge(attribute as string, this, value, attributes);\n\n\t\tconst refs = this[$attributes][attribute] as Ref[];\n\t\trefs.push(ref);\n\n\t\tref.addEventListener('dispose', () => {\n\t\t\tlet index;\n\t\t\twhile ((index = refs.indexOf(ref)) !== -1) {\n\t\t\t\trefs.splice(index, 1);\n\t\t\t}\n\t\t\tthis.dispatchEvent({ type: 'change', attribute });\n\t\t});\n\n\t\treturn this.dispatchEvent({ type: 'change', attribute });\n\t}\n\n\t/** @hidden */\n\tprotected removeRef<K extends RefListKeys<Attributes>>(\n\t\tattribute: K,\n\t\tvalue: GraphNode & Attributes[K][keyof Attributes[K]]\n\t): this {\n\t\tconst refs = this[$attributes][attribute] as Ref[];\n\t\tconst pruned = refs.filter((ref) => ref.getChild() === value);\n\t\tpruned.forEach((ref) => ref.dispose()); // TODO(cleanup): Possible duplicate event.\n\t\treturn this;\n\t}\n\n\t/**********************************************************************************************\n\t * RefMap: Named 1:many (map) graph node references.\n\t */\n\n\t/** @hidden */\n\tprotected listRefMapKeys<K extends RefMapKeys<Attributes>>(key: K): string[] {\n\t\treturn Object.keys(this[$attributes][key] as any);\n\t}\n\n\t/** @hidden */\n\tprotected listRefMapValues<K extends RefMapKeys<Attributes>>(\n\t\tkey: K\n\t): GraphNode[] & Attributes[K][keyof Attributes[K]][] {\n\t\treturn Object.values(this[$attributes][key] as any).map((ref: any) => ref.getChild());\n\t}\n\n\t/** @hidden */\n\tprotected getRefMap<K extends RefMapKeys<Attributes>, SK extends keyof Attributes[K]>(\n\t\tattribute: K,\n\t\tkey: SK\n\t): (GraphNode & Attributes[K][SK]) | null {\n\t\tconst refMap = this[$attributes][attribute] as any;\n\t\treturn refMap[key] ? refMap[key].getChild() : null;\n\t}\n\n\t/** @hidden */\n\tprotected setRefMap<K extends RefMapKeys<Attributes>, SK extends keyof Attributes[K]>(\n\t\tattribute: K,\n\t\tkey: SK,\n\t\tvalue: (GraphNode & Attributes[K][SK]) | null,\n\t\tmetadata?: Record<string, unknown>\n\t): this {\n\t\tconst refMap = this[$attributes][attribute] as any;\n\n\t\tconst prevRef = refMap[key];\n\t\tif (prevRef) prevRef.dispose(); // TODO(cleanup): Possible duplicate event.\n\n\t\tif (!value) return this;\n\n\t\tmetadata = Object.assign(metadata || {}, { key: key });\n\t\tconst ref = this.graph.createEdge(attribute as string, this, value, { ...metadata, key });\n\t\tref.addEventListener('dispose', () => {\n\t\t\tdelete refMap[key];\n\t\t\tthis.dispatchEvent({ type: 'change', attribute, key });\n\t\t});\n\t\trefMap[key] = ref;\n\n\t\treturn this.dispatchEvent({ type: 'change', attribute, key });\n\t}\n\n\t/**********************************************************************************************\n\t * Events.\n\t */\n\n\t/**\n\t * Dispatches an event on the GraphNode, and on the associated\n\t * Graph. Event types on the graph are prefixed, `\"node:[type]\"`.\n\t */\n\tdispatchEvent(event: BaseEvent): this {\n\t\tsuper.dispatchEvent({ ...event, target: this });\n\t\tthis.graph.dispatchEvent({ ...event, target: this, type: `node:${event.type}` });\n\t\treturn this;\n\t}\n}\n", "// Injected at compile time, from $npm_package_version.\ndeclare const PACKAGE_VERSION: string;\n\n/**\n * Current version of the package.\n * @hidden\n */\nexport const VERSION = `v${PACKAGE_VERSION}`;\n\n/** @internal */\nexport const NAME = '@gltf-transform/core';\n\n/**\n * Interface allowing Accessor setter/getter methods to be used interchangeably with gl-matrix\n * arrays or with three.js math objects' fromArray/toArray methods. For example, THREE.Vector2,\n * THREE.Vector3, THREE.Vector4, THREE.Quaternion, THREE.Matrix3, THREE.Matrix4, and THREE.Color.\n *\n * @internal\n */\nexport interface ArrayProxy {\n\t/** Sets the value of the object from an array of values. */\n\tfromArray(array: number[]): ArrayProxy;\n\t/** Writes the value of the object into the given array. */\n\ttoArray(array: number[]): number[];\n}\n\n/**\n * TypeScript utility for nullable types.\n * @hidden\n */\nexport type Nullable<T> = { [P in keyof T]: T[P] | null };\n\n/**\n * 2-dimensional vector.\n * @hidden\n */\nexport type vec2 = [number, number];\n\n/**\n * 3-dimensional vector.\n * @hidden\n */\nexport type vec3 = [number, number, number];\n\n/**\n * 4-dimensional vector, e.g. RGBA or a quaternion.\n * @hidden\n */\nexport type vec4 = [number, number, number, number];\n\n// prettier-ignore\n/**\n * 3x3 matrix, e.g. an affine transform of a 2D vector.\n * @hidden\n */\nexport type mat3 = [\n\tnumber, number, number,\n\tnumber, number, number,\n\tnumber, number, number,\n];\n\n// prettier-ignore\n/**\n * 4x4 matrix, e.g. an affine transform of a 3D vector.\n * @hidden\n */\nexport type mat4 = [\n\tnumber, number, number, number,\n\tnumber, number, number, number,\n\tnumber, number, number, number,\n\tnumber, number, number, number,\n];\n\n/** @hidden */\nexport type bbox = { min: vec3; max: vec3 };\n\n/** @hidden */\nexport const GLB_BUFFER = '@glb.bin';\n\n/**\n * Abstraction representing any one of the typed array classes supported by glTF and JavaScript.\n * @hidden\n */\nexport type TypedArray = Float32Array | Uint32Array | Uint16Array | Uint8Array | Int16Array | Int8Array;\n\n/**\n * Abstraction representing the typed array constructors supported by glTF and JavaScript.\n * @hidden\n */\nexport type TypedArrayConstructor =\n\t| Float32ArrayConstructor\n\t| Uint32ArrayConstructor\n\t| Uint16ArrayConstructor\n\t| Uint8ArrayConstructor\n\t| Int16ArrayConstructor\n\t| Int8ArrayConstructor;\n\n/** String IDs for core {@link Property} types. */\nexport enum PropertyType {\n\tACCESSOR = 'Accessor',\n\tANIMATION = 'Animation',\n\tANIMATION_CHANNEL = 'AnimationChannel',\n\tANIMATION_SAMPLER = 'AnimationSampler',\n\tBUFFER = 'Buffer',\n\tCAMERA = 'Camera',\n\tMATERIAL = 'Material',\n\tMESH = 'Mesh',\n\tPRIMITIVE = 'Primitive',\n\tPRIMITIVE_TARGET = 'PrimitiveTarget',\n\tNODE = 'Node',\n\tROOT = 'Root',\n\tSCENE = 'Scene',\n\tSKIN = 'Skin',\n\tTEXTURE = 'Texture',\n\tTEXTURE_INFO = 'TextureInfo',\n}\n\n/** Vertex layout method. */\nexport enum VertexLayout {\n\t/**\n\t * Stores vertex attributes in a single buffer view per mesh primitive. Interleaving vertex\n\t * data may improve performance by reducing page-thrashing in GPU memory.\n\t */\n\tINTERLEAVED = 'interleaved',\n\n\t/**\n\t * Stores each vertex attribute in a separate buffer view. May decrease performance by causing\n\t * page-thrashing in GPU memory. Some 3D engines may prefer this layout, e.g. for simplicity.\n\t */\n\tSEPARATE = 'separate',\n}\n\n/** Accessor usage. */\nexport enum BufferViewUsage {\n\tARRAY_BUFFER = 'ARRAY_BUFFER',\n\tELEMENT_ARRAY_BUFFER = 'ELEMENT_ARRAY_BUFFER',\n\tINVERSE_BIND_MATRICES = 'INVERSE_BIND_MATRICES',\n\tOTHER = 'OTHER',\n\tSPARSE = 'SPARSE',\n}\n\n/** Texture channels. */\nexport enum TextureChannel {\n\tR = 0x1000,\n\tG = 0x0100,\n\tB = 0x0010,\n\tA = 0x0001,\n}\n\nexport enum Format {\n\tGLTF = 'GLTF',\n\tGLB = 'GLB',\n}\n\nexport const ComponentTypeToTypedArray = {\n\t'5120': Int8Array,\n\t'5121': Uint8Array,\n\t'5122': Int16Array,\n\t'5123': Uint16Array,\n\t'5125': Uint32Array,\n\t'5126': Float32Array,\n};\n", "/**\n * Common utilities\n * @module glMatrix\n */\n// Configuration Constants\nexport var EPSILON = 0.000001;\nexport var ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;\nexport var RANDOM = Math.random;\n/**\n * Sets the type of array used when creating new vectors and matrices\n *\n * @param {Float32ArrayConstructor | ArrayConstructor} type Array type, such as Float32Array or Array\n */\n\nexport function setMatrixArrayType(type) {\n  ARRAY_TYPE = type;\n}\nvar degree = Math.PI / 180;\n/**\n * Convert Degree To Radian\n *\n * @param {Number} a Angle in Degrees\n */\n\nexport function toRadian(a) {\n  return a * degree;\n}\n/**\n * Tests whether or not the arguments have approximately the same value, within an absolute\n * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less\n * than or equal to 1.0, and a relative tolerance is used for larger values)\n *\n * @param {Number} a The first number to test.\n * @param {Number} b The second number to test.\n * @returns {Boolean} True if the numbers are approximately equal, false otherwise.\n */\n\nexport function equals(a, b) {\n  return Math.abs(a - b) <= EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));\n}\nif (!Math.hypot) Math.hypot = function () {\n  var y = 0,\n      i = arguments.length;\n\n  while (i--) {\n    y += arguments[i] * arguments[i];\n  }\n\n  return Math.sqrt(y);\n};", "import * as glMatrix from \"./common.js\";\n/**\n * 3 Dimensional Vector\n * @module vec3\n */\n\n/**\n * Creates a new, empty vec3\n *\n * @returns {vec3} a new 3D vector\n */\n\nexport function create() {\n  var out = new glMatrix.ARRAY_TYPE(3);\n\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n  }\n\n  return out;\n}\n/**\n * Creates a new vec3 initialized with values from an existing vector\n *\n * @param {ReadonlyVec3} a vector to clone\n * @returns {vec3} a new 3D vector\n */\n\nexport function clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(3);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  return out;\n}\n/**\n * Calculates the length of a vec3\n *\n * @param {ReadonlyVec3} a vector to calculate length of\n * @returns {Number} length of a\n */\n\nexport function length(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  return Math.hypot(x, y, z);\n}\n/**\n * Creates a new vec3 initialized with the given values\n *\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @returns {vec3} a new 3D vector\n */\n\nexport function fromValues(x, y, z) {\n  var out = new glMatrix.ARRAY_TYPE(3);\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  return out;\n}\n/**\n * Copy the values from one vec3 to another\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the source vector\n * @returns {vec3} out\n */\n\nexport function copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  return out;\n}\n/**\n * Set the components of a vec3 to the given values\n *\n * @param {vec3} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @returns {vec3} out\n */\n\nexport function set(out, x, y, z) {\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  return out;\n}\n/**\n * Adds two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  return out;\n}\n/**\n * Subtracts vector b from vector a\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  return out;\n}\n/**\n * Multiplies two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function multiply(out, a, b) {\n  out[0] = a[0] * b[0];\n  out[1] = a[1] * b[1];\n  out[2] = a[2] * b[2];\n  return out;\n}\n/**\n * Divides two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function divide(out, a, b) {\n  out[0] = a[0] / b[0];\n  out[1] = a[1] / b[1];\n  out[2] = a[2] / b[2];\n  return out;\n}\n/**\n * Math.ceil the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to ceil\n * @returns {vec3} out\n */\n\nexport function ceil(out, a) {\n  out[0] = Math.ceil(a[0]);\n  out[1] = Math.ceil(a[1]);\n  out[2] = Math.ceil(a[2]);\n  return out;\n}\n/**\n * Math.floor the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to floor\n * @returns {vec3} out\n */\n\nexport function floor(out, a) {\n  out[0] = Math.floor(a[0]);\n  out[1] = Math.floor(a[1]);\n  out[2] = Math.floor(a[2]);\n  return out;\n}\n/**\n * Returns the minimum of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function min(out, a, b) {\n  out[0] = Math.min(a[0], b[0]);\n  out[1] = Math.min(a[1], b[1]);\n  out[2] = Math.min(a[2], b[2]);\n  return out;\n}\n/**\n * Returns the maximum of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function max(out, a, b) {\n  out[0] = Math.max(a[0], b[0]);\n  out[1] = Math.max(a[1], b[1]);\n  out[2] = Math.max(a[2], b[2]);\n  return out;\n}\n/**\n * Math.round the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to round\n * @returns {vec3} out\n */\n\nexport function round(out, a) {\n  out[0] = Math.round(a[0]);\n  out[1] = Math.round(a[1]);\n  out[2] = Math.round(a[2]);\n  return out;\n}\n/**\n * Scales a vec3 by a scalar number\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {vec3} out\n */\n\nexport function scale(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  return out;\n}\n/**\n * Adds two vec3's after scaling the second operand by a scalar value\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @param {Number} scale the amount to scale b by before adding\n * @returns {vec3} out\n */\n\nexport function scaleAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  return out;\n}\n/**\n * Calculates the euclidian distance between two vec3's\n *\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {Number} distance between a and b\n */\n\nexport function distance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  return Math.hypot(x, y, z);\n}\n/**\n * Calculates the squared euclidian distance between two vec3's\n *\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {Number} squared distance between a and b\n */\n\nexport function squaredDistance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  return x * x + y * y + z * z;\n}\n/**\n * Calculates the squared length of a vec3\n *\n * @param {ReadonlyVec3} a vector to calculate squared length of\n * @returns {Number} squared length of a\n */\n\nexport function squaredLength(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  return x * x + y * y + z * z;\n}\n/**\n * Negates the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to negate\n * @returns {vec3} out\n */\n\nexport function negate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  out[2] = -a[2];\n  return out;\n}\n/**\n * Returns the inverse of the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to invert\n * @returns {vec3} out\n */\n\nexport function inverse(out, a) {\n  out[0] = 1.0 / a[0];\n  out[1] = 1.0 / a[1];\n  out[2] = 1.0 / a[2];\n  return out;\n}\n/**\n * Normalize a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to normalize\n * @returns {vec3} out\n */\n\nexport function normalize(out, a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  var len = x * x + y * y + z * z;\n\n  if (len > 0) {\n    //TODO: evaluate use of glm_invsqrt here?\n    len = 1 / Math.sqrt(len);\n  }\n\n  out[0] = a[0] * len;\n  out[1] = a[1] * len;\n  out[2] = a[2] * len;\n  return out;\n}\n/**\n * Calculates the dot product of two vec3's\n *\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {Number} dot product of a and b\n */\n\nexport function dot(a, b) {\n  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n}\n/**\n * Computes the cross product of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function cross(out, a, b) {\n  var ax = a[0],\n      ay = a[1],\n      az = a[2];\n  var bx = b[0],\n      by = b[1],\n      bz = b[2];\n  out[0] = ay * bz - az * by;\n  out[1] = az * bx - ax * bz;\n  out[2] = ax * by - ay * bx;\n  return out;\n}\n/**\n * Performs a linear interpolation between two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec3} out\n */\n\nexport function lerp(out, a, b, t) {\n  var ax = a[0];\n  var ay = a[1];\n  var az = a[2];\n  out[0] = ax + t * (b[0] - ax);\n  out[1] = ay + t * (b[1] - ay);\n  out[2] = az + t * (b[2] - az);\n  return out;\n}\n/**\n * Performs a hermite interpolation with two control points\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @param {ReadonlyVec3} c the third operand\n * @param {ReadonlyVec3} d the fourth operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec3} out\n */\n\nexport function hermite(out, a, b, c, d, t) {\n  var factorTimes2 = t * t;\n  var factor1 = factorTimes2 * (2 * t - 3) + 1;\n  var factor2 = factorTimes2 * (t - 2) + t;\n  var factor3 = factorTimes2 * (t - 1);\n  var factor4 = factorTimes2 * (3 - 2 * t);\n  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;\n  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;\n  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;\n  return out;\n}\n/**\n * Performs a bezier interpolation with two control points\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @param {ReadonlyVec3} c the third operand\n * @param {ReadonlyVec3} d the fourth operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec3} out\n */\n\nexport function bezier(out, a, b, c, d, t) {\n  var inverseFactor = 1 - t;\n  var inverseFactorTimesTwo = inverseFactor * inverseFactor;\n  var factorTimes2 = t * t;\n  var factor1 = inverseFactorTimesTwo * inverseFactor;\n  var factor2 = 3 * t * inverseFactorTimesTwo;\n  var factor3 = 3 * factorTimes2 * inverseFactor;\n  var factor4 = factorTimes2 * t;\n  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;\n  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;\n  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;\n  return out;\n}\n/**\n * Generates a random vector with the given scale\n *\n * @param {vec3} out the receiving vector\n * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned\n * @returns {vec3} out\n */\n\nexport function random(out, scale) {\n  scale = scale || 1.0;\n  var r = glMatrix.RANDOM() * 2.0 * Math.PI;\n  var z = glMatrix.RANDOM() * 2.0 - 1.0;\n  var zScale = Math.sqrt(1.0 - z * z) * scale;\n  out[0] = Math.cos(r) * zScale;\n  out[1] = Math.sin(r) * zScale;\n  out[2] = z * scale;\n  return out;\n}\n/**\n * Transforms the vec3 with a mat4.\n * 4th vector component is implicitly '1'\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to transform\n * @param {ReadonlyMat4} m matrix to transform with\n * @returns {vec3} out\n */\n\nexport function transformMat4(out, a, m) {\n  var x = a[0],\n      y = a[1],\n      z = a[2];\n  var w = m[3] * x + m[7] * y + m[11] * z + m[15];\n  w = w || 1.0;\n  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;\n  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;\n  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;\n  return out;\n}\n/**\n * Transforms the vec3 with a mat3.\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to transform\n * @param {ReadonlyMat3} m the 3x3 matrix to transform with\n * @returns {vec3} out\n */\n\nexport function transformMat3(out, a, m) {\n  var x = a[0],\n      y = a[1],\n      z = a[2];\n  out[0] = x * m[0] + y * m[3] + z * m[6];\n  out[1] = x * m[1] + y * m[4] + z * m[7];\n  out[2] = x * m[2] + y * m[5] + z * m[8];\n  return out;\n}\n/**\n * Transforms the vec3 with a quat\n * Can also be used for dual quaternions. (Multiply it with the real part)\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to transform\n * @param {ReadonlyQuat} q quaternion to transform with\n * @returns {vec3} out\n */\n\nexport function transformQuat(out, a, q) {\n  // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed\n  var qx = q[0],\n      qy = q[1],\n      qz = q[2],\n      qw = q[3];\n  var x = a[0],\n      y = a[1],\n      z = a[2]; // var qvec = [qx, qy, qz];\n  // var uv = vec3.cross([], qvec, a);\n\n  var uvx = qy * z - qz * y,\n      uvy = qz * x - qx * z,\n      uvz = qx * y - qy * x; // var uuv = vec3.cross([], qvec, uv);\n\n  var uuvx = qy * uvz - qz * uvy,\n      uuvy = qz * uvx - qx * uvz,\n      uuvz = qx * uvy - qy * uvx; // vec3.scale(uv, uv, 2 * w);\n\n  var w2 = qw * 2;\n  uvx *= w2;\n  uvy *= w2;\n  uvz *= w2; // vec3.scale(uuv, uuv, 2);\n\n  uuvx *= 2;\n  uuvy *= 2;\n  uuvz *= 2; // return vec3.add(out, a, vec3.add(out, uv, uuv));\n\n  out[0] = x + uvx + uuvx;\n  out[1] = y + uvy + uuvy;\n  out[2] = z + uvz + uuvz;\n  return out;\n}\n/**\n * Rotate a 3D vector around the x-axis\n * @param {vec3} out The receiving vec3\n * @param {ReadonlyVec3} a The vec3 point to rotate\n * @param {ReadonlyVec3} b The origin of the rotation\n * @param {Number} rad The angle of rotation in radians\n * @returns {vec3} out\n */\n\nexport function rotateX(out, a, b, rad) {\n  var p = [],\n      r = []; //Translate point to the origin\n\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2]; //perform rotation\n\n  r[0] = p[0];\n  r[1] = p[1] * Math.cos(rad) - p[2] * Math.sin(rad);\n  r[2] = p[1] * Math.sin(rad) + p[2] * Math.cos(rad); //translate to correct position\n\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n  return out;\n}\n/**\n * Rotate a 3D vector around the y-axis\n * @param {vec3} out The receiving vec3\n * @param {ReadonlyVec3} a The vec3 point to rotate\n * @param {ReadonlyVec3} b The origin of the rotation\n * @param {Number} rad The angle of rotation in radians\n * @returns {vec3} out\n */\n\nexport function rotateY(out, a, b, rad) {\n  var p = [],\n      r = []; //Translate point to the origin\n\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2]; //perform rotation\n\n  r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);\n  r[1] = p[1];\n  r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad); //translate to correct position\n\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n  return out;\n}\n/**\n * Rotate a 3D vector around the z-axis\n * @param {vec3} out The receiving vec3\n * @param {ReadonlyVec3} a The vec3 point to rotate\n * @param {ReadonlyVec3} b The origin of the rotation\n * @param {Number} rad The angle of rotation in radians\n * @returns {vec3} out\n */\n\nexport function rotateZ(out, a, b, rad) {\n  var p = [],\n      r = []; //Translate point to the origin\n\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2]; //perform rotation\n\n  r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);\n  r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);\n  r[2] = p[2]; //translate to correct position\n\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n  return out;\n}\n/**\n * Get the angle between two 3D vectors\n * @param {ReadonlyVec3} a The first operand\n * @param {ReadonlyVec3} b The second operand\n * @returns {Number} The angle in radians\n */\n\nexport function angle(a, b) {\n  var ax = a[0],\n      ay = a[1],\n      az = a[2],\n      bx = b[0],\n      by = b[1],\n      bz = b[2],\n      mag1 = Math.sqrt(ax * ax + ay * ay + az * az),\n      mag2 = Math.sqrt(bx * bx + by * by + bz * bz),\n      mag = mag1 * mag2,\n      cosine = mag && dot(a, b) / mag;\n  return Math.acos(Math.min(Math.max(cosine, -1), 1));\n}\n/**\n * Set the components of a vec3 to zero\n *\n * @param {vec3} out the receiving vector\n * @returns {vec3} out\n */\n\nexport function zero(out) {\n  out[0] = 0.0;\n  out[1] = 0.0;\n  out[2] = 0.0;\n  return out;\n}\n/**\n * Returns a string representation of a vector\n *\n * @param {ReadonlyVec3} a vector to represent as a string\n * @returns {String} string representation of the vector\n */\n\nexport function str(a) {\n  return \"vec3(\" + a[0] + \", \" + a[1] + \", \" + a[2] + \")\";\n}\n/**\n * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyVec3} a The first vector.\n * @param {ReadonlyVec3} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\nexport function exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];\n}\n/**\n * Returns whether or not the vectors have approximately the same elements in the same position.\n *\n * @param {ReadonlyVec3} a The first vector.\n * @param {ReadonlyVec3} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\nexport function equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2));\n}\n/**\n * Alias for {@link vec3.subtract}\n * @function\n */\n\nexport var sub = subtract;\n/**\n * Alias for {@link vec3.multiply}\n * @function\n */\n\nexport var mul = multiply;\n/**\n * Alias for {@link vec3.divide}\n * @function\n */\n\nexport var div = divide;\n/**\n * Alias for {@link vec3.distance}\n * @function\n */\n\nexport var dist = distance;\n/**\n * Alias for {@link vec3.squaredDistance}\n * @function\n */\n\nexport var sqrDist = squaredDistance;\n/**\n * Alias for {@link vec3.length}\n * @function\n */\n\nexport var len = length;\n/**\n * Alias for {@link vec3.squaredLength}\n * @function\n */\n\nexport var sqrLen = squaredLength;\n/**\n * Perform some operation over an array of vec3s.\n *\n * @param {Array} a the array of vectors to iterate over\n * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed\n * @param {Number} offset Number of elements to skip at the beginning of the array\n * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array\n * @param {Function} fn Function to call for each vector in the array\n * @param {Object} [arg] additional argument to pass to fn\n * @returns {Array} a\n * @function\n */\n\nexport var forEach = function () {\n  var vec = create();\n  return function (a, stride, offset, count, fn, arg) {\n    var i, l;\n\n    if (!stride) {\n      stride = 3;\n    }\n\n    if (!offset) {\n      offset = 0;\n    }\n\n    if (count) {\n      l = Math.min(count * stride + offset, a.length);\n    } else {\n      l = a.length;\n    }\n\n    for (i = offset; i < l; i += stride) {\n      vec[0] = a[i];\n      vec[1] = a[i + 1];\n      vec[2] = a[i + 2];\n      fn(vec, vec, arg);\n      a[i] = vec[0];\n      a[i + 1] = vec[1];\n      a[i + 2] = vec[2];\n    }\n\n    return a;\n  };\n}();", "import { transformMat4 } from 'gl-matrix/vec3';\nimport { PropertyType, bbox, mat4, vec3 } from '../constants.js';\nimport type { Mesh, Node, Scene } from '../properties/index.js';\n\n/**\n * Computes bounding box (AABB) in world space for the given {@link Node} or {@link Scene}.\n *\n * Example:\n *\n * ```ts\n * const {min, max} = getBounds(scene);\n * ```\n */\nexport function getBounds(node: Node | Scene): bbox {\n\tconst resultBounds = createBounds();\n\tconst parents = node.propertyType === PropertyType.NODE ? [node] : node.listChildren();\n\n\tfor (const parent of parents) {\n\t\tparent.traverse((node) => {\n\t\t\tconst mesh = node.getMesh();\n\t\t\tif (!mesh) return;\n\n\t\t\t// Compute mesh bounds and update result.\n\t\t\tconst meshBounds = getMeshBounds(mesh, node.getWorldMatrix());\n\t\t\texpandBounds(meshBounds.min, resultBounds);\n\t\t\texpandBounds(meshBounds.max, resultBounds);\n\t\t});\n\t}\n\n\treturn resultBounds;\n}\n\n/**\n * @deprecated Renamed to {@link getBounds}.\n * @hidden\n */\nexport const bounds = getBounds;\n\n/** Computes mesh bounds in local space. */\nfunction getMeshBounds(mesh: Mesh, worldMatrix: mat4): bbox {\n\tconst meshBounds = createBounds();\n\n\t// We can't transform a local AABB into world space and still have a tight AABB in world space,\n\t// so we need to compute the world AABB vertex by vertex here.\n\tfor (const prim of mesh.listPrimitives()) {\n\t\tconst position = prim.getAttribute('POSITION');\n\t\tif (!position) continue;\n\n\t\tlet localPos: vec3 = [0, 0, 0];\n\t\tlet worldPos: vec3 = [0, 0, 0];\n\t\tfor (let i = 0; i < position.getCount(); i++) {\n\t\t\tlocalPos = position.getElement(i, localPos) as vec3;\n\t\t\tworldPos = transformMat4(worldPos, localPos, worldMatrix) as vec3;\n\t\t\texpandBounds(worldPos, meshBounds);\n\t\t}\n\t}\n\n\treturn meshBounds;\n}\n\n/** Expands bounds of target by given source. */\nfunction expandBounds(point: vec3, target: bbox): void {\n\tfor (let i = 0; i < 3; i++) {\n\t\ttarget.min[i] = Math.min(point[i], target.min[i]);\n\t\ttarget.max[i] = Math.max(point[i], target.max[i]);\n\t}\n}\n\n/** Creates new bounds with min=Infinity, max=-Infinity. */\nfunction createBounds(): bbox {\n\treturn {\n\t\tmin: [Infinity, Infinity, Infinity] as vec3,\n\t\tmax: [-Infinity, -Infinity, -Infinity] as vec3,\n\t};\n}\n", "import type { TypedArray } from '../constants.js';\n\n/**\n * *Common utilities for working with Uint8Array and Buffer objects.*\n *\n * @category Utilities\n */\nexport class BufferUtils {\n\t/** Creates a byte array from a Data URI. */\n\tstatic createBufferFromDataURI(dataURI: string): Uint8Array {\n\t\tif (typeof Buffer === 'undefined') {\n\t\t\t// Browser.\n\t\t\tconst byteString = atob(dataURI.split(',')[1]);\n\t\t\tconst ia = new Uint8Array(byteString.length);\n\t\t\tfor (let i = 0; i < byteString.length; i++) {\n\t\t\t\tia[i] = byteString.charCodeAt(i);\n\t\t\t}\n\t\t\treturn ia;\n\t\t} else {\n\t\t\t// Node.js.\n\t\t\tconst data = dataURI.split(',')[1];\n\t\t\tconst isBase64 = dataURI.indexOf('base64') >= 0;\n\t\t\treturn Buffer.from(data, isBase64 ? 'base64' : 'utf8');\n\t\t}\n\t}\n\n\t/** Encodes text to a byte array. */\n\tstatic encodeText(text: string): Uint8Array {\n\t\tif (typeof TextEncoder !== 'undefined') {\n\t\t\treturn new TextEncoder().encode(text);\n\t\t}\n\t\treturn Buffer.from(text);\n\t}\n\n\t/** Decodes a byte array to text. */\n\tstatic decodeText(array: Uint8Array): string {\n\t\tif (typeof TextDecoder !== 'undefined') {\n\t\t\treturn new TextDecoder().decode(array);\n\t\t}\n\t\treturn Buffer.from(array).toString('utf8');\n\t}\n\n\t/**\n\t * Concatenates N byte arrays.\n\t */\n\tstatic concat(arrays: Uint8Array[]): Uint8Array {\n\t\tlet totalByteLength = 0;\n\t\tfor (const array of arrays) {\n\t\t\ttotalByteLength += array.byteLength;\n\t\t}\n\n\t\tconst result = new Uint8Array(totalByteLength);\n\t\tlet byteOffset = 0;\n\n\t\tfor (const array of arrays) {\n\t\t\tresult.set(array, byteOffset);\n\t\t\tbyteOffset += array.byteLength;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Pads a Uint8Array to the next 4-byte boundary.\n\t *\n\t * Reference: [glTF  Data Alignment](https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#data-alignment)\n\t */\n\tstatic pad(srcArray: Uint8Array, paddingByte = 0): Uint8Array {\n\t\tconst paddedLength = this.padNumber(srcArray.byteLength);\n\t\tif (paddedLength === srcArray.byteLength) return srcArray;\n\n\t\tconst dstArray = new Uint8Array(paddedLength);\n\t\tdstArray.set(srcArray);\n\n\t\tif (paddingByte !== 0) {\n\t\t\tfor (let i = srcArray.byteLength; i < paddedLength; i++) {\n\t\t\t\tdstArray[i] = paddingByte;\n\t\t\t}\n\t\t}\n\n\t\treturn dstArray;\n\t}\n\n\t/** Pads a number to 4-byte boundaries. */\n\tstatic padNumber(v: number): number {\n\t\treturn Math.ceil(v / 4) * 4;\n\t}\n\n\t/** Returns true if given byte array instances are equal. */\n\tstatic equals(a: Uint8Array, b: Uint8Array): boolean {\n\t\tif (a === b) return true;\n\n\t\tif (a.byteLength !== b.byteLength) return false;\n\n\t\tlet i = a.byteLength;\n\t\twhile (i--) {\n\t\t\tif (a[i] !== b[i]) return false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Returns a Uint8Array view of a typed array, with the same underlying ArrayBuffer.\n\t *\n\t * A shorthand for:\n\t *\n\t * ```js\n\t * const buffer = new Uint8Array(\n\t * \tarray.buffer,\n\t * \tarray.byteOffset + byteOffset,\n\t * \tMath.min(array.byteLength, byteLength)\n\t * );\n\t * ```\n\t *\n\t */\n\tstatic toView(a: TypedArray, byteOffset = 0, byteLength = Infinity): Uint8Array {\n\t\treturn new Uint8Array(a.buffer, a.byteOffset + byteOffset, Math.min(a.byteLength, byteLength));\n\t}\n\n\t/** @internal */\n\tstatic assertView(view: null): null;\n\tstatic assertView(view: Uint8Array): Uint8Array;\n\tstatic assertView(view: Uint8Array | null): Uint8Array | null;\n\tstatic assertView(view: Uint8Array | null): Uint8Array | null {\n\t\tif (view && !ArrayBuffer.isView(view)) {\n\t\t\tthrow new Error(`Method requires Uint8Array parameter; received \"${typeof view}\".`);\n\t\t}\n\t\treturn view as Uint8Array;\n\t}\n}\n", "import type { vec3, vec4 } from '../constants.js';\n\n/**\n * *Common utilities for working with colors in vec3, vec4, or hexadecimal form.*\n *\n * Provides methods to convert linear components (vec3, vec4) to sRGB hex values. All colors in\n * the glTF specification, excluding color textures, are linear. Hexadecimal values, in sRGB\n * colorspace, are accessible through helper functions in the API as a convenience.\n *\n * ```typescript\n * // Hex (sRGB) to factor (linear).\n * const factor = ColorUtils.hexToFactor(0xFFCCCC, []);\n *\n * // Factor (linear) to hex (sRGB).\n * const hex = ColorUtils.factorToHex([1, .25, .25])\n * ```\n *\n * @category Utilities\n */\nexport class ColorUtils {\n\t/**\n\t * Converts sRGB hexadecimal to linear components.\n\t * @typeParam T vec3 or vec4 linear components.\n\t */\n\tstatic hexToFactor<T = vec3 | vec4>(hex: number, target: T): T {\n\t\thex = Math.floor(hex);\n\t\tconst _target = target as unknown as vec3;\n\t\t_target[0] = ((hex >> 16) & 255) / 255;\n\t\t_target[1] = ((hex >> 8) & 255) / 255;\n\t\t_target[2] = (hex & 255) / 255;\n\t\treturn this.convertSRGBToLinear<T>(target, target);\n\t}\n\n\t/**\n\t * Converts linear components to sRGB hexadecimal.\n\t * @typeParam T vec3 or vec4 linear components.\n\t */\n\tstatic factorToHex<T = vec3 | vec4>(factor: T): number {\n\t\tconst target = [...(factor as unknown as number[])] as unknown as T;\n\t\tconst [r, g, b] = this.convertLinearToSRGB(factor, target) as unknown as number[];\n\t\treturn ((r * 255) << 16) ^ ((g * 255) << 8) ^ ((b * 255) << 0);\n\t}\n\n\t/**\n\t * Converts sRGB components to linear components.\n\t * @typeParam T vec3 or vec4 linear components.\n\t */\n\tstatic convertSRGBToLinear<T = vec3 | vec4>(source: T, target: T): T {\n\t\tconst _source = source as unknown as vec3;\n\t\tconst _target = target as unknown as vec3;\n\t\tfor (let i = 0; i < 3; i++) {\n\t\t\t_target[i] =\n\t\t\t\t_source[i] < 0.04045\n\t\t\t\t\t? _source[i] * 0.0773993808\n\t\t\t\t\t: Math.pow(_source[i] * 0.9478672986 + 0.0521327014, 2.4);\n\t\t}\n\t\treturn target;\n\t}\n\n\t/**\n\t * Converts linear components to sRGB components.\n\t * @typeParam T vec3 or vec4 linear components.\n\t */\n\tstatic convertLinearToSRGB<T = vec3 | vec4>(source: T, target: T): T {\n\t\tconst _source = source as unknown as vec3;\n\t\tconst _target = target as unknown as vec3;\n\t\tfor (let i = 0; i < 3; i++) {\n\t\t\t_target[i] = _source[i] < 0.0031308 ? _source[i] * 12.92 : 1.055 * Math.pow(_source[i], 0.41666) - 0.055;\n\t\t}\n\t\treturn target;\n\t}\n}\n", "import type { vec2 } from '../constants.js';\nimport { BufferUtils } from './buffer-utils.js';\n\n/** Implements support for an image format in the {@link ImageUtils} class. */\nexport interface ImageUtilsFormat {\n\tmatch(buffer: Uint8Array): boolean;\n\tgetSize(buffer: Uint8Array): vec2 | null;\n\tgetChannels(buffer: Uint8Array): number | null;\n\tgetVRAMByteLength?(buffer: Uint8Array): number | null;\n}\n\n/** JPEG image support. */\nclass JPEGImageUtils implements ImageUtilsFormat {\n\tmatch(array: Uint8Array): boolean {\n\t\treturn array.length >= 3 && array[0] === 255 && array[1] === 216 && array[2] === 255;\n\t}\n\tgetSize(array: Uint8Array): vec2 {\n\t\t// Skip 4 chars, they are for signature\n\t\tlet view = new DataView(array.buffer, array.byteOffset + 4);\n\n\t\tlet i: number, next: number;\n\t\twhile (view.byteLength) {\n\t\t\t// read length of the next block\n\t\t\ti = view.getUint16(0, false);\n\t\t\t// i = buffer.readUInt16BE(0);\n\n\t\t\t// ensure correct format\n\t\t\tvalidateJPEGBuffer(view, i);\n\n\t\t\t// 0xFFC0 is baseline standard(SOF)\n\t\t\t// 0xFFC1 is baseline optimized(SOF)\n\t\t\t// 0xFFC2 is progressive(SOF2)\n\t\t\tnext = view.getUint8(i + 1);\n\t\t\tif (next === 0xc0 || next === 0xc1 || next === 0xc2) {\n\t\t\t\treturn [view.getUint16(i + 7, false), view.getUint16(i + 5, false)];\n\t\t\t}\n\n\t\t\t// move to the next block\n\t\t\tview = new DataView(array.buffer, view.byteOffset + i + 2);\n\t\t}\n\n\t\tthrow new TypeError('Invalid JPG, no size found');\n\t}\n\n\tgetChannels(_buffer: Uint8Array): number {\n\t\treturn 3;\n\t}\n}\n\n/**\n * PNG image support.\n *\n * PNG signature: 'PNG\\r\\n\\x1a\\n'\n * PNG image header chunk name: 'IHDR'\n */\nclass PNGImageUtils implements ImageUtilsFormat {\n\t// Used to detect \"fried\" png's: http://www.jongware.com/pngdefry.html\n\tstatic PNG_FRIED_CHUNK_NAME = 'CgBI';\n\tmatch(array: Uint8Array): boolean {\n\t\treturn (\n\t\t\tarray.length >= 8 &&\n\t\t\tarray[0] === 0x89 &&\n\t\t\tarray[1] === 0x50 &&\n\t\t\tarray[2] === 0x4e &&\n\t\t\tarray[3] === 0x47 &&\n\t\t\tarray[4] === 0x0d &&\n\t\t\tarray[5] === 0x0a &&\n\t\t\tarray[6] === 0x1a &&\n\t\t\tarray[7] === 0x0a\n\t\t);\n\t}\n\tgetSize(array: Uint8Array): vec2 {\n\t\tconst view = new DataView(array.buffer, array.byteOffset);\n\t\tconst magic = BufferUtils.decodeText(array.slice(12, 16));\n\t\tif (magic === PNGImageUtils.PNG_FRIED_CHUNK_NAME) {\n\t\t\treturn [view.getUint32(32, false), view.getUint32(36, false)];\n\t\t}\n\t\treturn [view.getUint32(16, false), view.getUint32(20, false)];\n\t}\n\tgetChannels(_buffer: Uint8Array): number {\n\t\treturn 4;\n\t}\n}\n\n/**\n * *Common utilities for working with image data.*\n *\n * @category Utilities\n */\nexport class ImageUtils {\n\tstatic impls: Record<string, ImageUtilsFormat> = {\n\t\t'image/jpeg': new JPEGImageUtils(),\n\t\t'image/png': new PNGImageUtils(),\n\t};\n\n\t/** Registers support for a new image format; useful for certain extensions. */\n\tpublic static registerFormat(mimeType: string, impl: ImageUtilsFormat): void {\n\t\tthis.impls[mimeType] = impl;\n\t}\n\n\t/**\n\t * Returns detected MIME type of the given image buffer. Note that for image\n\t * formats with support provided by extensions, the extension must be\n\t * registered with an I/O class before it can be detected by ImageUtils.\n\t */\n\tpublic static getMimeType(buffer: Uint8Array): string | null {\n\t\tfor (const mimeType in this.impls) {\n\t\t\tif (this.impls[mimeType].match(buffer)) {\n\t\t\t\treturn mimeType;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/** Returns the dimensions of the image. */\n\tpublic static getSize(buffer: Uint8Array, mimeType: string): vec2 | null {\n\t\tif (!this.impls[mimeType]) return null;\n\t\treturn this.impls[mimeType].getSize(buffer);\n\t}\n\n\t/**\n\t * Returns a conservative estimate of the number of channels in the image. For some image\n\t * formats, the method may return 4 indicating the possibility of an alpha channel, without\n\t * the ability to guarantee that an alpha channel is present.\n\t */\n\tpublic static getChannels(buffer: Uint8Array, mimeType: string): number | null {\n\t\tif (!this.impls[mimeType]) return null;\n\t\treturn this.impls[mimeType].getChannels(buffer);\n\t}\n\n\t/** Returns a conservative estimate of the GPU memory required by this image. */\n\tpublic static getVRAMByteLength(buffer: Uint8Array, mimeType: string): number | null {\n\t\tif (!this.impls[mimeType]) return null;\n\n\t\tif (this.impls[mimeType].getVRAMByteLength) {\n\t\t\treturn this.impls[mimeType].getVRAMByteLength!(buffer);\n\t\t}\n\n\t\tlet uncompressedBytes = 0;\n\t\tconst channels = 4; // See https://github.com/donmccurdy/glTF-Transform/issues/151.\n\t\tconst resolution = this.getSize(buffer, mimeType);\n\t\tif (!resolution) return null;\n\n\t\twhile (resolution[0] > 1 || resolution[1] > 1) {\n\t\t\tuncompressedBytes += resolution[0] * resolution[1] * channels;\n\t\t\tresolution[0] = Math.max(Math.floor(resolution[0] / 2), 1);\n\t\t\tresolution[1] = Math.max(Math.floor(resolution[1] / 2), 1);\n\t\t}\n\t\tuncompressedBytes += 1 * 1 * channels;\n\t\treturn uncompressedBytes;\n\t}\n\n\t/** Returns the preferred file extension for the given MIME type. */\n\tpublic static mimeTypeToExtension(mimeType: string): string {\n\t\tif (mimeType === 'image/jpeg') return 'jpg';\n\t\treturn mimeType.split('/').pop()!;\n\t}\n\n\t/** Returns the MIME type for the given file extension. */\n\tpublic static extensionToMimeType(extension: string): string {\n\t\tif (extension === 'jpg') return 'image/jpeg';\n\t\tif (!extension) return '';\n\t\treturn `image/${extension}`;\n\t}\n}\n\nfunction validateJPEGBuffer(view: DataView, i: number): DataView {\n\t// index should be within buffer limits\n\tif (i > view.byteLength) {\n\t\tthrow new TypeError('Corrupt JPG, exceeded buffer limits');\n\t}\n\t// Every JPEG block must begin with a 0xFF\n\tif (view.getUint8(i) !== 0xff) {\n\t\tthrow new TypeError('Invalid JPG, marker table corrupted');\n\t}\n\n\treturn view;\n}\n", "import { ImageUtils } from './image-utils.js';\n\n/**\n * *Utility class for working with file systems and URI paths.*\n *\n * @category Utilities\n */\nexport class FileUtils {\n\t/**\n\t * Extracts the basename from a file path, e.g. \"folder/model.glb\" -> \"model\".\n\t * See: {@link HTTPUtils.basename}\n\t */\n\tstatic basename(uri: string): string {\n\t\tconst fileName = uri.split(/[\\\\/]/).pop()!;\n\t\treturn fileName.substring(0, fileName.lastIndexOf('.'));\n\t}\n\n\t/**\n\t * Extracts the extension from a file path, e.g. \"folder/model.glb\" -> \"glb\".\n\t * See: {@link HTTPUtils.extension}\n\t */\n\tstatic extension(uri: string): string {\n\t\tif (uri.startsWith('data:image/')) {\n\t\t\tconst mimeType = uri.match(/data:(image\\/\\w+)/)![1];\n\t\t\treturn ImageUtils.mimeTypeToExtension(mimeType);\n\t\t} else if (uri.startsWith('data:model/gltf+json')) {\n\t\t\treturn 'gltf';\n\t\t} else if (uri.startsWith('data:model/gltf-binary')) {\n\t\t\treturn 'glb';\n\t\t} else if (uri.startsWith('data:application/')) {\n\t\t\treturn 'bin';\n\t\t}\n\t\treturn uri.split(/[\\\\/]/).pop()!.split(/[.]/).pop()!;\n\t}\n}\n", "/* eslint-disable @typescript-eslint/no-explicit-any */\n// Reference: https://github.com/jonschlinkert/is-plain-object\n\nfunction isObject(o: any) {\n\treturn Object.prototype.toString.call(o) === '[object Object]';\n}\n\nexport function isPlainObject(o: any) {\n\tif (isObject(o) === false) return false;\n\n\t// If has modified constructor\n\tconst ctor = o.constructor;\n\tif (ctor === undefined) return true;\n\n\t// If has modified prototype\n\tconst prot = ctor.prototype;\n\tif (isObject(prot) === false) return false;\n\n\t// If constructor does not have an Object-specific method\n\tif (Object.prototype.hasOwnProperty.call(prot, 'isPrototypeOf') === false) {\n\t\treturn false;\n\t}\n\n\t// Most likely a plain Object\n\treturn true;\n}\n", "/** Logger verbosity thresholds. */\nexport enum Verbosity {\n\t/** No events are logged. */\n\tSILENT = 4,\n\n\t/** Only error events are logged. */\n\tERROR = 3,\n\n\t/** Only error and warn events are logged. */\n\tWARN = 2,\n\n\t/** Only error, warn, and info events are logged. (DEFAULT) */\n\tINFO = 1,\n\n\t/** All events are logged. */\n\tDEBUG = 0,\n}\n\nexport interface ILogger {\n\tdebug(text: string): void;\n\tinfo(text: string): void;\n\twarn(text: string): void;\n\terror(text: string): void;\n}\n\n/**\n * *Logger utility class.*\n *\n * @category Utilities\n */\nexport class Logger implements ILogger {\n\t/** Logger verbosity thresholds. */\n\tstatic Verbosity = Verbosity;\n\n\t/** Default logger instance. */\n\tpublic static DEFAULT_INSTANCE = new Logger(Logger.Verbosity.INFO);\n\n\t/** Constructs a new Logger instance. */\n\tconstructor(private readonly verbosity: number) {}\n\n\t/** Logs an event at level {@link Logger.Verbosity.DEBUG}. */\n\tdebug(text: string): void {\n\t\tif (this.verbosity <= Logger.Verbosity.DEBUG) {\n\t\t\tconsole.debug(text);\n\t\t}\n\t}\n\n\t/** Logs an event at level {@link Logger.Verbosity.INFO}. */\n\tinfo(text: string): void {\n\t\tif (this.verbosity <= Logger.Verbosity.INFO) {\n\t\t\tconsole.info(text);\n\t\t}\n\t}\n\n\t/** Logs an event at level {@link Logger.Verbosity.WARN}. */\n\twarn(text: string): void {\n\t\tif (this.verbosity <= Logger.Verbosity.WARN) {\n\t\t\tconsole.warn(text);\n\t\t}\n\t}\n\n\t/** Logs an event at level {@link Logger.Verbosity.ERROR}. */\n\terror(text: string): void {\n\t\tif (this.verbosity <= Logger.Verbosity.ERROR) {\n\t\t\tconsole.error(text);\n\t\t}\n\t}\n}\n", "import * as glMatrix from \"./common.js\";\n/**\n * 4x4 Matrix<br>Format: column-major, when typed out it looks like row-major<br>The matrices are being post multiplied.\n * @module mat4\n */\n\n/**\n * Creates a new identity mat4\n *\n * @returns {mat4} a new 4x4 matrix\n */\n\nexport function create() {\n  var out = new glMatrix.ARRAY_TYPE(16);\n\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[4] = 0;\n    out[6] = 0;\n    out[7] = 0;\n    out[8] = 0;\n    out[9] = 0;\n    out[11] = 0;\n    out[12] = 0;\n    out[13] = 0;\n    out[14] = 0;\n  }\n\n  out[0] = 1;\n  out[5] = 1;\n  out[10] = 1;\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a new mat4 initialized with values from an existing matrix\n *\n * @param {ReadonlyMat4} a matrix to clone\n * @returns {mat4} a new 4x4 matrix\n */\n\nexport function clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(16);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  out[9] = a[9];\n  out[10] = a[10];\n  out[11] = a[11];\n  out[12] = a[12];\n  out[13] = a[13];\n  out[14] = a[14];\n  out[15] = a[15];\n  return out;\n}\n/**\n * Copy the values from one mat4 to another\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the source matrix\n * @returns {mat4} out\n */\n\nexport function copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  out[9] = a[9];\n  out[10] = a[10];\n  out[11] = a[11];\n  out[12] = a[12];\n  out[13] = a[13];\n  out[14] = a[14];\n  out[15] = a[15];\n  return out;\n}\n/**\n * Create a new mat4 with the given values\n *\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\n * @param {Number} m03 Component in column 0, row 3 position (index 3)\n * @param {Number} m10 Component in column 1, row 0 position (index 4)\n * @param {Number} m11 Component in column 1, row 1 position (index 5)\n * @param {Number} m12 Component in column 1, row 2 position (index 6)\n * @param {Number} m13 Component in column 1, row 3 position (index 7)\n * @param {Number} m20 Component in column 2, row 0 position (index 8)\n * @param {Number} m21 Component in column 2, row 1 position (index 9)\n * @param {Number} m22 Component in column 2, row 2 position (index 10)\n * @param {Number} m23 Component in column 2, row 3 position (index 11)\n * @param {Number} m30 Component in column 3, row 0 position (index 12)\n * @param {Number} m31 Component in column 3, row 1 position (index 13)\n * @param {Number} m32 Component in column 3, row 2 position (index 14)\n * @param {Number} m33 Component in column 3, row 3 position (index 15)\n * @returns {mat4} A new mat4\n */\n\nexport function fromValues(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {\n  var out = new glMatrix.ARRAY_TYPE(16);\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m02;\n  out[3] = m03;\n  out[4] = m10;\n  out[5] = m11;\n  out[6] = m12;\n  out[7] = m13;\n  out[8] = m20;\n  out[9] = m21;\n  out[10] = m22;\n  out[11] = m23;\n  out[12] = m30;\n  out[13] = m31;\n  out[14] = m32;\n  out[15] = m33;\n  return out;\n}\n/**\n * Set the components of a mat4 to the given values\n *\n * @param {mat4} out the receiving matrix\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\n * @param {Number} m03 Component in column 0, row 3 position (index 3)\n * @param {Number} m10 Component in column 1, row 0 position (index 4)\n * @param {Number} m11 Component in column 1, row 1 position (index 5)\n * @param {Number} m12 Component in column 1, row 2 position (index 6)\n * @param {Number} m13 Component in column 1, row 3 position (index 7)\n * @param {Number} m20 Component in column 2, row 0 position (index 8)\n * @param {Number} m21 Component in column 2, row 1 position (index 9)\n * @param {Number} m22 Component in column 2, row 2 position (index 10)\n * @param {Number} m23 Component in column 2, row 3 position (index 11)\n * @param {Number} m30 Component in column 3, row 0 position (index 12)\n * @param {Number} m31 Component in column 3, row 1 position (index 13)\n * @param {Number} m32 Component in column 3, row 2 position (index 14)\n * @param {Number} m33 Component in column 3, row 3 position (index 15)\n * @returns {mat4} out\n */\n\nexport function set(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m02;\n  out[3] = m03;\n  out[4] = m10;\n  out[5] = m11;\n  out[6] = m12;\n  out[7] = m13;\n  out[8] = m20;\n  out[9] = m21;\n  out[10] = m22;\n  out[11] = m23;\n  out[12] = m30;\n  out[13] = m31;\n  out[14] = m32;\n  out[15] = m33;\n  return out;\n}\n/**\n * Set a mat4 to the identity matrix\n *\n * @param {mat4} out the receiving matrix\n * @returns {mat4} out\n */\n\nexport function identity(out) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = 1;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 1;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Transpose the values of a mat4\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the source matrix\n * @returns {mat4} out\n */\n\nexport function transpose(out, a) {\n  // If we are transposing ourselves we can skip a few steps but have to cache some values\n  if (out === a) {\n    var a01 = a[1],\n        a02 = a[2],\n        a03 = a[3];\n    var a12 = a[6],\n        a13 = a[7];\n    var a23 = a[11];\n    out[1] = a[4];\n    out[2] = a[8];\n    out[3] = a[12];\n    out[4] = a01;\n    out[6] = a[9];\n    out[7] = a[13];\n    out[8] = a02;\n    out[9] = a12;\n    out[11] = a[14];\n    out[12] = a03;\n    out[13] = a13;\n    out[14] = a23;\n  } else {\n    out[0] = a[0];\n    out[1] = a[4];\n    out[2] = a[8];\n    out[3] = a[12];\n    out[4] = a[1];\n    out[5] = a[5];\n    out[6] = a[9];\n    out[7] = a[13];\n    out[8] = a[2];\n    out[9] = a[6];\n    out[10] = a[10];\n    out[11] = a[14];\n    out[12] = a[3];\n    out[13] = a[7];\n    out[14] = a[11];\n    out[15] = a[15];\n  }\n\n  return out;\n}\n/**\n * Inverts a mat4\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the source matrix\n * @returns {mat4} out\n */\n\nexport function invert(out, a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15];\n  var b00 = a00 * a11 - a01 * a10;\n  var b01 = a00 * a12 - a02 * a10;\n  var b02 = a00 * a13 - a03 * a10;\n  var b03 = a01 * a12 - a02 * a11;\n  var b04 = a01 * a13 - a03 * a11;\n  var b05 = a02 * a13 - a03 * a12;\n  var b06 = a20 * a31 - a21 * a30;\n  var b07 = a20 * a32 - a22 * a30;\n  var b08 = a20 * a33 - a23 * a30;\n  var b09 = a21 * a32 - a22 * a31;\n  var b10 = a21 * a33 - a23 * a31;\n  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant\n\n  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  if (!det) {\n    return null;\n  }\n\n  det = 1.0 / det;\n  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;\n  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;\n  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;\n  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;\n  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;\n  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;\n  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;\n  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;\n  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;\n  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;\n  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;\n  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;\n  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;\n  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;\n  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;\n  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;\n  return out;\n}\n/**\n * Calculates the adjugate of a mat4\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the source matrix\n * @returns {mat4} out\n */\n\nexport function adjoint(out, a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15];\n  out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);\n  out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));\n  out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);\n  out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));\n  out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));\n  out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);\n  out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));\n  out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);\n  out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);\n  out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));\n  out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);\n  out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));\n  out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));\n  out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);\n  out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));\n  out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);\n  return out;\n}\n/**\n * Calculates the determinant of a mat4\n *\n * @param {ReadonlyMat4} a the source matrix\n * @returns {Number} determinant of a\n */\n\nexport function determinant(a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15];\n  var b00 = a00 * a11 - a01 * a10;\n  var b01 = a00 * a12 - a02 * a10;\n  var b02 = a00 * a13 - a03 * a10;\n  var b03 = a01 * a12 - a02 * a11;\n  var b04 = a01 * a13 - a03 * a11;\n  var b05 = a02 * a13 - a03 * a12;\n  var b06 = a20 * a31 - a21 * a30;\n  var b07 = a20 * a32 - a22 * a30;\n  var b08 = a20 * a33 - a23 * a30;\n  var b09 = a21 * a32 - a22 * a31;\n  var b10 = a21 * a33 - a23 * a31;\n  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant\n\n  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n}\n/**\n * Multiplies two mat4s\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the first operand\n * @param {ReadonlyMat4} b the second operand\n * @returns {mat4} out\n */\n\nexport function multiply(out, a, b) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15]; // Cache only the current line of the second matrix\n\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3];\n  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  b0 = b[4];\n  b1 = b[5];\n  b2 = b[6];\n  b3 = b[7];\n  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  b0 = b[8];\n  b1 = b[9];\n  b2 = b[10];\n  b3 = b[11];\n  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  b0 = b[12];\n  b1 = b[13];\n  b2 = b[14];\n  b3 = b[15];\n  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  return out;\n}\n/**\n * Translate a mat4 by the given vector\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to translate\n * @param {ReadonlyVec3} v vector to translate by\n * @returns {mat4} out\n */\n\nexport function translate(out, a, v) {\n  var x = v[0],\n      y = v[1],\n      z = v[2];\n  var a00, a01, a02, a03;\n  var a10, a11, a12, a13;\n  var a20, a21, a22, a23;\n\n  if (a === out) {\n    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];\n    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];\n    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];\n    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];\n  } else {\n    a00 = a[0];\n    a01 = a[1];\n    a02 = a[2];\n    a03 = a[3];\n    a10 = a[4];\n    a11 = a[5];\n    a12 = a[6];\n    a13 = a[7];\n    a20 = a[8];\n    a21 = a[9];\n    a22 = a[10];\n    a23 = a[11];\n    out[0] = a00;\n    out[1] = a01;\n    out[2] = a02;\n    out[3] = a03;\n    out[4] = a10;\n    out[5] = a11;\n    out[6] = a12;\n    out[7] = a13;\n    out[8] = a20;\n    out[9] = a21;\n    out[10] = a22;\n    out[11] = a23;\n    out[12] = a00 * x + a10 * y + a20 * z + a[12];\n    out[13] = a01 * x + a11 * y + a21 * z + a[13];\n    out[14] = a02 * x + a12 * y + a22 * z + a[14];\n    out[15] = a03 * x + a13 * y + a23 * z + a[15];\n  }\n\n  return out;\n}\n/**\n * Scales the mat4 by the dimensions in the given vec3 not using vectorization\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to scale\n * @param {ReadonlyVec3} v the vec3 to scale the matrix by\n * @returns {mat4} out\n **/\n\nexport function scale(out, a, v) {\n  var x = v[0],\n      y = v[1],\n      z = v[2];\n  out[0] = a[0] * x;\n  out[1] = a[1] * x;\n  out[2] = a[2] * x;\n  out[3] = a[3] * x;\n  out[4] = a[4] * y;\n  out[5] = a[5] * y;\n  out[6] = a[6] * y;\n  out[7] = a[7] * y;\n  out[8] = a[8] * z;\n  out[9] = a[9] * z;\n  out[10] = a[10] * z;\n  out[11] = a[11] * z;\n  out[12] = a[12];\n  out[13] = a[13];\n  out[14] = a[14];\n  out[15] = a[15];\n  return out;\n}\n/**\n * Rotates a mat4 by the given angle around the given axis\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @param {ReadonlyVec3} axis the axis to rotate around\n * @returns {mat4} out\n */\n\nexport function rotate(out, a, rad, axis) {\n  var x = axis[0],\n      y = axis[1],\n      z = axis[2];\n  var len = Math.hypot(x, y, z);\n  var s, c, t;\n  var a00, a01, a02, a03;\n  var a10, a11, a12, a13;\n  var a20, a21, a22, a23;\n  var b00, b01, b02;\n  var b10, b11, b12;\n  var b20, b21, b22;\n\n  if (len < glMatrix.EPSILON) {\n    return null;\n  }\n\n  len = 1 / len;\n  x *= len;\n  y *= len;\n  z *= len;\n  s = Math.sin(rad);\n  c = Math.cos(rad);\n  t = 1 - c;\n  a00 = a[0];\n  a01 = a[1];\n  a02 = a[2];\n  a03 = a[3];\n  a10 = a[4];\n  a11 = a[5];\n  a12 = a[6];\n  a13 = a[7];\n  a20 = a[8];\n  a21 = a[9];\n  a22 = a[10];\n  a23 = a[11]; // Construct the elements of the rotation matrix\n\n  b00 = x * x * t + c;\n  b01 = y * x * t + z * s;\n  b02 = z * x * t - y * s;\n  b10 = x * y * t - z * s;\n  b11 = y * y * t + c;\n  b12 = z * y * t + x * s;\n  b20 = x * z * t + y * s;\n  b21 = y * z * t - x * s;\n  b22 = z * z * t + c; // Perform rotation-specific matrix multiplication\n\n  out[0] = a00 * b00 + a10 * b01 + a20 * b02;\n  out[1] = a01 * b00 + a11 * b01 + a21 * b02;\n  out[2] = a02 * b00 + a12 * b01 + a22 * b02;\n  out[3] = a03 * b00 + a13 * b01 + a23 * b02;\n  out[4] = a00 * b10 + a10 * b11 + a20 * b12;\n  out[5] = a01 * b10 + a11 * b11 + a21 * b12;\n  out[6] = a02 * b10 + a12 * b11 + a22 * b12;\n  out[7] = a03 * b10 + a13 * b11 + a23 * b12;\n  out[8] = a00 * b20 + a10 * b21 + a20 * b22;\n  out[9] = a01 * b20 + a11 * b21 + a21 * b22;\n  out[10] = a02 * b20 + a12 * b21 + a22 * b22;\n  out[11] = a03 * b20 + a13 * b21 + a23 * b22;\n\n  if (a !== out) {\n    // If the source and destination differ, copy the unchanged last row\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  }\n\n  return out;\n}\n/**\n * Rotates a matrix by the given angle around the X axis\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\n\nexport function rotateX(out, a, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad);\n  var a10 = a[4];\n  var a11 = a[5];\n  var a12 = a[6];\n  var a13 = a[7];\n  var a20 = a[8];\n  var a21 = a[9];\n  var a22 = a[10];\n  var a23 = a[11];\n\n  if (a !== out) {\n    // If the source and destination differ, copy the unchanged rows\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = a[2];\n    out[3] = a[3];\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  } // Perform axis-specific matrix multiplication\n\n\n  out[4] = a10 * c + a20 * s;\n  out[5] = a11 * c + a21 * s;\n  out[6] = a12 * c + a22 * s;\n  out[7] = a13 * c + a23 * s;\n  out[8] = a20 * c - a10 * s;\n  out[9] = a21 * c - a11 * s;\n  out[10] = a22 * c - a12 * s;\n  out[11] = a23 * c - a13 * s;\n  return out;\n}\n/**\n * Rotates a matrix by the given angle around the Y axis\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\n\nexport function rotateY(out, a, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad);\n  var a00 = a[0];\n  var a01 = a[1];\n  var a02 = a[2];\n  var a03 = a[3];\n  var a20 = a[8];\n  var a21 = a[9];\n  var a22 = a[10];\n  var a23 = a[11];\n\n  if (a !== out) {\n    // If the source and destination differ, copy the unchanged rows\n    out[4] = a[4];\n    out[5] = a[5];\n    out[6] = a[6];\n    out[7] = a[7];\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  } // Perform axis-specific matrix multiplication\n\n\n  out[0] = a00 * c - a20 * s;\n  out[1] = a01 * c - a21 * s;\n  out[2] = a02 * c - a22 * s;\n  out[3] = a03 * c - a23 * s;\n  out[8] = a00 * s + a20 * c;\n  out[9] = a01 * s + a21 * c;\n  out[10] = a02 * s + a22 * c;\n  out[11] = a03 * s + a23 * c;\n  return out;\n}\n/**\n * Rotates a matrix by the given angle around the Z axis\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\n\nexport function rotateZ(out, a, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad);\n  var a00 = a[0];\n  var a01 = a[1];\n  var a02 = a[2];\n  var a03 = a[3];\n  var a10 = a[4];\n  var a11 = a[5];\n  var a12 = a[6];\n  var a13 = a[7];\n\n  if (a !== out) {\n    // If the source and destination differ, copy the unchanged last row\n    out[8] = a[8];\n    out[9] = a[9];\n    out[10] = a[10];\n    out[11] = a[11];\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  } // Perform axis-specific matrix multiplication\n\n\n  out[0] = a00 * c + a10 * s;\n  out[1] = a01 * c + a11 * s;\n  out[2] = a02 * c + a12 * s;\n  out[3] = a03 * c + a13 * s;\n  out[4] = a10 * c - a00 * s;\n  out[5] = a11 * c - a01 * s;\n  out[6] = a12 * c - a02 * s;\n  out[7] = a13 * c - a03 * s;\n  return out;\n}\n/**\n * Creates a matrix from a vector translation\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.translate(dest, dest, vec);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {ReadonlyVec3} v Translation vector\n * @returns {mat4} out\n */\n\nexport function fromTranslation(out, v) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = 1;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 1;\n  out[11] = 0;\n  out[12] = v[0];\n  out[13] = v[1];\n  out[14] = v[2];\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from a vector scaling\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.scale(dest, dest, vec);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {ReadonlyVec3} v Scaling vector\n * @returns {mat4} out\n */\n\nexport function fromScaling(out, v) {\n  out[0] = v[0];\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = v[1];\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = v[2];\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from a given angle around a given axis\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.rotate(dest, dest, rad, axis);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @param {ReadonlyVec3} axis the axis to rotate around\n * @returns {mat4} out\n */\n\nexport function fromRotation(out, rad, axis) {\n  var x = axis[0],\n      y = axis[1],\n      z = axis[2];\n  var len = Math.hypot(x, y, z);\n  var s, c, t;\n\n  if (len < glMatrix.EPSILON) {\n    return null;\n  }\n\n  len = 1 / len;\n  x *= len;\n  y *= len;\n  z *= len;\n  s = Math.sin(rad);\n  c = Math.cos(rad);\n  t = 1 - c; // Perform rotation-specific matrix multiplication\n\n  out[0] = x * x * t + c;\n  out[1] = y * x * t + z * s;\n  out[2] = z * x * t - y * s;\n  out[3] = 0;\n  out[4] = x * y * t - z * s;\n  out[5] = y * y * t + c;\n  out[6] = z * y * t + x * s;\n  out[7] = 0;\n  out[8] = x * z * t + y * s;\n  out[9] = y * z * t - x * s;\n  out[10] = z * z * t + c;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from the given angle around the X axis\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.rotateX(dest, dest, rad);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\n\nexport function fromXRotation(out, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad); // Perform axis-specific matrix multiplication\n\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = c;\n  out[6] = s;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = -s;\n  out[10] = c;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from the given angle around the Y axis\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.rotateY(dest, dest, rad);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\n\nexport function fromYRotation(out, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad); // Perform axis-specific matrix multiplication\n\n  out[0] = c;\n  out[1] = 0;\n  out[2] = -s;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = 1;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = s;\n  out[9] = 0;\n  out[10] = c;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from the given angle around the Z axis\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.rotateZ(dest, dest, rad);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\n\nexport function fromZRotation(out, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad); // Perform axis-specific matrix multiplication\n\n  out[0] = c;\n  out[1] = s;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = -s;\n  out[5] = c;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 1;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from a quaternion rotation and vector translation\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.translate(dest, vec);\n *     let quatMat = mat4.create();\n *     quat4.toMat4(quat, quatMat);\n *     mat4.multiply(dest, quatMat);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {quat4} q Rotation quaternion\n * @param {ReadonlyVec3} v Translation vector\n * @returns {mat4} out\n */\n\nexport function fromRotationTranslation(out, q, v) {\n  // Quaternion math\n  var x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n  var xx = x * x2;\n  var xy = x * y2;\n  var xz = x * z2;\n  var yy = y * y2;\n  var yz = y * z2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  out[0] = 1 - (yy + zz);\n  out[1] = xy + wz;\n  out[2] = xz - wy;\n  out[3] = 0;\n  out[4] = xy - wz;\n  out[5] = 1 - (xx + zz);\n  out[6] = yz + wx;\n  out[7] = 0;\n  out[8] = xz + wy;\n  out[9] = yz - wx;\n  out[10] = 1 - (xx + yy);\n  out[11] = 0;\n  out[12] = v[0];\n  out[13] = v[1];\n  out[14] = v[2];\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a new mat4 from a dual quat.\n *\n * @param {mat4} out Matrix\n * @param {ReadonlyQuat2} a Dual Quaternion\n * @returns {mat4} mat4 receiving operation result\n */\n\nexport function fromQuat2(out, a) {\n  var translation = new glMatrix.ARRAY_TYPE(3);\n  var bx = -a[0],\n      by = -a[1],\n      bz = -a[2],\n      bw = a[3],\n      ax = a[4],\n      ay = a[5],\n      az = a[6],\n      aw = a[7];\n  var magnitude = bx * bx + by * by + bz * bz + bw * bw; //Only scale if it makes sense\n\n  if (magnitude > 0) {\n    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;\n    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;\n    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;\n  } else {\n    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;\n    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;\n    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;\n  }\n\n  fromRotationTranslation(out, a, translation);\n  return out;\n}\n/**\n * Returns the translation vector component of a transformation\n *  matrix. If a matrix is built with fromRotationTranslation,\n *  the returned vector will be the same as the translation vector\n *  originally supplied.\n * @param  {vec3} out Vector to receive translation component\n * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)\n * @return {vec3} out\n */\n\nexport function getTranslation(out, mat) {\n  out[0] = mat[12];\n  out[1] = mat[13];\n  out[2] = mat[14];\n  return out;\n}\n/**\n * Returns the scaling factor component of a transformation\n *  matrix. If a matrix is built with fromRotationTranslationScale\n *  with a normalized Quaternion paramter, the returned vector will be\n *  the same as the scaling vector\n *  originally supplied.\n * @param  {vec3} out Vector to receive scaling factor component\n * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)\n * @return {vec3} out\n */\n\nexport function getScaling(out, mat) {\n  var m11 = mat[0];\n  var m12 = mat[1];\n  var m13 = mat[2];\n  var m21 = mat[4];\n  var m22 = mat[5];\n  var m23 = mat[6];\n  var m31 = mat[8];\n  var m32 = mat[9];\n  var m33 = mat[10];\n  out[0] = Math.hypot(m11, m12, m13);\n  out[1] = Math.hypot(m21, m22, m23);\n  out[2] = Math.hypot(m31, m32, m33);\n  return out;\n}\n/**\n * Returns a quaternion representing the rotational component\n *  of a transformation matrix. If a matrix is built with\n *  fromRotationTranslation, the returned quaternion will be the\n *  same as the quaternion originally supplied.\n * @param {quat} out Quaternion to receive the rotation component\n * @param {ReadonlyMat4} mat Matrix to be decomposed (input)\n * @return {quat} out\n */\n\nexport function getRotation(out, mat) {\n  var scaling = new glMatrix.ARRAY_TYPE(3);\n  getScaling(scaling, mat);\n  var is1 = 1 / scaling[0];\n  var is2 = 1 / scaling[1];\n  var is3 = 1 / scaling[2];\n  var sm11 = mat[0] * is1;\n  var sm12 = mat[1] * is2;\n  var sm13 = mat[2] * is3;\n  var sm21 = mat[4] * is1;\n  var sm22 = mat[5] * is2;\n  var sm23 = mat[6] * is3;\n  var sm31 = mat[8] * is1;\n  var sm32 = mat[9] * is2;\n  var sm33 = mat[10] * is3;\n  var trace = sm11 + sm22 + sm33;\n  var S = 0;\n\n  if (trace > 0) {\n    S = Math.sqrt(trace + 1.0) * 2;\n    out[3] = 0.25 * S;\n    out[0] = (sm23 - sm32) / S;\n    out[1] = (sm31 - sm13) / S;\n    out[2] = (sm12 - sm21) / S;\n  } else if (sm11 > sm22 && sm11 > sm33) {\n    S = Math.sqrt(1.0 + sm11 - sm22 - sm33) * 2;\n    out[3] = (sm23 - sm32) / S;\n    out[0] = 0.25 * S;\n    out[1] = (sm12 + sm21) / S;\n    out[2] = (sm31 + sm13) / S;\n  } else if (sm22 > sm33) {\n    S = Math.sqrt(1.0 + sm22 - sm11 - sm33) * 2;\n    out[3] = (sm31 - sm13) / S;\n    out[0] = (sm12 + sm21) / S;\n    out[1] = 0.25 * S;\n    out[2] = (sm23 + sm32) / S;\n  } else {\n    S = Math.sqrt(1.0 + sm33 - sm11 - sm22) * 2;\n    out[3] = (sm12 - sm21) / S;\n    out[0] = (sm31 + sm13) / S;\n    out[1] = (sm23 + sm32) / S;\n    out[2] = 0.25 * S;\n  }\n\n  return out;\n}\n/**\n * Creates a matrix from a quaternion rotation, vector translation and vector scale\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.translate(dest, vec);\n *     let quatMat = mat4.create();\n *     quat4.toMat4(quat, quatMat);\n *     mat4.multiply(dest, quatMat);\n *     mat4.scale(dest, scale)\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {quat4} q Rotation quaternion\n * @param {ReadonlyVec3} v Translation vector\n * @param {ReadonlyVec3} s Scaling vector\n * @returns {mat4} out\n */\n\nexport function fromRotationTranslationScale(out, q, v, s) {\n  // Quaternion math\n  var x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n  var xx = x * x2;\n  var xy = x * y2;\n  var xz = x * z2;\n  var yy = y * y2;\n  var yz = y * z2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  var sx = s[0];\n  var sy = s[1];\n  var sz = s[2];\n  out[0] = (1 - (yy + zz)) * sx;\n  out[1] = (xy + wz) * sx;\n  out[2] = (xz - wy) * sx;\n  out[3] = 0;\n  out[4] = (xy - wz) * sy;\n  out[5] = (1 - (xx + zz)) * sy;\n  out[6] = (yz + wx) * sy;\n  out[7] = 0;\n  out[8] = (xz + wy) * sz;\n  out[9] = (yz - wx) * sz;\n  out[10] = (1 - (xx + yy)) * sz;\n  out[11] = 0;\n  out[12] = v[0];\n  out[13] = v[1];\n  out[14] = v[2];\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.translate(dest, vec);\n *     mat4.translate(dest, origin);\n *     let quatMat = mat4.create();\n *     quat4.toMat4(quat, quatMat);\n *     mat4.multiply(dest, quatMat);\n *     mat4.scale(dest, scale)\n *     mat4.translate(dest, negativeOrigin);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {quat4} q Rotation quaternion\n * @param {ReadonlyVec3} v Translation vector\n * @param {ReadonlyVec3} s Scaling vector\n * @param {ReadonlyVec3} o The origin vector around which to scale and rotate\n * @returns {mat4} out\n */\n\nexport function fromRotationTranslationScaleOrigin(out, q, v, s, o) {\n  // Quaternion math\n  var x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n  var xx = x * x2;\n  var xy = x * y2;\n  var xz = x * z2;\n  var yy = y * y2;\n  var yz = y * z2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  var sx = s[0];\n  var sy = s[1];\n  var sz = s[2];\n  var ox = o[0];\n  var oy = o[1];\n  var oz = o[2];\n  var out0 = (1 - (yy + zz)) * sx;\n  var out1 = (xy + wz) * sx;\n  var out2 = (xz - wy) * sx;\n  var out4 = (xy - wz) * sy;\n  var out5 = (1 - (xx + zz)) * sy;\n  var out6 = (yz + wx) * sy;\n  var out8 = (xz + wy) * sz;\n  var out9 = (yz - wx) * sz;\n  var out10 = (1 - (xx + yy)) * sz;\n  out[0] = out0;\n  out[1] = out1;\n  out[2] = out2;\n  out[3] = 0;\n  out[4] = out4;\n  out[5] = out5;\n  out[6] = out6;\n  out[7] = 0;\n  out[8] = out8;\n  out[9] = out9;\n  out[10] = out10;\n  out[11] = 0;\n  out[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz);\n  out[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz);\n  out[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz);\n  out[15] = 1;\n  return out;\n}\n/**\n * Calculates a 4x4 matrix from the given quaternion\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {ReadonlyQuat} q Quaternion to create matrix from\n *\n * @returns {mat4} out\n */\n\nexport function fromQuat(out, q) {\n  var x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n  var xx = x * x2;\n  var yx = y * x2;\n  var yy = y * y2;\n  var zx = z * x2;\n  var zy = z * y2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  out[0] = 1 - yy - zz;\n  out[1] = yx + wz;\n  out[2] = zx - wy;\n  out[3] = 0;\n  out[4] = yx - wz;\n  out[5] = 1 - xx - zz;\n  out[6] = zy + wx;\n  out[7] = 0;\n  out[8] = zx + wy;\n  out[9] = zy - wx;\n  out[10] = 1 - xx - yy;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Generates a frustum matrix with the given bounds\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {Number} left Left bound of the frustum\n * @param {Number} right Right bound of the frustum\n * @param {Number} bottom Bottom bound of the frustum\n * @param {Number} top Top bound of the frustum\n * @param {Number} near Near bound of the frustum\n * @param {Number} far Far bound of the frustum\n * @returns {mat4} out\n */\n\nexport function frustum(out, left, right, bottom, top, near, far) {\n  var rl = 1 / (right - left);\n  var tb = 1 / (top - bottom);\n  var nf = 1 / (near - far);\n  out[0] = near * 2 * rl;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = near * 2 * tb;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = (right + left) * rl;\n  out[9] = (top + bottom) * tb;\n  out[10] = (far + near) * nf;\n  out[11] = -1;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = far * near * 2 * nf;\n  out[15] = 0;\n  return out;\n}\n/**\n * Generates a perspective projection matrix with the given bounds.\n * The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],\n * which matches WebGL/OpenGL's clip volume.\n * Passing null/undefined/no value for far will generate infinite projection matrix.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {number} fovy Vertical field of view in radians\n * @param {number} aspect Aspect ratio. typically viewport width/height\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum, can be null or Infinity\n * @returns {mat4} out\n */\n\nexport function perspectiveNO(out, fovy, aspect, near, far) {\n  var f = 1.0 / Math.tan(fovy / 2),\n      nf;\n  out[0] = f / aspect;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = f;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[11] = -1;\n  out[12] = 0;\n  out[13] = 0;\n  out[15] = 0;\n\n  if (far != null && far !== Infinity) {\n    nf = 1 / (near - far);\n    out[10] = (far + near) * nf;\n    out[14] = 2 * far * near * nf;\n  } else {\n    out[10] = -1;\n    out[14] = -2 * near;\n  }\n\n  return out;\n}\n/**\n * Alias for {@link mat4.perspectiveNO}\n * @function\n */\n\nexport var perspective = perspectiveNO;\n/**\n * Generates a perspective projection matrix suitable for WebGPU with the given bounds.\n * The near/far clip planes correspond to a normalized device coordinate Z range of [0, 1],\n * which matches WebGPU/Vulkan/DirectX/Metal's clip volume.\n * Passing null/undefined/no value for far will generate infinite projection matrix.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {number} fovy Vertical field of view in radians\n * @param {number} aspect Aspect ratio. typically viewport width/height\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum, can be null or Infinity\n * @returns {mat4} out\n */\n\nexport function perspectiveZO(out, fovy, aspect, near, far) {\n  var f = 1.0 / Math.tan(fovy / 2),\n      nf;\n  out[0] = f / aspect;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = f;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[11] = -1;\n  out[12] = 0;\n  out[13] = 0;\n  out[15] = 0;\n\n  if (far != null && far !== Infinity) {\n    nf = 1 / (near - far);\n    out[10] = far * nf;\n    out[14] = far * near * nf;\n  } else {\n    out[10] = -1;\n    out[14] = -near;\n  }\n\n  return out;\n}\n/**\n * Generates a perspective projection matrix with the given field of view.\n * This is primarily useful for generating projection matrices to be used\n * with the still experiemental WebVR API.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum\n * @returns {mat4} out\n */\n\nexport function perspectiveFromFieldOfView(out, fov, near, far) {\n  var upTan = Math.tan(fov.upDegrees * Math.PI / 180.0);\n  var downTan = Math.tan(fov.downDegrees * Math.PI / 180.0);\n  var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180.0);\n  var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180.0);\n  var xScale = 2.0 / (leftTan + rightTan);\n  var yScale = 2.0 / (upTan + downTan);\n  out[0] = xScale;\n  out[1] = 0.0;\n  out[2] = 0.0;\n  out[3] = 0.0;\n  out[4] = 0.0;\n  out[5] = yScale;\n  out[6] = 0.0;\n  out[7] = 0.0;\n  out[8] = -((leftTan - rightTan) * xScale * 0.5);\n  out[9] = (upTan - downTan) * yScale * 0.5;\n  out[10] = far / (near - far);\n  out[11] = -1.0;\n  out[12] = 0.0;\n  out[13] = 0.0;\n  out[14] = far * near / (near - far);\n  out[15] = 0.0;\n  return out;\n}\n/**\n * Generates a orthogonal projection matrix with the given bounds.\n * The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],\n * which matches WebGL/OpenGL's clip volume.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {number} left Left bound of the frustum\n * @param {number} right Right bound of the frustum\n * @param {number} bottom Bottom bound of the frustum\n * @param {number} top Top bound of the frustum\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum\n * @returns {mat4} out\n */\n\nexport function orthoNO(out, left, right, bottom, top, near, far) {\n  var lr = 1 / (left - right);\n  var bt = 1 / (bottom - top);\n  var nf = 1 / (near - far);\n  out[0] = -2 * lr;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = -2 * bt;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 2 * nf;\n  out[11] = 0;\n  out[12] = (left + right) * lr;\n  out[13] = (top + bottom) * bt;\n  out[14] = (far + near) * nf;\n  out[15] = 1;\n  return out;\n}\n/**\n * Alias for {@link mat4.orthoNO}\n * @function\n */\n\nexport var ortho = orthoNO;\n/**\n * Generates a orthogonal projection matrix with the given bounds.\n * The near/far clip planes correspond to a normalized device coordinate Z range of [0, 1],\n * which matches WebGPU/Vulkan/DirectX/Metal's clip volume.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {number} left Left bound of the frustum\n * @param {number} right Right bound of the frustum\n * @param {number} bottom Bottom bound of the frustum\n * @param {number} top Top bound of the frustum\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum\n * @returns {mat4} out\n */\n\nexport function orthoZO(out, left, right, bottom, top, near, far) {\n  var lr = 1 / (left - right);\n  var bt = 1 / (bottom - top);\n  var nf = 1 / (near - far);\n  out[0] = -2 * lr;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = -2 * bt;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = nf;\n  out[11] = 0;\n  out[12] = (left + right) * lr;\n  out[13] = (top + bottom) * bt;\n  out[14] = near * nf;\n  out[15] = 1;\n  return out;\n}\n/**\n * Generates a look-at matrix with the given eye position, focal point, and up axis.\n * If you want a matrix that actually makes an object look at another object, you should use targetTo instead.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {ReadonlyVec3} eye Position of the viewer\n * @param {ReadonlyVec3} center Point the viewer is looking at\n * @param {ReadonlyVec3} up vec3 pointing up\n * @returns {mat4} out\n */\n\nexport function lookAt(out, eye, center, up) {\n  var x0, x1, x2, y0, y1, y2, z0, z1, z2, len;\n  var eyex = eye[0];\n  var eyey = eye[1];\n  var eyez = eye[2];\n  var upx = up[0];\n  var upy = up[1];\n  var upz = up[2];\n  var centerx = center[0];\n  var centery = center[1];\n  var centerz = center[2];\n\n  if (Math.abs(eyex - centerx) < glMatrix.EPSILON && Math.abs(eyey - centery) < glMatrix.EPSILON && Math.abs(eyez - centerz) < glMatrix.EPSILON) {\n    return identity(out);\n  }\n\n  z0 = eyex - centerx;\n  z1 = eyey - centery;\n  z2 = eyez - centerz;\n  len = 1 / Math.hypot(z0, z1, z2);\n  z0 *= len;\n  z1 *= len;\n  z2 *= len;\n  x0 = upy * z2 - upz * z1;\n  x1 = upz * z0 - upx * z2;\n  x2 = upx * z1 - upy * z0;\n  len = Math.hypot(x0, x1, x2);\n\n  if (!len) {\n    x0 = 0;\n    x1 = 0;\n    x2 = 0;\n  } else {\n    len = 1 / len;\n    x0 *= len;\n    x1 *= len;\n    x2 *= len;\n  }\n\n  y0 = z1 * x2 - z2 * x1;\n  y1 = z2 * x0 - z0 * x2;\n  y2 = z0 * x1 - z1 * x0;\n  len = Math.hypot(y0, y1, y2);\n\n  if (!len) {\n    y0 = 0;\n    y1 = 0;\n    y2 = 0;\n  } else {\n    len = 1 / len;\n    y0 *= len;\n    y1 *= len;\n    y2 *= len;\n  }\n\n  out[0] = x0;\n  out[1] = y0;\n  out[2] = z0;\n  out[3] = 0;\n  out[4] = x1;\n  out[5] = y1;\n  out[6] = z1;\n  out[7] = 0;\n  out[8] = x2;\n  out[9] = y2;\n  out[10] = z2;\n  out[11] = 0;\n  out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);\n  out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);\n  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);\n  out[15] = 1;\n  return out;\n}\n/**\n * Generates a matrix that makes something look at something else.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {ReadonlyVec3} eye Position of the viewer\n * @param {ReadonlyVec3} center Point the viewer is looking at\n * @param {ReadonlyVec3} up vec3 pointing up\n * @returns {mat4} out\n */\n\nexport function targetTo(out, eye, target, up) {\n  var eyex = eye[0],\n      eyey = eye[1],\n      eyez = eye[2],\n      upx = up[0],\n      upy = up[1],\n      upz = up[2];\n  var z0 = eyex - target[0],\n      z1 = eyey - target[1],\n      z2 = eyez - target[2];\n  var len = z0 * z0 + z1 * z1 + z2 * z2;\n\n  if (len > 0) {\n    len = 1 / Math.sqrt(len);\n    z0 *= len;\n    z1 *= len;\n    z2 *= len;\n  }\n\n  var x0 = upy * z2 - upz * z1,\n      x1 = upz * z0 - upx * z2,\n      x2 = upx * z1 - upy * z0;\n  len = x0 * x0 + x1 * x1 + x2 * x2;\n\n  if (len > 0) {\n    len = 1 / Math.sqrt(len);\n    x0 *= len;\n    x1 *= len;\n    x2 *= len;\n  }\n\n  out[0] = x0;\n  out[1] = x1;\n  out[2] = x2;\n  out[3] = 0;\n  out[4] = z1 * x2 - z2 * x1;\n  out[5] = z2 * x0 - z0 * x2;\n  out[6] = z0 * x1 - z1 * x0;\n  out[7] = 0;\n  out[8] = z0;\n  out[9] = z1;\n  out[10] = z2;\n  out[11] = 0;\n  out[12] = eyex;\n  out[13] = eyey;\n  out[14] = eyez;\n  out[15] = 1;\n  return out;\n}\n/**\n * Returns a string representation of a mat4\n *\n * @param {ReadonlyMat4} a matrix to represent as a string\n * @returns {String} string representation of the matrix\n */\n\nexport function str(a) {\n  return \"mat4(\" + a[0] + \", \" + a[1] + \", \" + a[2] + \", \" + a[3] + \", \" + a[4] + \", \" + a[5] + \", \" + a[6] + \", \" + a[7] + \", \" + a[8] + \", \" + a[9] + \", \" + a[10] + \", \" + a[11] + \", \" + a[12] + \", \" + a[13] + \", \" + a[14] + \", \" + a[15] + \")\";\n}\n/**\n * Returns Frobenius norm of a mat4\n *\n * @param {ReadonlyMat4} a the matrix to calculate Frobenius norm of\n * @returns {Number} Frobenius norm\n */\n\nexport function frob(a) {\n  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]);\n}\n/**\n * Adds two mat4's\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the first operand\n * @param {ReadonlyMat4} b the second operand\n * @returns {mat4} out\n */\n\nexport function add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  out[3] = a[3] + b[3];\n  out[4] = a[4] + b[4];\n  out[5] = a[5] + b[5];\n  out[6] = a[6] + b[6];\n  out[7] = a[7] + b[7];\n  out[8] = a[8] + b[8];\n  out[9] = a[9] + b[9];\n  out[10] = a[10] + b[10];\n  out[11] = a[11] + b[11];\n  out[12] = a[12] + b[12];\n  out[13] = a[13] + b[13];\n  out[14] = a[14] + b[14];\n  out[15] = a[15] + b[15];\n  return out;\n}\n/**\n * Subtracts matrix b from matrix a\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the first operand\n * @param {ReadonlyMat4} b the second operand\n * @returns {mat4} out\n */\n\nexport function subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  out[3] = a[3] - b[3];\n  out[4] = a[4] - b[4];\n  out[5] = a[5] - b[5];\n  out[6] = a[6] - b[6];\n  out[7] = a[7] - b[7];\n  out[8] = a[8] - b[8];\n  out[9] = a[9] - b[9];\n  out[10] = a[10] - b[10];\n  out[11] = a[11] - b[11];\n  out[12] = a[12] - b[12];\n  out[13] = a[13] - b[13];\n  out[14] = a[14] - b[14];\n  out[15] = a[15] - b[15];\n  return out;\n}\n/**\n * Multiply each element of the matrix by a scalar.\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to scale\n * @param {Number} b amount to scale the matrix's elements by\n * @returns {mat4} out\n */\n\nexport function multiplyScalar(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  out[3] = a[3] * b;\n  out[4] = a[4] * b;\n  out[5] = a[5] * b;\n  out[6] = a[6] * b;\n  out[7] = a[7] * b;\n  out[8] = a[8] * b;\n  out[9] = a[9] * b;\n  out[10] = a[10] * b;\n  out[11] = a[11] * b;\n  out[12] = a[12] * b;\n  out[13] = a[13] * b;\n  out[14] = a[14] * b;\n  out[15] = a[15] * b;\n  return out;\n}\n/**\n * Adds two mat4's after multiplying each element of the second operand by a scalar value.\n *\n * @param {mat4} out the receiving vector\n * @param {ReadonlyMat4} a the first operand\n * @param {ReadonlyMat4} b the second operand\n * @param {Number} scale the amount to scale b's elements by before adding\n * @returns {mat4} out\n */\n\nexport function multiplyScalarAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  out[3] = a[3] + b[3] * scale;\n  out[4] = a[4] + b[4] * scale;\n  out[5] = a[5] + b[5] * scale;\n  out[6] = a[6] + b[6] * scale;\n  out[7] = a[7] + b[7] * scale;\n  out[8] = a[8] + b[8] * scale;\n  out[9] = a[9] + b[9] * scale;\n  out[10] = a[10] + b[10] * scale;\n  out[11] = a[11] + b[11] * scale;\n  out[12] = a[12] + b[12] * scale;\n  out[13] = a[13] + b[13] * scale;\n  out[14] = a[14] + b[14] * scale;\n  out[15] = a[15] + b[15] * scale;\n  return out;\n}\n/**\n * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyMat4} a The first matrix.\n * @param {ReadonlyMat4} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\n\nexport function exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];\n}\n/**\n * Returns whether or not the matrices have approximately the same elements in the same position.\n *\n * @param {ReadonlyMat4} a The first matrix.\n * @param {ReadonlyMat4} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\n\nexport function equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3];\n  var a4 = a[4],\n      a5 = a[5],\n      a6 = a[6],\n      a7 = a[7];\n  var a8 = a[8],\n      a9 = a[9],\n      a10 = a[10],\n      a11 = a[11];\n  var a12 = a[12],\n      a13 = a[13],\n      a14 = a[14],\n      a15 = a[15];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3];\n  var b4 = b[4],\n      b5 = b[5],\n      b6 = b[6],\n      b7 = b[7];\n  var b8 = b[8],\n      b9 = b[9],\n      b10 = b[10],\n      b11 = b[11];\n  var b12 = b[12],\n      b13 = b[13],\n      b14 = b[14],\n      b15 = b[15];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a15), Math.abs(b15));\n}\n/**\n * Alias for {@link mat4.multiply}\n * @function\n */\n\nexport var mul = multiply;\n/**\n * Alias for {@link mat4.subtract}\n * @function\n */\n\nexport var sub = subtract;", "import { determinant, getRotation } from 'gl-matrix/mat4';\nimport { length } from 'gl-matrix/vec3';\nimport type { mat4, vec3, vec4 } from '../constants.js';\nimport type { GLTF } from '../types/gltf.js';\n\n/** @hidden */\nexport class MathUtils {\n\tpublic static identity(v: number): number {\n\t\treturn v;\n\t}\n\n\tpublic static eq(a: number[], b: number[], tolerance = 10e-6): boolean {\n\t\tif (a.length !== b.length) return false;\n\n\t\tfor (let i = 0; i < a.length; i++) {\n\t\t\tif (Math.abs(a[i] - b[i]) > tolerance) return false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tpublic static decodeNormalizedInt(c: number, componentType: GLTF.AccessorComponentType): number {\n\t\t// Hardcode enums from accessor.ts to avoid a circular dependency.\n\t\tswitch (componentType) {\n\t\t\tcase 5126:\n\t\t\t\treturn c;\n\t\t\tcase 5123:\n\t\t\t\treturn c / 65535.0;\n\t\t\tcase 5121:\n\t\t\t\treturn c / 255.0;\n\t\t\tcase 5122:\n\t\t\t\treturn Math.max(c / 32767.0, -1.0);\n\t\t\tcase 5120:\n\t\t\t\treturn Math.max(c / 127.0, -1.0);\n\t\t\tdefault:\n\t\t\t\tthrow new Error('Invalid component type.');\n\t\t}\n\t}\n\n\t/** @deprecated Renamed to {@link MathUtils.decodeNormalizedInt}. */\n\tpublic static denormalize(c: number, componentType: GLTF.AccessorComponentType): number {\n\t\treturn MathUtils.decodeNormalizedInt(c, componentType);\n\t}\n\n\tpublic static encodeNormalizedInt(f: number, componentType: GLTF.AccessorComponentType): number {\n\t\t// Hardcode enums from accessor.ts to avoid a circular dependency.\n\t\tswitch (componentType) {\n\t\t\tcase 5126:\n\t\t\t\treturn f;\n\t\t\tcase 5123:\n\t\t\t\treturn Math.round(f * 65535.0);\n\t\t\tcase 5121:\n\t\t\t\treturn Math.round(f * 255.0);\n\t\t\tcase 5122:\n\t\t\t\treturn Math.round(f * 32767.0);\n\t\t\tcase 5120:\n\t\t\t\treturn Math.round(f * 127.0);\n\t\t\tdefault:\n\t\t\t\tthrow new Error('Invalid component type.');\n\t\t}\n\t}\n\n\t/** @deprecated Renamed to {@link MathUtils.encodeNormalizedInt}. */\n\tpublic static normalize(f: number, componentType: GLTF.AccessorComponentType): number {\n\t\treturn MathUtils.encodeNormalizedInt(f, componentType);\n\t}\n\n\t/**\n\t * Decompose a mat4 to TRS properties.\n\t *\n\t * Equivalent to the Matrix4 decompose() method in three.js, and intentionally not using the\n\t * gl-matrix version. See: https://github.com/toji/gl-matrix/issues/408\n\t *\n\t * @param srcMat Matrix element, to be decomposed to TRS properties.\n\t * @param dstTranslation Translation element, to be overwritten.\n\t * @param dstRotation Rotation element, to be overwritten.\n\t * @param dstScale Scale element, to be overwritten.\n\t */\n\tpublic static decompose(srcMat: mat4, dstTranslation: vec3, dstRotation: vec4, dstScale: vec3): void {\n\t\tlet sx = length([srcMat[0], srcMat[1], srcMat[2]]);\n\t\tconst sy = length([srcMat[4], srcMat[5], srcMat[6]]);\n\t\tconst sz = length([srcMat[8], srcMat[9], srcMat[10]]);\n\n\t\t// if determine is negative, we need to invert one scale\n\t\tconst det = determinant(srcMat);\n\t\tif (det < 0) sx = -sx;\n\n\t\tdstTranslation[0] = srcMat[12];\n\t\tdstTranslation[1] = srcMat[13];\n\t\tdstTranslation[2] = srcMat[14];\n\n\t\t// scale the rotation part\n\t\tconst _m1 = srcMat.slice();\n\n\t\tconst invSX = 1 / sx;\n\t\tconst invSY = 1 / sy;\n\t\tconst invSZ = 1 / sz;\n\n\t\t_m1[0] *= invSX;\n\t\t_m1[1] *= invSX;\n\t\t_m1[2] *= invSX;\n\n\t\t_m1[4] *= invSY;\n\t\t_m1[5] *= invSY;\n\t\t_m1[6] *= invSY;\n\n\t\t_m1[8] *= invSZ;\n\t\t_m1[9] *= invSZ;\n\t\t_m1[10] *= invSZ;\n\n\t\tgetRotation(dstRotation, _m1 as mat4);\n\n\t\tdstScale[0] = sx;\n\t\tdstScale[1] = sy;\n\t\tdstScale[2] = sz;\n\t}\n\n\t/**\n\t * Compose TRS properties to a mat4.\n\t *\n\t * Equivalent to the Matrix4 compose() method in three.js, and intentionally not using the\n\t * gl-matrix version. See: https://github.com/toji/gl-matrix/issues/408\n\t *\n\t * @param srcTranslation Translation element of matrix.\n\t * @param srcRotation Rotation element of matrix.\n\t * @param srcScale Scale element of matrix.\n\t * @param dstMat Matrix element, to be modified and returned.\n\t * @returns dstMat, overwritten to mat4 equivalent of given TRS properties.\n\t */\n\tpublic static compose(srcTranslation: vec3, srcRotation: vec4, srcScale: vec3, dstMat: mat4): mat4 {\n\t\tconst te = dstMat;\n\n\t\tconst x = srcRotation[0],\n\t\t\ty = srcRotation[1],\n\t\t\tz = srcRotation[2],\n\t\t\tw = srcRotation[3];\n\t\tconst x2 = x + x,\n\t\t\ty2 = y + y,\n\t\t\tz2 = z + z;\n\t\tconst xx = x * x2,\n\t\t\txy = x * y2,\n\t\t\txz = x * z2;\n\t\tconst yy = y * y2,\n\t\t\tyz = y * z2,\n\t\t\tzz = z * z2;\n\t\tconst wx = w * x2,\n\t\t\twy = w * y2,\n\t\t\twz = w * z2;\n\n\t\tconst sx = srcScale[0],\n\t\t\tsy = srcScale[1],\n\t\t\tsz = srcScale[2];\n\n\t\tte[0] = (1 - (yy + zz)) * sx;\n\t\tte[1] = (xy + wz) * sx;\n\t\tte[2] = (xz - wy) * sx;\n\t\tte[3] = 0;\n\n\t\tte[4] = (xy - wz) * sy;\n\t\tte[5] = (1 - (xx + zz)) * sy;\n\t\tte[6] = (yz + wx) * sy;\n\t\tte[7] = 0;\n\n\t\tte[8] = (xz + wy) * sz;\n\t\tte[9] = (yz - wx) * sz;\n\t\tte[10] = (1 - (xx + yy)) * sz;\n\t\tte[11] = 0;\n\n\t\tte[12] = srcTranslation[0];\n\t\tte[13] = srcTranslation[1];\n\t\tte[14] = srcTranslation[2];\n\t\tte[15] = 1;\n\n\t\treturn te;\n\t}\n}\n", "import type { GraphEdge } from 'property-graph';\nimport { isPlainObject } from './is-plain-object.js';\nimport type { BufferViewUsage } from '../constants.js';\nimport type { Property } from '../properties/index.js';\n\nexport type Ref = GraphEdge<Property, Property>;\nexport type RefMap = { [key: string]: Ref };\nexport type UnknownRef = Ref | Ref[] | RefMap | unknown;\n\nexport function equalsRef(refA: Ref, refB: Ref): boolean {\n\tif (!!refA !== !!refB) return false;\n\n\tconst a = refA.getChild();\n\tconst b = refB.getChild();\n\n\treturn a === b || a.equals(b);\n}\n\nexport function equalsRefList(refListA: Ref[], refListB: Ref[]): boolean {\n\tif (!!refListA !== !!refListB) return false;\n\tif (refListA.length !== refListB.length) return false;\n\n\tfor (let i = 0; i < refListA.length; i++) {\n\t\tconst a = refListA[i];\n\t\tconst b = refListB[i];\n\n\t\tif (a.getChild() === b.getChild()) continue;\n\n\t\tif (!a.getChild().equals(b.getChild())) return false;\n\t}\n\n\treturn true;\n}\n\nexport function equalsRefMap(refMapA: RefMap, refMapB: RefMap): boolean {\n\tif (!!refMapA !== !!refMapB) return false;\n\n\tconst keysA = Object.keys(refMapA);\n\tconst keysB = Object.keys(refMapB);\n\tif (keysA.length !== keysB.length) return false;\n\n\tfor (const key in refMapA) {\n\t\tconst refA = refMapA[key];\n\t\tconst refB = refMapB[key];\n\t\tif (!!refA !== !!refB) return false;\n\n\t\tconst a = refA.getChild();\n\t\tconst b = refB.getChild();\n\t\tif (a === b) continue;\n\n\t\tif (!a.equals(b)) return false;\n\t}\n\n\treturn true;\n}\n\nexport function equalsArray(a: ArrayLike<unknown> | null, b: ArrayLike<unknown> | null): boolean {\n\tif (a === b) return true;\n\n\tif (!!a !== !!b || !a || !b) return false;\n\n\tif (a.length !== b.length) return false;\n\n\tfor (let i = 0; i < a.length; i++) {\n\t\tif (a[i] !== b[i]) return false;\n\t}\n\n\treturn true;\n}\n\nexport function equalsObject(_a: unknown, _b: unknown): boolean {\n\tif (_a === _b) return true;\n\tif (!!_a !== !!_b) return false;\n\tif (!isPlainObject(_a) || !isPlainObject(_b)) {\n\t\treturn _a === _b;\n\t}\n\n\tconst a = _a as Record<string, unknown>;\n\tconst b = _b as Record<string, unknown>;\n\n\tlet numKeysA = 0;\n\tlet numKeysB = 0;\n\n\tlet key: string;\n\n\tfor (key in a) numKeysA++;\n\tfor (key in b) numKeysB++;\n\tif (numKeysA !== numKeysB) return false;\n\n\tfor (key in a) {\n\t\tconst valueA = a[key];\n\t\tconst valueB = b[key];\n\t\tif (isArray(valueA) && isArray(valueB)) {\n\t\t\tif (!equalsArray(valueA as [], valueB as [])) return false;\n\t\t} else if (isPlainObject(valueA) && isPlainObject(valueB)) {\n\t\t\tif (!equalsObject(valueA, valueB)) return false;\n\t\t} else {\n\t\t\tif (valueA !== valueB) return false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nexport type RefAttributes = Record<string, unknown>;\n\nexport interface AccessorRefAttributes extends RefAttributes {\n\t/** Usage role of an accessor reference. */\n\tusage: BufferViewUsage | string;\n}\n\nexport interface TextureRefAttributes extends RefAttributes {\n\t/** Bitmask for {@link TextureChannel TextureChannels} used by a texture reference. */\n\tchannels: number;\n\t/**\n\t * Specifies that the texture contains color data (base color, emissive, ),\n\t * rather than non-color data (normal maps, metallic roughness, ). Used\n\t * when tuning texture compression settings.\n\t */\n\tisColor?: boolean;\n}\n\nexport function isArray(value: unknown): boolean {\n\treturn Array.isArray(value) || ArrayBuffer.isView(value);\n}\n", "const ALPHABET = '23456789abdegjkmnpqrvwxyzABDEGJKMNPQRVWXYZ';\nconst UNIQUE_RETRIES = 999;\nconst ID_LENGTH = 6;\n\nconst previousIDs = new Set();\n\nconst generateOne = function (): string {\n\tlet rtn = '';\n\tfor (let i = 0; i < ID_LENGTH; i++) {\n\t\trtn += ALPHABET.charAt(Math.floor(Math.random() * ALPHABET.length));\n\t}\n\treturn rtn;\n};\n\n/**\n * Short ID generator.\n *\n * Generated IDs are short, easy to type, and unique for the duration of the program's execution.\n * Uniqueness across multiple program executions, or on other devices, is not guaranteed. Based on\n * [Short ID Generation in JavaScript](https://tomspencer.dev/blog/2014/11/16/short-id-generation-in-javascript/),\n * with alterations.\n *\n * @category Utilities\n * @hidden\n */\nexport const uuid = function (): string {\n\tfor (let retries = 0; retries < UNIQUE_RETRIES; retries++) {\n\t\tconst id = generateOne();\n\t\tif (!previousIDs.has(id)) {\n\t\t\tpreviousIDs.add(id);\n\t\t\treturn id;\n\t\t}\n\t}\n\treturn '';\n};\n", "import { FileUtils } from './file-utils.js';\n\n// Need a placeholder domain to construct a URL from a relative path. We only\n// access `url.pathname`, so the domain doesn't matter.\nconst NULL_DOMAIN = 'https://null.example';\n\n/**\n * *Utility class for working with URLs.*\n *\n * @category Utilities\n */\nexport class HTTPUtils {\n\tstatic readonly DEFAULT_INIT: RequestInit = {};\n\tstatic readonly PROTOCOL_REGEXP = /^[a-zA-Z]+:\\/\\//;\n\n\tstatic dirname(path: string): string {\n\t\tconst index = path.lastIndexOf('/');\n\t\tif (index === -1) return './';\n\t\treturn path.substring(0, index + 1);\n\t}\n\n\t/**\n\t * Extracts the basename from a URL, e.g. \"folder/model.glb\" -> \"model\".\n\t * See: {@link FileUtils.basename}\n\t */\n\tstatic basename(uri: string): string {\n\t\treturn FileUtils.basename(new URL(uri, NULL_DOMAIN).pathname);\n\t}\n\n\t/**\n\t * Extracts the extension from a URL, e.g. \"folder/model.glb\" -> \"glb\".\n\t * See: {@link FileUtils.extension}\n\t */\n\tstatic extension(uri: string): string {\n\t\treturn FileUtils.extension(new URL(uri, NULL_DOMAIN).pathname);\n\t}\n\n\tstatic resolve(base: string, path: string) {\n\t\tif (!this.isRelativePath(path)) return path;\n\n\t\tconst stack = base.split('/');\n\t\tconst parts = path.split('/');\n\t\tstack.pop();\n\t\tfor (let i = 0; i < parts.length; i++) {\n\t\t\tif (parts[i] === '.') continue;\n\t\t\tif (parts[i] === '..') {\n\t\t\t\tstack.pop();\n\t\t\t} else {\n\t\t\t\tstack.push(parts[i]);\n\t\t\t}\n\t\t}\n\t\treturn stack.join('/');\n\t}\n\n\t/**\n\t * Returns true for URLs containing a protocol, and false for both\n\t * absolute and relative paths.\n\t */\n\tstatic isAbsoluteURL(path: string) {\n\t\treturn this.PROTOCOL_REGEXP.test(path);\n\t}\n\n\t/**\n\t * Returns true for paths that are declared relative to some unknown base\n\t * path. For example, \"foo/bar/\" is relative both \"/foo/bar/\" is not.\n\t */\n\tstatic isRelativePath(path: string): boolean {\n\t\treturn !/^(?:[a-zA-Z]+:)?\\//.test(path);\n\t}\n}\n", "import type { Nullable } from '../constants.js';\nimport {\n\t$attributes,\n\t$immutableKeys,\n\tGraph,\n\tGraphNode,\n\tGraphEdge,\n\tisRef,\n\tisRefList,\n\tisRefMap,\n\tLiteralKeys,\n} from 'property-graph';\nimport {\n\tequalsArray,\n\tequalsObject,\n\tequalsRef,\n\tequalsRefList,\n\tequalsRefMap,\n\tisArray,\n\tisPlainObject,\n} from '../utils/index.js';\nimport type { Ref, RefMap, UnknownRef } from '../utils/index.js';\n\nexport type PropertyResolver<T extends Property> = (p: T) => T;\nexport const COPY_IDENTITY = <T extends Property>(t: T): T => t;\n\nexport interface IProperty {\n\tname: string;\n\textras: Record<string, unknown>;\n}\n\nconst EMPTY_SET = new Set<string>();\n\n/**\n * *Properties represent distinct resources in a glTF asset, referenced by other properties.*\n *\n * For example, each material and texture is a property, with material properties holding\n * references to the textures. All properties are created with factory methods on the\n * {@link Document} in which they should be constructed. Properties are destroyed by calling\n * {@link Property.dispose}().\n *\n * Usage:\n *\n * ```ts\n * const texture = doc.createTexture('myTexture');\n * doc.listTextures(); //  [texture x 1]\n *\n * // Attach a texture to a material.\n * material.setBaseColorTexture(texture);\n * material.getBaseColortexture(); //  texture\n *\n * // Detaching a texture removes any references to it, except from the doc.\n * texture.detach();\n * material.getBaseColorTexture(); //  null\n * doc.listTextures(); //  [texture x 1]\n *\n * // Disposing a texture removes all references to it, and its own references.\n * texture.dispose();\n * doc.listTextures(); //  []\n * ```\n *\n * Reference:\n * - [glTF  Concepts](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#concepts)\n *\n * @category Properties\n */\nexport abstract class Property<T extends IProperty = IProperty> extends GraphNode<T> {\n\t/** Property type. */\n\tpublic abstract readonly propertyType: string;\n\n\t/**\n\t * Internal graph used to search and maintain references.\n\t * @override\n\t * @hidden\n\t */\n\tprotected declare readonly graph: Graph<Property>;\n\n\t/** @hidden */\n\tconstructor(graph: Graph<Property>, name = '') {\n\t\tsuper(graph);\n\t\t(this as Property)[$attributes]['name'] = name;\n\t\tthis.init();\n\t\tthis.dispatchEvent({ type: 'create' });\n\t}\n\n\t/**\n\t * Initializes instance data for a subclass. Because subclass constructors run after the\n\t * constructor of the parent class, and 'create' events dispatched by the parent class\n\t * assume the instance is fully initialized, it's best to do any initialization here.\n\t * @hidden\n\t */\n\tprotected abstract init(): void;\n\n\t/**\n\t * Returns the Graph associated with this Property. For internal use.\n\t * @hidden\n\t * @experimental\n\t */\n\tpublic getGraph(): Graph<Property> {\n\t\treturn this.graph;\n\t}\n\n\t/**\n\t * Returns default attributes for the property. Empty lists and maps should be initialized\n\t * to empty arrays and objects. Always invoke `super.getDefaults()` and extend the result.\n\t */\n\tprotected getDefaults(): Nullable<T> {\n\t\treturn Object.assign(super.getDefaults(), { name: '', extras: {} });\n\t}\n\n\t/** @hidden */\n\tprotected set<K extends LiteralKeys<T>>(attribute: K, value: T[K]): this {\n\t\tif (Array.isArray(value)) value = value.slice() as T[K]; // copy vector, quat, color \n\t\treturn super.set(attribute, value);\n\t}\n\n\t/**********************************************************************************************\n\t * Name.\n\t */\n\n\t/**\n\t * Returns the name of this property. While names are not required to be unique, this is\n\t * encouraged, and non-unique names will be overwritten in some tools. For custom data about\n\t * a property, prefer to use Extras.\n\t */\n\tpublic getName(): string {\n\t\treturn (this as Property).get('name');\n\t}\n\n\t/**\n\t * Sets the name of this property. While names are not required to be unique, this is\n\t * encouraged, and non-unique names will be overwritten in some tools. For custom data about\n\t * a property, prefer to use Extras.\n\t */\n\tpublic setName(name: string): this {\n\t\treturn (this as Property).set('name', name) as this;\n\t}\n\n\t/**********************************************************************************************\n\t * Extras.\n\t */\n\n\t/**\n\t * Returns a reference to the Extras object, containing application-specific data for this\n\t * Property. Extras should be an Object, not a primitive value, for best portability.\n\t */\n\tpublic getExtras(): Record<string, unknown> {\n\t\treturn (this as Property).get('extras');\n\t}\n\n\t/**\n\t * Updates the Extras object, containing application-specific data for this Property. Extras\n\t * should be an Object, not a primitive value, for best portability.\n\t */\n\tpublic setExtras(extras: Record<string, unknown>): this {\n\t\treturn (this as Property).set('extras', extras) as this;\n\t}\n\n\t/**********************************************************************************************\n\t * Graph state.\n\t */\n\n\t/**\n\t * Makes a copy of this property, with the same resources (by reference) as the original.\n\t */\n\tpublic clone(): this {\n\t\tconst PropertyClass = this.constructor as new (g: Graph<Property>) => this;\n\t\treturn new PropertyClass(this.graph).copy(this, COPY_IDENTITY);\n\t}\n\n\t/**\n\t * Copies all data from another property to this one. Child properties are copied by reference,\n\t * unless a 'resolve' function is given to override that.\n\t * @param other Property to copy references from.\n\t * @param resolve Function to resolve each Property being transferred. Default is identity.\n\t */\n\tpublic copy(other: this, resolve: PropertyResolver<Property> = COPY_IDENTITY): this {\n\t\t// Remove previous references.\n\t\tfor (const key in this[$attributes]) {\n\t\t\tconst value = this[$attributes][key];\n\t\t\tif (value instanceof GraphEdge) {\n\t\t\t\tif (!this[$immutableKeys].has(key)) {\n\t\t\t\t\tvalue.dispose();\n\t\t\t\t}\n\t\t\t} else if (isRefList(value)) {\n\t\t\t\tfor (const ref of value as unknown as Ref[]) {\n\t\t\t\t\tref.dispose();\n\t\t\t\t}\n\t\t\t} else if (isRefMap(value)) {\n\t\t\t\tfor (const subkey in value) {\n\t\t\t\t\tconst ref = value[subkey] as Ref;\n\t\t\t\t\tref.dispose();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Add new references.\n\t\tfor (const key in other[$attributes]) {\n\t\t\tconst thisValue = this[$attributes][key];\n\t\t\tconst otherValue = other[$attributes][key];\n\t\t\tif (otherValue instanceof GraphEdge) {\n\t\t\t\tif (this[$immutableKeys].has(key)) {\n\t\t\t\t\tconst ref = thisValue as unknown as Ref;\n\t\t\t\t\tref.getChild().copy(resolve(otherValue.getChild()), resolve);\n\t\t\t\t} else {\n\t\t\t\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t\t\t\t\tthis.setRef(key as any, resolve(otherValue.getChild()), otherValue.getAttributes());\n\t\t\t\t}\n\t\t\t} else if (isRefList(otherValue)) {\n\t\t\t\tfor (const ref of otherValue as unknown as Ref[]) {\n\t\t\t\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t\t\t\t\tthis.addRef(key as any, resolve(ref.getChild()), ref.getAttributes());\n\t\t\t\t}\n\t\t\t} else if (isRefMap(otherValue)) {\n\t\t\t\tfor (const subkey in otherValue) {\n\t\t\t\t\tconst ref = otherValue[subkey] as Ref;\n\t\t\t\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t\t\t\t\tthis.setRefMap(key as any, subkey, resolve(ref.getChild()), ref.getAttributes());\n\t\t\t\t}\n\t\t\t} else if (isPlainObject(otherValue)) {\n\t\t\t\tthis[$attributes][key] = JSON.parse(JSON.stringify(otherValue));\n\t\t\t} else if (\n\t\t\t\tArray.isArray(otherValue) ||\n\t\t\t\totherValue instanceof ArrayBuffer ||\n\t\t\t\tArrayBuffer.isView(otherValue)\n\t\t\t) {\n\t\t\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t\t\t\tthis[$attributes][key] = (otherValue as unknown as Uint8Array).slice() as any;\n\t\t\t} else {\n\t\t\t\tthis[$attributes][key] = otherValue;\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns true if two properties are deeply equivalent, recursively comparing the attributes\n\t * of the properties. Optionally, a 'skip' set may be included, specifying attributes whose\n\t * values should not be considered in the comparison.\n\t *\n\t * Example: Two {@link Primitive Primitives} are equivalent if they have accessors and\n\t * materials with equivalent content  but not necessarily the same specific accessors\n\t * and materials.\n\t */\n\tpublic equals(other: this, skip = EMPTY_SET): boolean {\n\t\tif (this === other) return true;\n\t\tif (this.propertyType !== other.propertyType) return false;\n\n\t\tfor (const key in this[$attributes]) {\n\t\t\tif (skip.has(key)) continue;\n\n\t\t\tconst a = this[$attributes][key] as UnknownRef;\n\t\t\tconst b = other[$attributes][key] as UnknownRef;\n\n\t\t\tif (isRef(a) || isRef(b)) {\n\t\t\t\tif (!equalsRef(a as Ref, b as Ref)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t} else if (isRefList(a) || isRefList(b)) {\n\t\t\t\tif (!equalsRefList(a as Ref[], b as Ref[])) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t} else if (isRefMap(a) || isRefMap(b)) {\n\t\t\t\tif (!equalsRefMap(a as RefMap, b as RefMap)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t} else if (isPlainObject(a) || isPlainObject(b)) {\n\t\t\t\tif (!equalsObject(a, b)) return false;\n\t\t\t} else if (isArray(a) || isArray(b)) {\n\t\t\t\tif (!equalsArray(a as [], b as [])) return false;\n\t\t\t} else {\n\t\t\t\t// Literal.\n\t\t\t\tif (a !== b) return false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tpublic detach(): this {\n\t\t// Detaching should keep properties in the same Document, and attached to its root.\n\t\tthis.graph.disconnectParents(this, (n: Property) => n.propertyType !== 'Root');\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns a list of all properties that hold a reference to this property. For example, a\n\t * material may hold references to various textures, but a texture does not hold references\n\t * to the materials that use it.\n\t *\n\t * It is often necessary to filter the results for a particular type: some resources, like\n\t * {@link Accessor}s, may be referenced by different types of properties. Most properties\n\t * include the {@link Root} as a parent, which is usually not of interest.\n\t *\n\t * Usage:\n\t *\n\t * ```ts\n\t * const materials = texture\n\t * \t.listParents()\n\t * \t.filter((p) => p instanceof Material)\n\t * ```\n\t */\n\tpublic listParents(): Property[] {\n\t\treturn this.graph.listParents(this);\n\t}\n}\n", "import type { Nullable } from '../constants.js';\nimport type { ExtensionProperty } from './extension-property.js';\nimport { Property, IProperty } from './property.js';\n\nexport interface IExtensibleProperty extends IProperty {\n\textensions: { [key: string]: ExtensionProperty };\n}\n\n/**\n * *A {@link Property} that can have {@link ExtensionProperty} instances attached.*\n *\n * Most properties are extensible. See the {@link Extension} documentation for information about\n * how to use extensions.\n *\n * @category Properties\n */\nexport abstract class ExtensibleProperty<T extends IExtensibleProperty = IExtensibleProperty> extends Property<T> {\n\tprotected getDefaults(): Nullable<T> {\n\t\treturn Object.assign(super.getDefaults(), { extensions: {} });\n\t}\n\n\t/** Returns an {@link ExtensionProperty} attached to this Property, if any. */\n\tpublic getExtension<Prop extends ExtensionProperty>(name: string): Prop | null {\n\t\treturn (this as ExtensibleProperty).getRefMap('extensions', name) as Prop;\n\t}\n\n\t/**\n\t * Attaches the given {@link ExtensionProperty} to this Property. For a given extension, only\n\t * one ExtensionProperty may be attached to any one Property at a time.\n\t */\n\tpublic setExtension<Prop extends ExtensionProperty>(name: string, extensionProperty: Prop | null): this {\n\t\tif (extensionProperty) extensionProperty._validateParent(this as ExtensibleProperty);\n\t\treturn (this as ExtensibleProperty).setRefMap('extensions', name, extensionProperty) as this;\n\t}\n\n\t/** Lists all {@link ExtensionProperty} instances attached to this Property. */\n\tpublic listExtensions(): ExtensionProperty[] {\n\t\treturn (this as ExtensibleProperty).listRefMapValues('extensions');\n\t}\n}\n", "import { Nullable, PropertyType, TypedArray } from '../constants.js';\nimport type { GLTF } from '../types/gltf.js';\nimport { MathUtils } from '../utils/index.js';\nimport type { Buffer } from './buffer.js';\nimport { ExtensibleProperty, IExtensibleProperty } from './extensible-property.js';\nimport { COPY_IDENTITY } from './property.js';\n\ninterface IAccessor extends IExtensibleProperty {\n\tarray: TypedArray | null;\n\ttype: GLTF.AccessorType;\n\tcomponentType: GLTF.AccessorComponentType;\n\tnormalized: boolean;\n\tsparse: boolean;\n\tbuffer: Buffer;\n}\n\n/**\n * *Accessors store lists of numeric, vector, or matrix elements in a typed array.*\n *\n * All large data for {@link Mesh}, {@link Skin}, and {@link Animation} properties is stored in\n * {@link Accessor}s, organized into one or more {@link Buffer}s. Each accessor provides data in\n * typed arrays, with two abstractions:\n *\n * *Elements* are the logical divisions of the data into useful types: `\"SCALAR\"`, `\"VEC2\"`,\n * `\"VEC3\"`, `\"VEC4\"`, `\"MAT3\"`, or `\"MAT4\"`. The element type can be determined with the\n * {@link Accessor.getType getType}() method, and the number of elements in the accessor determine its\n * {@link Accessor.getCount getCount}(). The number of components in an element  e.g. 9 for `\"MAT3\"`  are its\n * {@link Accessor.getElementSize getElementSize}(). See {@link Accessor.Type}.\n *\n * *Components* are the numeric values within an element  e.g. `.x` and `.y` for `\"VEC2\"`. Various\n * component types are available: `BYTE`, `UNSIGNED_BYTE`, `SHORT`, `UNSIGNED_SHORT`,\n * `UNSIGNED_INT`, and `FLOAT`. The component type can be determined with the\n * {@link Accessor.getComponentType getComponentType} method, and the number of bytes in each component determine its\n * {@link Accessor.getComponentSize getComponentSize}. See {@link Accessor.ComponentType}.\n *\n * Usage:\n *\n * ```typescript\n * const accessor = doc.createAccessor('myData')\n * \t.setArray(new Float32Array([1,2,3,4,5,6,7,8,9,10,11,12]))\n * \t.setType(Accessor.Type.VEC3)\n * \t.setBuffer(doc.listBuffers()[0]);\n *\n * accessor.getCount();        //  4\n * accessor.getElementSize();  //  3\n * accessor.getByteLength();   //  48\n * accessor.getElement(1, []); //  [4, 5, 6]\n *\n * accessor.setElement(0, [10, 20, 30]);\n * ```\n *\n * Data access through the {@link Accessor.getElement getElement} and {@link Accessor.setElement setElement}\n * methods reads or overwrites the content of the underlying typed array. These methods use\n * element arrays intended to be compatible with the [gl-matrix](https://github.com/toji/gl-matrix)\n * library, or with the `toArray`/`fromArray` methods of libraries like three.js and babylon.js.\n *\n * Each Accessor must be assigned to a {@link Buffer}, which determines where the accessor's data\n * is stored in the final file. Assigning Accessors to different Buffers allows the data to be\n * written to different `.bin` files.\n *\n * glTF Transform does not expose many details of sparse, normalized, or interleaved accessors\n * through its API. It reads files using those techniques, presents a simplified view of the data\n * for editing, and attempts to write data back out with optimizations. For example, vertex\n * attributes will typically be interleaved by default, regardless of the input file.\n *\n * References:\n * - [glTF  Accessors](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#accessors)\n *\n * @category Properties\n */\nexport class Accessor extends ExtensibleProperty<IAccessor> {\n\tpublic declare propertyType: PropertyType.ACCESSOR;\n\n\t/**********************************************************************************************\n\t * Constants.\n\t */\n\n\t/** Element type contained by the accessor (SCALAR, VEC2, ...). */\n\tpublic static Type: Record<string, GLTF.AccessorType> = {\n\t\t/** Scalar, having 1 value per element. */\n\t\tSCALAR: 'SCALAR',\n\t\t/** 2-component vector, having 2 components per element. */\n\t\tVEC2: 'VEC2',\n\t\t/** 3-component vector, having 3 components per element. */\n\t\tVEC3: 'VEC3',\n\t\t/** 4-component vector, having 4 components per element. */\n\t\tVEC4: 'VEC4',\n\t\t/** 2x2 matrix, having 4 components per element. */\n\t\tMAT2: 'MAT2',\n\t\t/** 3x3 matrix, having 9 components per element. */\n\t\tMAT3: 'MAT3',\n\t\t/** 4x3 matrix, having 16 components per element. */\n\t\tMAT4: 'MAT4',\n\t};\n\n\t/** Data type of the values composing each element in the accessor. */\n\tpublic static ComponentType: Record<string, GLTF.AccessorComponentType> = {\n\t\t/**\n\t\t * 1-byte signed integer, stored as\n\t\t * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int8Array Int8Array}.\n\t\t */\n\t\tBYTE: 5120,\n\t\t/**\n\t\t * 1-byte unsigned integer, stored as\n\t\t * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array Uint8Array}.\n\t\t */\n\t\tUNSIGNED_BYTE: 5121,\n\t\t/**\n\t\t * 2-byte signed integer, stored as\n\t\t * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int16Array Int16Array}.\n\t\t */\n\t\tSHORT: 5122,\n\t\t/**\n\t\t * 2-byte unsigned integer, stored as\n\t\t * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint16Array Uint16Array}.\n\t\t */\n\t\tUNSIGNED_SHORT: 5123,\n\t\t/**\n\t\t * 4-byte unsigned integer, stored as\n\t\t * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array Uint32Array}.\n\t\t */\n\t\tUNSIGNED_INT: 5125,\n\t\t/**\n\t\t * 4-byte floating point number, stored as\n\t\t * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array Float32Array}.\n\t\t */\n\t\tFLOAT: 5126,\n\t};\n\n\t/**********************************************************************************************\n\t * Instance.\n\t */\n\n\tprotected init(): void {\n\t\tthis.propertyType = PropertyType.ACCESSOR;\n\t}\n\n\tprotected getDefaults(): Nullable<IAccessor> {\n\t\treturn Object.assign(super.getDefaults() as IExtensibleProperty, {\n\t\t\tarray: null,\n\t\t\ttype: Accessor.Type.SCALAR,\n\t\t\tcomponentType: Accessor.ComponentType.FLOAT,\n\t\t\tnormalized: false,\n\t\t\tsparse: false,\n\t\t\tbuffer: null,\n\t\t});\n\t}\n\n\t/** @internal Inbound transform to normalized representation, if applicable. */\n\tprivate _in = MathUtils.identity;\n\n\t/** @internal Outbound transform from normalized representation, if applicable. */\n\tprivate _out = MathUtils.identity;\n\n\tpublic copy(other: this, resolve = COPY_IDENTITY): this {\n\t\tsuper.copy(other, resolve);\n\t\tthis._in = other._in;\n\t\tthis._out = other._out;\n\t\treturn this;\n\t}\n\n\t/**********************************************************************************************\n\t * Static.\n\t */\n\n\t/** Returns size of a given element type, in components. */\n\tpublic static getElementSize(type: GLTF.AccessorType): number {\n\t\tswitch (type) {\n\t\t\tcase Accessor.Type.SCALAR:\n\t\t\t\treturn 1;\n\t\t\tcase Accessor.Type.VEC2:\n\t\t\t\treturn 2;\n\t\t\tcase Accessor.Type.VEC3:\n\t\t\t\treturn 3;\n\t\t\tcase Accessor.Type.VEC4:\n\t\t\t\treturn 4;\n\t\t\tcase Accessor.Type.MAT2:\n\t\t\t\treturn 4;\n\t\t\tcase Accessor.Type.MAT3:\n\t\t\t\treturn 9;\n\t\t\tcase Accessor.Type.MAT4:\n\t\t\t\treturn 16;\n\t\t\tdefault:\n\t\t\t\tthrow new Error('Unexpected type: ' + type);\n\t\t}\n\t}\n\n\t/** Returns size of a given component type, in bytes. */\n\tpublic static getComponentSize(componentType: GLTF.AccessorComponentType): number {\n\t\tswitch (componentType) {\n\t\t\tcase Accessor.ComponentType.BYTE:\n\t\t\t\treturn 1;\n\t\t\tcase Accessor.ComponentType.UNSIGNED_BYTE:\n\t\t\t\treturn 1;\n\t\t\tcase Accessor.ComponentType.SHORT:\n\t\t\t\treturn 2;\n\t\t\tcase Accessor.ComponentType.UNSIGNED_SHORT:\n\t\t\t\treturn 2;\n\t\t\tcase Accessor.ComponentType.UNSIGNED_INT:\n\t\t\t\treturn 4;\n\t\t\tcase Accessor.ComponentType.FLOAT:\n\t\t\t\treturn 4;\n\t\t\tdefault:\n\t\t\t\tthrow new Error('Unexpected component type: ' + componentType);\n\t\t}\n\t}\n\n\t/**********************************************************************************************\n\t * Min/max bounds.\n\t */\n\n\t/**\n\t * Minimum value of each component in this attribute. Unlike in a final glTF file, values\n\t * returned by this method will reflect the minimum accounting for {@link .normalized}\n\t * state.\n\t */\n\tpublic getMinNormalized(target: number[]): number[] {\n\t\tconst elementSize = this.getElementSize();\n\n\t\tthis.getMin(target);\n\n\t\tfor (let j = 0; j < elementSize; j++) target[j] = this._out(target[j]);\n\n\t\treturn target;\n\t}\n\n\t/**\n\t * Minimum value of each component in this attribute. Values returned by this method do not\n\t * reflect normalization: use {@link .getMinNormalized} in that case.\n\t */\n\tpublic getMin(target: number[]): number[] {\n\t\tconst array = this.get('array');\n\t\tconst count = this.getCount();\n\t\tconst elementSize = this.getElementSize();\n\n\t\tfor (let j = 0; j < elementSize; j++) target[j] = Infinity;\n\n\t\tfor (let i = 0; i < count * elementSize; i += elementSize) {\n\t\t\tfor (let j = 0; j < elementSize; j++) {\n\t\t\t\tconst value = array![i + j];\n\t\t\t\tif (Number.isFinite(value)) {\n\t\t\t\t\ttarget[j] = Math.min(target[j], value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn target;\n\t}\n\n\t/**\n\t * Maximum value of each component in this attribute. Unlike in a final glTF file, values\n\t * returned by this method will reflect the minimum accounting for {@link .normalized}\n\t * state.\n\t */\n\tpublic getMaxNormalized(target: number[]): number[] {\n\t\tconst elementSize = this.getElementSize();\n\n\t\tthis.getMax(target);\n\n\t\tfor (let j = 0; j < elementSize; j++) target[j] = this._out(target[j]);\n\n\t\treturn target;\n\t}\n\n\t/**\n\t * Maximum value of each component in this attribute. Values returned by this method do not\n\t * reflect normalization: use {@link .getMinNormalized} in that case.\n\t */\n\tpublic getMax(target: number[]): number[] {\n\t\tconst array = this.get('array');\n\t\tconst count = this.getCount();\n\t\tconst elementSize = this.getElementSize();\n\n\t\tfor (let j = 0; j < elementSize; j++) target[j] = -Infinity;\n\n\t\tfor (let i = 0; i < count * elementSize; i += elementSize) {\n\t\t\tfor (let j = 0; j < elementSize; j++) {\n\t\t\t\tconst value = array![i + j];\n\t\t\t\tif (Number.isFinite(value)) {\n\t\t\t\t\ttarget[j] = Math.max(target[j], value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn target;\n\t}\n\n\t/**********************************************************************************************\n\t * Layout.\n\t */\n\n\t/**\n\t * Number of elements in the accessor. An array of length 30, containing 10 `VEC3` elements,\n\t * will have a count of 10.\n\t */\n\tpublic getCount(): number {\n\t\tconst array = this.get('array');\n\t\treturn array ? array.length / this.getElementSize() : 0;\n\t}\n\n\t/** Type of element stored in the accessor. `VEC2`, `VEC3`, etc. */\n\tpublic getType(): GLTF.AccessorType {\n\t\treturn this.get('type');\n\t}\n\n\t/**\n\t * Sets type of element stored in the accessor. `VEC2`, `VEC3`, etc. Array length must be a\n\t * multiple of the component size (`VEC2` = 2, `VEC3` = 3, ...) for the selected type.\n\t */\n\tpublic setType(type: GLTF.AccessorType): Accessor {\n\t\treturn this.set('type', type);\n\t}\n\n\t/**\n\t * Number of components in each element of the accessor. For example, the element size of a\n\t * `VEC2` accessor is 2. This value is determined automatically based on array length and\n\t * accessor type, specified with {@link Accessor.setType setType()}.\n\t */\n\tpublic getElementSize(): number {\n\t\treturn Accessor.getElementSize(this.get('type'));\n\t}\n\n\t/**\n\t * Size of each component (a value in the raw array), in bytes. For example, the\n\t * `componentSize` of data backed by a `float32` array is 4 bytes.\n\t */\n\tpublic getComponentSize(): number {\n\t\treturn this.get('array')!.BYTES_PER_ELEMENT;\n\t}\n\n\t/**\n\t * Component type (float32, uint16, etc.). This value is determined automatically, and can only\n\t * be modified by replacing the underlying array.\n\t */\n\tpublic getComponentType(): GLTF.AccessorComponentType {\n\t\treturn this.get('componentType');\n\t}\n\n\t/**********************************************************************************************\n\t * Normalization.\n\t */\n\n\t/**\n\t * Specifies whether integer data values should be normalized (true) to [0, 1] (for unsigned\n\t * types) or [-1, 1] (for signed types), or converted directly (false) when they are accessed.\n\t * This property is defined only for accessors that contain vertex attributes or animation\n\t * output data.\n\t */\n\tpublic getNormalized(): boolean {\n\t\treturn this.get('normalized');\n\t}\n\n\t/**\n\t * Specifies whether integer data values should be normalized (true) to [0, 1] (for unsigned\n\t * types) or [-1, 1] (for signed types), or converted directly (false) when they are accessed.\n\t * This property is defined only for accessors that contain vertex attributes or animation\n\t * output data.\n\t */\n\tpublic setNormalized(normalized: boolean): this {\n\t\tthis.set('normalized', normalized);\n\n\t\tif (normalized) {\n\t\t\tthis._out = (c: number): number => MathUtils.decodeNormalizedInt(c, this.get('componentType'));\n\t\t\tthis._in = (f: number): number => MathUtils.encodeNormalizedInt(f, this.get('componentType'));\n\t\t} else {\n\t\t\tthis._out = MathUtils.identity;\n\t\t\tthis._in = MathUtils.identity;\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**********************************************************************************************\n\t * Data access.\n\t */\n\n\t/**\n\t * Returns the scalar element value at the given index, accounting for normalization if\n\t * applicable.\n\t */\n\tpublic getScalar(index: number): number {\n\t\tconst elementSize = this.getElementSize();\n\t\treturn this._out(this.get('array')![index * elementSize]);\n\t}\n\n\t/**\n\t * Assigns the scalar element value at the given index, accounting for normalization if\n\t * applicable.\n\t */\n\tpublic setScalar(index: number, x: number): this {\n\t\tthis.get('array')![index * this.getElementSize()] = this._in(x);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns the vector or matrix element value at the given index, accounting for normalization\n\t * if applicable.\n\t */\n\tpublic getElement(index: number, target: number[]): number[] {\n\t\tconst elementSize = this.getElementSize();\n\t\tconst array = this.get('array')!;\n\t\tfor (let i = 0; i < elementSize; i++) {\n\t\t\ttarget[i] = this._out(array[index * elementSize + i]);\n\t\t}\n\t\treturn target;\n\t}\n\n\t/**\n\t * Assigns the vector or matrix element value at the given index, accounting for normalization\n\t * if applicable.\n\t */\n\tpublic setElement(index: number, value: number[]): this {\n\t\tconst elementSize = this.getElementSize();\n\t\tconst array = this.get('array')!;\n\t\tfor (let i = 0; i < elementSize; i++) {\n\t\t\tarray![index * elementSize + i] = this._in(value[i]);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**********************************************************************************************\n\t * Raw data storage.\n\t */\n\n\t/**\n\t * Specifies whether the accessor should be stored sparsely. When written to a glTF file, sparse\n\t * accessors store only values that differ from base values. When loaded in glTF Transform (or most\n\t * runtimes) a sparse accessor can be treated like any other accessor. Currently, glTF Transform always\n\t * uses zeroes for the base values when writing files.\n\t * @experimental\n\t */\n\tpublic getSparse(): boolean {\n\t\treturn this.get('sparse');\n\t}\n\n\t/**\n\t * Specifies whether the accessor should be stored sparsely. When written to a glTF file, sparse\n\t * accessors store only values that differ from base values. When loaded in glTF Transform (or most\n\t * runtimes) a sparse accessor can be treated like any other accessor. Currently, glTF Transform always\n\t * uses zeroes for the base values when writing files.\n\t * @experimental\n\t */\n\tpublic setSparse(sparse: boolean): this {\n\t\treturn this.set('sparse', sparse);\n\t}\n\n\t/** Returns the {@link Buffer} into which this accessor will be organized. */\n\tpublic getBuffer(): Buffer | null {\n\t\treturn this.getRef('buffer');\n\t}\n\n\t/** Assigns the {@link Buffer} into which this accessor will be organized. */\n\tpublic setBuffer(buffer: Buffer | null): this {\n\t\treturn this.setRef('buffer', buffer);\n\t}\n\n\t/** Returns the raw typed array underlying this accessor. */\n\tpublic getArray(): TypedArray | null {\n\t\treturn this.get('array');\n\t}\n\n\t/** Assigns the raw typed array underlying this accessor. */\n\tpublic setArray(array: TypedArray): this {\n\t\tthis.set('componentType', array ? arrayToComponentType(array) : Accessor.ComponentType.FLOAT);\n\t\tthis.set('array', array);\n\t\treturn this;\n\t}\n\n\t/** Returns the total bytelength of this accessor, exclusive of padding. */\n\tpublic getByteLength(): number {\n\t\tconst array = this.get('array');\n\t\treturn array ? array.byteLength : 0;\n\t}\n}\n\n/**************************************************************************************************\n * Accessor utilities.\n */\n\n/** @internal */\nfunction arrayToComponentType(array: TypedArray): GLTF.AccessorComponentType {\n\tswitch (array.constructor) {\n\t\tcase Float32Array:\n\t\t\treturn Accessor.ComponentType.FLOAT;\n\t\tcase Uint32Array:\n\t\t\treturn Accessor.ComponentType.UNSIGNED_INT;\n\t\tcase Uint16Array:\n\t\t\treturn Accessor.ComponentType.UNSIGNED_SHORT;\n\t\tcase Uint8Array:\n\t\t\treturn Accessor.ComponentType.UNSIGNED_BYTE;\n\t\tcase Int16Array:\n\t\t\treturn Accessor.ComponentType.SHORT;\n\t\tcase Int8Array:\n\t\t\treturn Accessor.ComponentType.BYTE;\n\t\tdefault:\n\t\t\tthrow new Error('Unknown accessor componentType.');\n\t}\n}\n", "import { Nullable, PropertyType } from '../constants.js';\nimport type { AnimationChannel } from './animation-channel.js';\nimport type { AnimationSampler } from './animation-sampler.js';\nimport { ExtensibleProperty, IExtensibleProperty } from './extensible-property.js';\n\ninterface IAnimation extends IExtensibleProperty {\n\tchannels: AnimationChannel[];\n\tsamplers: AnimationSampler[];\n}\n\n/**\n * *Reusable collections of {@link AnimationChannel}s, together representing a discrete animation\n * clip.*\n *\n * One Animation represents one playable unit in an animation system. Each may contain channels\n * affecting multiple paths (`translation`, `rotation`, `scale`, or `weights`) on multiple\n * {@link Node}s. An Animation's channels must be played together, and do not have any meaning in\n * isolation.\n *\n * Multiple Animations _may_ be played together: for example, one character's _Walk_ animation\n * might play while another character's _Run_ animation plays. Or a single character might have\n * both an _Idle_ and a _Talk_ animation playing at the same time. However, glTF does not define\n * any particular relationship between top-level Animations, or any particular playback behavior\n * like looping or sequences of Animations. General-purpose viewers typically autoplay the first\n * animation and provide UI controls for choosing another. Game engines may have significantly\n * more advanced methods of playing and blending animations.\n *\n * For example, a very simple skinned {@link Mesh} might have two Animations, _Idle_ and _Walk_.\n * Each of those Animations might affect the rotations of two bones, _LegL_ and _LegR_, where the\n * keyframes for each target-path pair are stored in {@link AnimationChannel} instances. In  total,\n * this model would contain two Animations and Four {@link AnimationChannel}s.\n *\n * Usage:\n *\n * ```ts\n * const animation = doc.createAnimation('machineRun')\n * \t.addChannel(rotateCog1)\n * \t.addChannel(rotateCog2)\n * \t.addChannel(rotateCog3);\n * ```\n *\n * Reference\n * - [glTF  Animations](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#animations)\n *\n * @category Properties\n */\nexport class Animation extends ExtensibleProperty<IAnimation> {\n\tpublic declare propertyType: PropertyType.ANIMATION;\n\n\tprotected init(): void {\n\t\tthis.propertyType = PropertyType.ANIMATION;\n\t}\n\n\tprotected getDefaults(): Nullable<IAnimation> {\n\t\treturn Object.assign(super.getDefaults() as IExtensibleProperty, { channels: [], samplers: [] });\n\t}\n\n\t/** Adds an {@link AnimationChannel} to this Animation. */\n\tpublic addChannel(channel: AnimationChannel): this {\n\t\treturn this.addRef('channels', channel);\n\t}\n\n\t/** Removes an {@link AnimationChannel} from this Animation. */\n\tpublic removeChannel(channel: AnimationChannel): this {\n\t\treturn this.removeRef('channels', channel);\n\t}\n\n\t/** Lists {@link AnimationChannel}s in this Animation. */\n\tpublic listChannels(): AnimationChannel[] {\n\t\treturn this.listRefs('channels');\n\t}\n\n\t/** Adds an {@link AnimationSampler} to this Animation. */\n\tpublic addSampler(sampler: AnimationSampler): this {\n\t\treturn this.addRef('samplers', sampler);\n\t}\n\n\t/** Removes an {@link AnimationSampler} from this Animation. */\n\tpublic removeSampler(sampler: AnimationSampler): this {\n\t\treturn this.removeRef('samplers', sampler);\n\t}\n\n\t/** Lists {@link AnimationSampler}s in this Animation. */\n\tpublic listSamplers(): AnimationSampler[] {\n\t\treturn this.listRefs('samplers');\n\t}\n}\n", "import { Nullable, PropertyType } from '../constants.js';\nimport type { GLTF } from '../types/gltf.js';\nimport type { AnimationSampler } from './animation-sampler.js';\nimport { ExtensibleProperty, IExtensibleProperty } from './extensible-property.js';\nimport type { Node } from './node.js';\n\ninterface IAnimationChannel extends IExtensibleProperty {\n\ttargetPath: GLTF.AnimationChannelTargetPath | null;\n\ttargetNode: Node;\n\tsampler: AnimationSampler;\n}\n\n/**\n * *A target-path pair within a larger {@link Animation}, which refers to an\n * {@link AnimationSampler} storing the keyframe data for that pair.*\n *\n * A _target_ is always a {@link Node}, in the core glTF spec. A _path_ is any property of that\n * Node that can be affected by animation: `translation`, `rotation`, `scale`, or `weights`. An\n * {@link Animation} affecting the positions and rotations of several {@link Node}s would contain\n * one channel for each Node-position or Node-rotation pair. The keyframe data for an\n * AnimationChannel is stored in an {@link AnimationSampler}, which must be attached to the same\n * {@link Animation}.\n *\n * Usage:\n *\n * ```ts\n * const node = doc.getRoot()\n * \t.listNodes()\n * \t.find((node) => node.getName() === 'Cog');\n *\n * const channel = doc.createAnimationChannel('cogRotation')\n * \t.setTargetPath('rotation')\n * \t.setTargetNode(node)\n * \t.setSampler(rotateSampler);\n * ```\n *\n * Reference\n * - [glTF  Animations](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#animations)\n *\n * @category Properties\n */\nexport class AnimationChannel extends ExtensibleProperty<IAnimationChannel> {\n\tpublic declare propertyType: PropertyType.ANIMATION_CHANNEL;\n\n\t/**********************************************************************************************\n\t * Constants.\n\t */\n\n\t/** Name of the property to be modified by an animation channel. */\n\tpublic static TargetPath: Record<string, GLTF.AnimationChannelTargetPath> = {\n\t\t/** Channel targets {@link Node.setTranslation}. */\n\t\tTRANSLATION: 'translation',\n\t\t/** Channel targets {@link Node.setRotation}. */\n\t\tROTATION: 'rotation',\n\t\t/** Channel targets {@link Node.setScale}. */\n\t\tSCALE: 'scale',\n\t\t/** Channel targets {@link Node.setWeights}, affecting {@link PrimitiveTarget} weights. */\n\t\tWEIGHTS: 'weights',\n\t};\n\n\t/**********************************************************************************************\n\t * Instance.\n\t */\n\n\tprotected init(): void {\n\t\tthis.propertyType = PropertyType.ANIMATION_CHANNEL;\n\t}\n\n\tprotected getDefaults(): Nullable<IAnimationChannel> {\n\t\treturn Object.assign(super.getDefaults() as IExtensibleProperty, {\n\t\t\ttargetPath: null,\n\t\t\ttargetNode: null,\n\t\t\tsampler: null,\n\t\t});\n\t}\n\n\t/**********************************************************************************************\n\t * Properties.\n\t */\n\n\t/**\n\t * Path (property) animated on the target {@link Node}. Supported values include:\n\t * `translation`, `rotation`, `scale`, or `weights`.\n\t */\n\tpublic getTargetPath(): GLTF.AnimationChannelTargetPath | null {\n\t\treturn this.get('targetPath');\n\t}\n\n\t/**\n\t * Path (property) animated on the target {@link Node}. Supported values include:\n\t * `translation`, `rotation`, `scale`, or `weights`.\n\t */\n\tpublic setTargetPath(targetPath: GLTF.AnimationChannelTargetPath): this {\n\t\treturn this.set('targetPath', targetPath);\n\t}\n\n\t/** Target {@link Node} animated by the channel. */\n\tpublic getTargetNode(): Node | null {\n\t\treturn this.getRef('targetNode');\n\t}\n\n\t/** Target {@link Node} animated by the channel. */\n\tpublic setTargetNode(targetNode: Node | null): this {\n\t\treturn this.setRef('targetNode', targetNode);\n\t}\n\n\t/**\n\t * Keyframe data input/output values for the channel. Must be attached to the same\n\t * {@link Animation}.\n\t */\n\tpublic getSampler(): AnimationSampler | null {\n\t\treturn this.getRef('sampler');\n\t}\n\n\t/**\n\t * Keyframe data input/output values for the channel. Must be attached to the same\n\t * {@link Animation}.\n\t */\n\tpublic setSampler(sampler: AnimationSampler | null): this {\n\t\treturn this.setRef('sampler', sampler);\n\t}\n}\n", "import { BufferViewUsage, Nullable, PropertyType } from '../constants.js';\nimport type { GLTF } from '../types/gltf.js';\nimport type { Accessor } from './accessor.js';\nimport { ExtensibleProperty, IExtensibleProperty } from './extensible-property.js';\n\ninterface IAnimationSampler extends IExtensibleProperty {\n\tinterpolation: GLTF.AnimationSamplerInterpolation;\n\tinput: Accessor;\n\toutput: Accessor;\n}\n\n/**\n * *Reusable collection of keyframes affecting particular property of an object.*\n *\n * Each AnimationSampler refers to an input and an output {@link Accessor}. Input contains times\n * (in seconds) for each keyframe. Output contains values (of any {@link Accessor.Type}) for the\n * animated property at each keyframe. Samplers using `CUBICSPLINE` interpolation will also contain\n * in/out tangents in the output, with the layout:\n *\n * in<sub>1</sub>, value<sub>1</sub>, out<sub>1</sub>,\n * in<sub>2</sub>, value<sub>2</sub>, out<sub>2</sub>,\n * in<sub>3</sub>, value<sub>3</sub>, out<sub>3</sub>, ...\n *\n * Usage:\n *\n * ```ts\n * // Create accessor containing input times, in seconds.\n * const input = doc.createAccessor('bounceTimes')\n * \t.setArray(new Float32Array([0, 1, 2]))\n * \t.setType(Accessor.Type.SCALAR);\n *\n * // Create accessor containing output values, in local units.\n * const output = doc.createAccessor('bounceValues')\n * \t.setArray(new Float32Array([\n * \t\t0, 0, 0, // y = 0\n * \t\t0, 1, 0, // y = 1\n * \t\t0, 0, 0, // y = 0\n * \t]))\n * \t.setType(Accessor.Type.VEC3);\n *\n * // Create sampler.\n * const sampler = doc.createAnimationSampler('bounce')\n * \t.setInput(input)\n * \t.setOutput(output)\n * \t.setInterpolation('LINEAR');\n * ```\n *\n * Reference\n * - [glTF  Animations](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#animations)\n *\n * @category Properties\n */\nexport class AnimationSampler extends ExtensibleProperty<IAnimationSampler> {\n\tpublic declare propertyType: PropertyType.ANIMATION_SAMPLER;\n\n\t/**********************************************************************************************\n\t * Constants.\n\t */\n\n\t/** Interpolation method. */\n\tpublic static Interpolation: Record<string, GLTF.AnimationSamplerInterpolation> = {\n\t\t/** Animated values are linearly interpolated between keyframes. */\n\t\tLINEAR: 'LINEAR',\n\t\t/** Animated values remain constant from one keyframe until the next keyframe. */\n\t\tSTEP: 'STEP',\n\t\t/** Animated values are interpolated according to given cubic spline tangents. */\n\t\tCUBICSPLINE: 'CUBICSPLINE',\n\t};\n\n\t/**********************************************************************************************\n\t * Instance.\n\t */\n\n\tprotected init(): void {\n\t\tthis.propertyType = PropertyType.ANIMATION_SAMPLER;\n\t}\n\n\tprotected getDefaultAttributes(): Nullable<IAnimationSampler> {\n\t\treturn Object.assign(super.getDefaults() as IExtensibleProperty, {\n\t\t\tinterpolation: AnimationSampler.Interpolation.LINEAR,\n\t\t\tinput: null,\n\t\t\toutput: null,\n\t\t});\n\t}\n\n\t/**********************************************************************************************\n\t * Static.\n\t */\n\n\t/** Interpolation mode: `STEP`, `LINEAR`, or `CUBICSPLINE`. */\n\tpublic getInterpolation(): GLTF.AnimationSamplerInterpolation {\n\t\treturn this.get('interpolation');\n\t}\n\n\t/** Interpolation mode: `STEP`, `LINEAR`, or `CUBICSPLINE`. */\n\tpublic setInterpolation(interpolation: GLTF.AnimationSamplerInterpolation): this {\n\t\treturn this.set('interpolation', interpolation);\n\t}\n\n\t/** Times for each keyframe, in seconds. */\n\tpublic getInput(): Accessor | null {\n\t\treturn this.getRef('input');\n\t}\n\n\t/** Times for each keyframe, in seconds. */\n\tpublic setInput(input: Accessor | null): this {\n\t\treturn this.setRef('input', input, { usage: BufferViewUsage.OTHER });\n\t}\n\n\t/**\n\t * Values for each keyframe. For `CUBICSPLINE` interpolation, output also contains in/out\n\t * tangents.\n\t */\n\tpublic getOutput(): Accessor | null {\n\t\treturn this.getRef('output');\n\t}\n\n\t/**\n\t * Values for each keyframe. For `CUBICSPLINE` interpolation, output also contains in/out\n\t * tangents.\n\t */\n\tpublic setOutput(output: Accessor | null): this {\n\t\treturn this.setRef('output', output, { usage: BufferViewUsage.OTHER });\n\t}\n}\n", "import { Nullable, PropertyType } from '../constants.js';\nimport { ExtensibleProperty, IExtensibleProperty } from './extensible-property.js';\n\ninterface IBuffer extends IExtensibleProperty {\n\turi: string;\n}\n\n/**\n * *Buffers are low-level storage units for binary data.*\n *\n * glTF 2.0 has three concepts relevant to binary storage: accessors, buffer views, and buffers.\n * In glTF Transform, an {@link Accessor} is referenced by any property that requires numeric typed\n * array data. Meshes, Primitives, and Animations all reference Accessors. Buffers define how that\n * data is organized into transmitted file(s). A `.glb` file has only a single Buffer, and when\n * exporting to `.glb` your resources should be grouped accordingly. A `.gltf` file may reference\n * one or more `.bin` files  each `.bin` is a Buffer  and grouping Accessors under different\n * Buffers allow you to specify that structure.\n *\n * For engines that can dynamically load portions of a glTF file, splitting data into separate\n * buffers can allow you to avoid loading data until it is needed. For example, you might put\n * binary data for specific meshes into a different `.bin` buffer, or put each animation's binary\n * payload into its own `.bin`.\n *\n * Buffer Views define how Accessors are organized within a given Buffer. glTF Transform creates an\n * efficient Buffer View layout automatically at export: there is no Buffer View property exposed\n * by the glTF Transform API, simplifying data management.\n *\n * Usage:\n *\n * ```ts\n * // Create two buffers with custom filenames.\n * const buffer1 = doc.createBuffer('buffer1')\n * \t.setURI('part1.bin');\n * const buffer2 = doc.createBuffer('buffer2')\n * \t.setURI('part2.bin');\n *\n * // Assign the attributes of two meshes to different buffers. If the meshes\n * // had indices or morph target attributes, you would also want to relocate\n * // those accessors.\n * mesh1\n * \t.listPrimitives()\n * \t.forEach((primitive) => primitive.listAttributes()\n * \t\t.forEach((attribute) => attribute.setBuffer(buffer1)));\n * mesh2\n * \t.listPrimitives()\n * \t.forEach((primitive) => primitive.listAttributes()\n * \t\t.forEach((attribute) => attribute.setBuffer(buffer2)));\n *\n * // Write to disk. Each mesh's binary data will be in a separate binary file;\n * // any remaining accessors will be in a third (default) buffer.\n * await new NodeIO().write('scene.gltf', doc);\n * //  scene.gltf, part1.bin, part2.bin\n * ```\n *\n * References:\n * - [glTF  Buffers and Buffer Views](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#buffers-and-buffer-views)\n * - [glTF  Accessors](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#accessors)\n *\n * @category Properties\n */\nexport class Buffer extends ExtensibleProperty<IBuffer> {\n\tpublic declare propertyType: PropertyType.BUFFER;\n\n\tprotected init(): void {\n\t\tthis.propertyType = PropertyType.BUFFER;\n\t}\n\n\tprotected getDefaults(): Nullable<IBuffer> {\n\t\treturn Object.assign(super.getDefaults() as IExtensibleProperty, { uri: '' });\n\t}\n\n\t/**\n\t * Returns the URI (or filename) of this buffer (e.g. 'myBuffer.bin'). URIs are strongly\n\t * encouraged to be relative paths, rather than absolute. Use of a protocol (like `file://`)\n\t * is possible for custom applications, but will limit the compatibility of the asset with most\n\t * tools.\n\t *\n\t * Buffers commonly use the extension `.bin`, though this is not required.\n\t */\n\tpublic getURI(): string {\n\t\treturn this.get('uri');\n\t}\n\n\t/**\n\t * Sets the URI (or filename) of this buffer (e.g. 'myBuffer.bin'). URIs are strongly\n\t * encouraged to be relative paths, rather than absolute. Use of a protocol (like `file://`)\n\t * is possible for custom applications, but will limit the compatibility of the asset with most\n\t * tools.\n\t *\n\t * Buffers commonly use the extension `.bin`, though this is not required.\n\t */\n\tpublic setURI(uri: string): this {\n\t\treturn this.set('uri', uri);\n\t}\n}\n", "import { Nullable, PropertyType } from '../constants.js';\nimport type { GLTF } from '../types/gltf.js';\nimport { ExtensibleProperty, IExtensibleProperty } from './extensible-property.js';\n\ninterface ICamera extends IExtensibleProperty {\n\ttype: GLTF.CameraType;\n\tznear: number;\n\tzfar: number;\n\taspectRatio: number | null;\n\tyfov: number;\n\txmag: number;\n\tymag: number;\n}\n\n/**\n * *Cameras are perspectives through which the {@link Scene} may be viewed.*\n *\n * Projection can be perspective or orthographic. Cameras are contained in nodes and thus can be\n * transformed. The camera is defined such that the local +X axis is to the right, the lens looks\n * towards the local -Z axis, and the top of the camera is aligned with the local +Y axis. If no\n * transformation is specified, the location of the camera is at the origin.\n *\n * Usage:\n *\n * ```typescript\n * const camera = doc.createCamera('myCamera')\n * \t.setType(GLTF.CameraType.PERSPECTIVE)\n * \t.setZNear(0.1)\n * \t.setZFar(100)\n * \t.setYFov(Math.PI / 4)\n * \t.setAspectRatio(1.5);\n *\n * node.setCamera(camera);\n * ```\n *\n * References:\n * - [glTF  Cameras](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#cameras)\n *\n * @category Properties\n */\nexport class Camera extends ExtensibleProperty<ICamera> {\n\tpublic declare propertyType: PropertyType.CAMERA;\n\n\t/**********************************************************************************************\n\t * Constants.\n\t */\n\n\tpublic static Type: Record<string, GLTF.CameraType> = {\n\t\t/** A perspective camera representing a perspective projection matrix. */\n\t\tPERSPECTIVE: 'perspective',\n\t\t/** An orthographic camera representing an orthographic projection matrix. */\n\t\tORTHOGRAPHIC: 'orthographic',\n\t};\n\n\t/**********************************************************************************************\n\t * Instance.\n\t */\n\n\tprotected init(): void {\n\t\tthis.propertyType = PropertyType.CAMERA;\n\t}\n\n\tprotected getDefaults(): Nullable<ICamera> {\n\t\treturn Object.assign(super.getDefaults() as IExtensibleProperty, {\n\t\t\t// Common.\n\t\t\ttype: Camera.Type.PERSPECTIVE,\n\t\t\tznear: 0.1,\n\t\t\tzfar: 100,\n\t\t\t// Perspective.\n\t\t\taspectRatio: null,\n\t\t\tyfov: (Math.PI * 2 * 50) / 360, // 50\n\t\t\t// Orthographic.\n\t\t\txmag: 1,\n\t\t\tymag: 1,\n\t\t});\n\t}\n\n\t/**********************************************************************************************\n\t * Common.\n\t */\n\n\t/** Specifies if the camera uses a perspective or orthographic projection. */\n\tpublic getType(): GLTF.CameraType {\n\t\treturn this.get('type');\n\t}\n\n\t/** Specifies if the camera uses a perspective or orthographic projection. */\n\tpublic setType(type: GLTF.CameraType): this {\n\t\treturn this.set('type', type);\n\t}\n\n\t/** Floating-point distance to the near clipping plane. */\n\tpublic getZNear(): number {\n\t\treturn this.get('znear');\n\t}\n\n\t/** Floating-point distance to the near clipping plane. */\n\tpublic setZNear(znear: number): this {\n\t\treturn this.set('znear', znear);\n\t}\n\n\t/**\n\t * Floating-point distance to the far clipping plane. When defined, zfar must be greater than\n\t * znear. If zfar is undefined, runtime must use infinite projection matrix.\n\t */\n\tpublic getZFar(): number {\n\t\treturn this.get('zfar');\n\t}\n\n\t/**\n\t * Floating-point distance to the far clipping plane. When defined, zfar must be greater than\n\t * znear. If zfar is undefined, runtime must use infinite projection matrix.\n\t */\n\tpublic setZFar(zfar: number): this {\n\t\treturn this.set('zfar', zfar);\n\t}\n\n\t/**********************************************************************************************\n\t * Perspective.\n\t */\n\n\t/**\n\t * Floating-point aspect ratio of the field of view. When undefined, the aspect ratio of the\n\t * canvas is used.\n\t */\n\tpublic getAspectRatio(): number | null {\n\t\treturn this.get('aspectRatio');\n\t}\n\n\t/**\n\t * Floating-point aspect ratio of the field of view. When undefined, the aspect ratio of the\n\t * canvas is used.\n\t */\n\tpublic setAspectRatio(aspectRatio: number | null): this {\n\t\treturn this.set('aspectRatio', aspectRatio);\n\t}\n\n\t/** Floating-point vertical field of view in radians. */\n\tpublic getYFov(): number {\n\t\treturn this.get('yfov');\n\t}\n\n\t/** Floating-point vertical field of view in radians. */\n\tpublic setYFov(yfov: number): this {\n\t\treturn this.set('yfov', yfov);\n\t}\n\n\t/**********************************************************************************************\n\t * Orthographic.\n\t */\n\n\t/**\n\t * Floating-point horizontal magnification of the view, and half the view's width\n\t * in world units.\n\t */\n\tpublic getXMag(): number {\n\t\treturn this.get('xmag');\n\t}\n\n\t/**\n\t * Floating-point horizontal magnification of the view, and half the view's width\n\t * in world units.\n\t */\n\tpublic setXMag(xmag: number): this {\n\t\treturn this.set('xmag', xmag);\n\t}\n\n\t/**\n\t * Floating-point vertical magnification of the view, and half the view's height\n\t * in world units.\n\t */\n\tpublic getYMag(): number {\n\t\treturn this.get('ymag');\n\t}\n\n\t/**\n\t * Floating-point vertical magnification of the view, and half the view's height\n\t * in world units.\n\t */\n\tpublic setYMag(ymag: number): this {\n\t\treturn this.set('ymag', ymag);\n\t}\n}\n", "import type { ExtensibleProperty } from './extensible-property.js';\nimport { Property, IProperty } from './property.js';\n\n/**\n * *Base class for all {@link Property} types that can be attached by an {@link Extension}.*\n *\n * After an {@link Extension} is attached to a glTF {@link Document}, the Extension may be used to\n * construct ExtensionProperty instances, to be referenced throughout the document as prescribed by\n * the Extension. For example, the `KHR_materials_clearcoat` Extension defines a `Clearcoat`\n * ExtensionProperty, which is referenced by {@link Material} Properties in the Document, and may\n * contain references to {@link Texture} properties of its own.\n *\n * For more information on available extensions and their usage, see [Extensions](/extensions).\n *\n * Reference:\n * - [glTF  Extensions](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#specifying-extensions)\n *\n * @category Properties\n */\nexport abstract class ExtensionProperty<T extends IProperty = IProperty> extends Property<T> {\n\tpublic static EXTENSION_NAME: string;\n\tpublic abstract readonly extensionName: string;\n\n\t/** List of supported {@link Property} types. */\n\tpublic abstract readonly parentTypes: string[];\n\n\t/** @hidden */\n\tpublic _validateParent(parent: ExtensibleProperty): void {\n\t\tif (!this.parentTypes.includes(parent.propertyType)) {\n\t\t\tthrow new Error(`Parent \"${parent.propertyType}\" invalid for child \"${this.propertyType}\".`);\n\t\t}\n\t}\n}\n", "import { Nullable, PropertyType } from '../constants.js';\nimport type { GLTF } from '../types/gltf.js';\nimport { ExtensibleProperty, IExtensibleProperty } from './extensible-property.js';\n\ninterface ITextureInfo extends IExtensibleProperty {\n\ttexCoord: number;\n\n\t// Sampler properties are also attached to TextureInfo, for simplicity.\n\tmagFilter: GLTF.TextureMagFilter | null;\n\tminFilter: GLTF.TextureMinFilter | null;\n\twrapS: GLTF.TextureWrapMode;\n\twrapT: GLTF.TextureWrapMode;\n}\n\n/**\n * *Settings associated with a particular use of a {@link Texture}.*\n *\n * Different materials may reuse the same texture but with different texture coordinates,\n * minFilter/magFilter, or wrapS/wrapT settings. The TextureInfo class contains settings\n * derived from both the \"TextureInfo\" and \"Sampler\" properties in the glTF specification,\n * consolidated here for simplicity.\n *\n * TextureInfo properties cannot be directly created. For any material texture slot, such as\n * baseColorTexture, there will be a corresponding method to obtain the TextureInfo for that slot.\n * For example, see {@link Material.getBaseColorTextureInfo}.\n *\n * References:\n * - [glTF  Texture Info](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#reference-textureinfo)\n *\n * @category Properties\n */\nexport class TextureInfo extends ExtensibleProperty<ITextureInfo> {\n\tpublic declare propertyType: PropertyType.TEXTURE_INFO;\n\n\t/**********************************************************************************************\n\t * Constants.\n\t */\n\n\t/** UV wrapping mode. Values correspond to WebGL enums. */\n\tpublic static WrapMode: Record<string, GLTF.TextureWrapMode> = {\n\t\t/** */\n\t\tCLAMP_TO_EDGE: 33071,\n\t\t/** */\n\t\tMIRRORED_REPEAT: 33648,\n\t\t/** */\n\t\tREPEAT: 10497,\n\t};\n\n\t/** Magnification filter. Values correspond to WebGL enums. */\n\tpublic static MagFilter: Record<string, GLTF.TextureMagFilter> = {\n\t\t/** */\n\t\tNEAREST: 9728,\n\t\t/** */\n\t\tLINEAR: 9729,\n\t};\n\n\t/** Minification filter. Values correspond to WebGL enums. */\n\tpublic static MinFilter: Record<string, GLTF.TextureMinFilter> = {\n\t\t/** */\n\t\tNEAREST: 9728,\n\t\t/** */\n\t\tLINEAR: 9729,\n\t\t/** */\n\t\tNEAREST_MIPMAP_NEAREST: 9984,\n\t\t/** */\n\t\tLINEAR_MIPMAP_NEAREST: 9985,\n\t\t/** */\n\t\tNEAREST_MIPMAP_LINEAR: 9986,\n\t\t/** */\n\t\tLINEAR_MIPMAP_LINEAR: 9987,\n\t};\n\n\t/**********************************************************************************************\n\t * Instance.\n\t */\n\n\tprotected init(): void {\n\t\tthis.propertyType = PropertyType.TEXTURE_INFO;\n\t}\n\n\tprotected getDefaults(): Nullable<ITextureInfo> {\n\t\treturn Object.assign(super.getDefaults() as IExtensibleProperty, {\n\t\t\ttexCoord: 0,\n\t\t\tmagFilter: null,\n\t\t\tminFilter: null,\n\t\t\twrapS: TextureInfo.WrapMode.REPEAT,\n\t\t\twrapT: TextureInfo.WrapMode.REPEAT,\n\t\t});\n\t}\n\n\t/**********************************************************************************************\n\t * Texture coordinates.\n\t */\n\n\t/** Returns the texture coordinate (UV set) index for the texture. */\n\tpublic getTexCoord(): number {\n\t\treturn this.get('texCoord');\n\t}\n\n\t/** Sets the texture coordinate (UV set) index for the texture. */\n\tpublic setTexCoord(texCoord: number): this {\n\t\treturn this.set('texCoord', texCoord);\n\t}\n\n\t/**********************************************************************************************\n\t * Min/mag filter.\n\t */\n\n\t/** Returns the magnification filter applied to the texture. */\n\tpublic getMagFilter(): GLTF.TextureMagFilter | null {\n\t\treturn this.get('magFilter');\n\t}\n\n\t/** Sets the magnification filter applied to the texture. */\n\tpublic setMagFilter(magFilter: GLTF.TextureMagFilter | null): this {\n\t\treturn this.set('magFilter', magFilter);\n\t}\n\n\t/** Sets the minification filter applied to the texture. */\n\tpublic getMinFilter(): GLTF.TextureMinFilter | null {\n\t\treturn this.get('minFilter');\n\t}\n\n\t/** Returns the minification filter applied to the texture. */\n\tpublic setMinFilter(minFilter: GLTF.TextureMinFilter | null): this {\n\t\treturn this.set('minFilter', minFilter);\n\t}\n\n\t/**********************************************************************************************\n\t * UV wrapping.\n\t */\n\n\t/** Returns the S (U) wrapping mode for UVs used by the texture. */\n\tpublic getWrapS(): GLTF.TextureWrapMode {\n\t\treturn this.get('wrapS');\n\t}\n\n\t/** Sets the S (U) wrapping mode for UVs used by the texture. */\n\tpublic setWrapS(wrapS: GLTF.TextureWrapMode): this {\n\t\treturn this.set('wrapS', wrapS);\n\t}\n\n\t/** Returns the T (V) wrapping mode for UVs used by the texture. */\n\tpublic getWrapT(): GLTF.TextureWrapMode {\n\t\treturn this.get('wrapT');\n\t}\n\n\t/** Sets the T (V) wrapping mode for UVs used by the texture. */\n\tpublic setWrapT(wrapT: GLTF.TextureWrapMode): this {\n\t\treturn this.set('wrapT', wrapT);\n\t}\n}\n", "import { Nullable, PropertyType, TextureChannel, vec3, vec4 } from '../constants.js';\nimport type { GLTF } from '../types/gltf.js';\nimport { ColorUtils } from '../utils/index.js';\nimport { ExtensibleProperty, IExtensibleProperty } from './extensible-property.js';\nimport type { Texture } from './texture.js';\nimport { TextureInfo } from './texture-info.js';\n\nconst { R, G, B, A } = TextureChannel;\n\ninterface IMaterial extends IExtensibleProperty {\n\talphaMode: GLTF.MaterialAlphaMode;\n\talphaCutoff: number;\n\tdoubleSided: boolean;\n\tbaseColorFactor: vec4;\n\tbaseColorTexture: Texture;\n\tbaseColorTextureInfo: TextureInfo;\n\temissiveFactor: vec3;\n\temissiveTexture: Texture;\n\temissiveTextureInfo: TextureInfo;\n\tnormalScale: number;\n\tnormalTexture: Texture;\n\tnormalTextureInfo: TextureInfo;\n\tocclusionStrength: number;\n\tocclusionTexture: Texture;\n\tocclusionTextureInfo: TextureInfo;\n\troughnessFactor: number;\n\tmetallicFactor: number;\n\tmetallicRoughnessTexture: Texture;\n\tmetallicRoughnessTextureInfo: TextureInfo;\n}\n\n/**\n * *Materials describe a surface's appearance and response to light.*\n *\n * Each {@link Primitive} within a {@link Mesh} may be assigned a single Material. The number of\n * GPU draw calls typically increases with both the numbers of Primitives and of Materials in an\n * asset; Materials should be reused wherever possible. Techniques like texture atlasing and vertex\n * colors allow objects to have varied appearances while technically sharing a single Material.\n *\n * Material properties are modified by both scalars (like `baseColorFactor`) and textures (like\n * `baseColorTexture`). When both are available, factors are considered linear multipliers against\n * textures of the same name. In the case of base color, vertex colors (`COLOR_0` attributes) are\n * also multiplied.\n *\n * Textures containing color data (`baseColorTexture`, `emissiveTexture`) are sRGB. All other\n * textures are linear. Like other resources, textures should be reused when possible.\n *\n * Usage:\n *\n * ```typescript\n * const material = doc.createMaterial('myMaterial')\n * \t.setBaseColorFactor([1, 0.5, 0.5, 1]) // RGBA\n * \t.setOcclusionTexture(aoTexture)\n * \t.setOcclusionStrength(0.5);\n *\n * mesh.listPrimitives()\n * \t.forEach((prim) => prim.setMaterial(material));\n * ```\n *\n * @category Properties\n */\nexport class Material extends ExtensibleProperty<IMaterial> {\n\tpublic declare propertyType: PropertyType.MATERIAL;\n\n\t/**********************************************************************************************\n\t * Constants.\n\t */\n\n\tpublic static AlphaMode: Record<string, GLTF.MaterialAlphaMode> = {\n\t\t/**\n\t\t * The alpha value is ignored and the rendered output is fully opaque\n\t\t */\n\t\tOPAQUE: 'OPAQUE',\n\t\t/**\n\t\t * The rendered output is either fully opaque or fully transparent depending on the alpha\n\t\t * value and the specified alpha cutoff value\n\t\t */\n\t\tMASK: 'MASK',\n\t\t/**\n\t\t * The alpha value is used to composite the source and destination areas. The rendered\n\t\t * output is combined with the background using the normal painting operation (i.e. the\n\t\t * Porter and Duff over operator)\n\t\t */\n\t\tBLEND: 'BLEND',\n\t};\n\n\t/**********************************************************************************************\n\t * Instance.\n\t */\n\n\tprotected init(): void {\n\t\tthis.propertyType = PropertyType.MATERIAL;\n\t}\n\n\tprotected getDefaults(): Nullable<IMaterial> {\n\t\treturn Object.assign(super.getDefaults() as IExtensibleProperty, {\n\t\t\talphaMode: Material.AlphaMode.OPAQUE,\n\t\t\talphaCutoff: 0.5,\n\t\t\tdoubleSided: false,\n\t\t\tbaseColorFactor: [1, 1, 1, 1] as vec4,\n\t\t\tbaseColorTexture: null,\n\t\t\tbaseColorTextureInfo: new TextureInfo(this.graph, 'baseColorTextureInfo'),\n\t\t\temissiveFactor: [0, 0, 0] as vec3,\n\t\t\temissiveTexture: null,\n\t\t\temissiveTextureInfo: new TextureInfo(this.graph, 'emissiveTextureInfo'),\n\t\t\tnormalScale: 1,\n\t\t\tnormalTexture: null,\n\t\t\tnormalTextureInfo: new TextureInfo(this.graph, 'normalTextureInfo'),\n\t\t\tocclusionStrength: 1,\n\t\t\tocclusionTexture: null,\n\t\t\tocclusionTextureInfo: new TextureInfo(this.graph, 'occlusionTextureInfo'),\n\t\t\troughnessFactor: 1,\n\t\t\tmetallicFactor: 1,\n\t\t\tmetallicRoughnessTexture: null,\n\t\t\tmetallicRoughnessTextureInfo: new TextureInfo(this.graph, 'metallicRoughnessTextureInfo'),\n\t\t});\n\t}\n\n\t/**********************************************************************************************\n\t * Double-sided / culling.\n\t */\n\n\t/** Returns true when both sides of triangles should be rendered. May impact performance. */\n\tpublic getDoubleSided(): boolean {\n\t\treturn this.get('doubleSided');\n\t}\n\n\t/** Sets whether to render both sides of triangles. May impact performance. */\n\tpublic setDoubleSided(doubleSided: boolean): this {\n\t\treturn this.set('doubleSided', doubleSided);\n\t}\n\n\t/**********************************************************************************************\n\t * Alpha.\n\t */\n\n\t/** Returns material alpha, equivalent to baseColorFactor[3]. */\n\tpublic getAlpha(): number {\n\t\treturn this.get('baseColorFactor')[3];\n\t}\n\n\t/** Sets material alpha, equivalent to baseColorFactor[3]. */\n\tpublic setAlpha(alpha: number): this {\n\t\tconst baseColorFactor = this.get('baseColorFactor').slice() as vec4;\n\t\tbaseColorFactor[3] = alpha;\n\t\treturn this.set('baseColorFactor', baseColorFactor);\n\t}\n\n\t/**\n\t * Returns the mode of the material's alpha channels, which are provided by `baseColorFactor`\n\t * and `baseColorTexture`.\n\t *\n\t * - `OPAQUE`: Alpha value is ignored and the rendered output is fully opaque.\n\t * - `BLEND`: Alpha value is used to determine the transparency each pixel on a surface, and\n\t * \tthe fraction of surface vs. background color in the final result. Alpha blending creates\n\t *\tsignificant edge cases in realtime renderers, and some care when structuring the model is\n\t * \tnecessary for good results. In particular, transparent geometry should be kept in separate\n\t * \tmeshes or primitives from opaque geometry. The `depthWrite` or `zWrite` settings in engines\n\t * \tshould usually be disabled on transparent materials.\n\t * - `MASK`: Alpha value is compared against `alphaCutoff` threshold for each pixel on a\n\t * \tsurface, and the pixel is either fully visible or fully discarded based on that cutoff.\n\t * \tThis technique is useful for things like leafs/foliage, grass, fabric meshes, and other\n\t * \tsurfaces where no semitransparency is needed. With a good choice of `alphaCutoff`, surfaces\n\t * \tthat don't require semitransparency can avoid the performance penalties and visual issues\n\t * \tinvolved with `BLEND` transparency.\n\t *\n\t * Reference:\n\t * - [glTF  material.alphaMode](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#materialalphamode)\n\t */\n\tpublic getAlphaMode(): GLTF.MaterialAlphaMode {\n\t\treturn this.get('alphaMode');\n\t}\n\n\t/** Sets the mode of the material's alpha channels. See {@link Material.getAlphaMode getAlphaMode} for details. */\n\tpublic setAlphaMode(alphaMode: GLTF.MaterialAlphaMode): this {\n\t\treturn this.set('alphaMode', alphaMode);\n\t}\n\n\t/** Returns the visibility threshold; applied only when `.alphaMode='MASK'`. */\n\tpublic getAlphaCutoff(): number {\n\t\treturn this.get('alphaCutoff');\n\t}\n\n\t/** Sets the visibility threshold; applied only when `.alphaMode='MASK'`. */\n\tpublic setAlphaCutoff(alphaCutoff: number): this {\n\t\treturn this.set('alphaCutoff', alphaCutoff);\n\t}\n\n\t/**********************************************************************************************\n\t * Base color.\n\t */\n\n\t/**\n\t * Base color / albedo factor; Linear-sRGB components.\n\t * See {@link Material.getBaseColorTexture getBaseColorTexture}.\n\t */\n\tpublic getBaseColorFactor(): vec4 {\n\t\treturn this.get('baseColorFactor');\n\t}\n\n\t/**\n\t * Base color / albedo factor; Linear-sRGB components.\n\t * See {@link Material.getBaseColorTexture getBaseColorTexture}.\n\t */\n\tpublic setBaseColorFactor(baseColorFactor: vec4): this {\n\t\treturn this.set('baseColorFactor', baseColorFactor);\n\t}\n\n\t/**\n\t * Base color / albedo; sRGB hexadecimal color. See {@link Material.getBaseColorTexture getBaseColorTexture}.\n\t */\n\tpublic getBaseColorHex(): number {\n\t\treturn ColorUtils.factorToHex(this.get('baseColorFactor'));\n\t}\n\n\t/**\n\t * Base color / albedo; sRGB hexadecimal color. See {@link Material.getBaseColorTexture getBaseColorTexture}.\n\t */\n\tpublic setBaseColorHex(hex: number): this {\n\t\tconst factor = this.get('baseColorFactor').slice() as vec4;\n\t\treturn this.set('baseColorFactor', ColorUtils.hexToFactor(hex, factor));\n\t}\n\n\t/**\n\t * Base color / albedo. The visible color of a non-metallic surface under constant ambient\n\t * light would be a linear combination (multiplication) of its vertex colors, base color\n\t * factor, and base color texture. Lighting, and reflections in metallic or smooth surfaces,\n\t * also effect the final color. The alpha (`.a`) channel of base color factors and textures\n\t * will have varying effects, based on the setting of {@link Material.getAlphaMode getAlphaMode}.\n\t *\n\t * Reference:\n\t * - [glTF  material.pbrMetallicRoughness.baseColorFactor](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#pbrmetallicroughnessbasecolorfactor)\n\t */\n\tpublic getBaseColorTexture(): Texture | null {\n\t\treturn this.getRef('baseColorTexture');\n\t}\n\n\t/**\n\t * Settings affecting the material's use of its base color texture. If no texture is attached,\n\t * {@link TextureInfo} is `null`.\n\t */\n\tpublic getBaseColorTextureInfo(): TextureInfo | null {\n\t\treturn this.getRef('baseColorTexture') ? this.getRef('baseColorTextureInfo') : null;\n\t}\n\n\t/** Sets base color / albedo texture. See {@link Material.getBaseColorTexture getBaseColorTexture}. */\n\tpublic setBaseColorTexture(texture: Texture | null): this {\n\t\treturn this.setRef('baseColorTexture', texture, { channels: R | G | B | A, isColor: true });\n\t}\n\n\t/**********************************************************************************************\n\t * Emissive.\n\t */\n\n\t/** Emissive color; Linear-sRGB components. See {@link Material.getEmissiveTexture getEmissiveTexture}. */\n\tpublic getEmissiveFactor(): vec3 {\n\t\treturn this.get('emissiveFactor');\n\t}\n\n\t/** Emissive color; Linear-sRGB components. See {@link Material.getEmissiveTexture getEmissiveTexture}. */\n\tpublic setEmissiveFactor(emissiveFactor: vec3): this {\n\t\treturn this.set('emissiveFactor', emissiveFactor);\n\t}\n\n\t/** Emissive; sRGB hexadecimal color. See {@link Material.getBaseColorTexture getBaseColorTexture}. */\n\tpublic getEmissiveHex(): number {\n\t\treturn ColorUtils.factorToHex(this.get('emissiveFactor'));\n\t}\n\n\t/** Emissive; sRGB hexadecimal color. See {@link Material.getEmissiveTexture getEmissiveTexture}. */\n\tpublic setEmissiveHex(hex: number): this {\n\t\tconst factor = this.get('emissiveFactor').slice() as vec3;\n\t\treturn this.set('emissiveFactor', ColorUtils.hexToFactor(hex, factor));\n\t}\n\n\t/**\n\t * Emissive texture. Emissive color is added to any base color of the material, after any\n\t * lighting/shadowing are applied. An emissive color does not inherently \"glow\", or affect\n\t * objects around it at all. To create that effect, most viewers must also enable a\n\t * post-processing effect called \"bloom\".\n\t *\n\t * Reference:\n\t * - [glTF  material.emissiveTexture](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#materialemissivetexture)\n\t */\n\tpublic getEmissiveTexture(): Texture | null {\n\t\treturn this.getRef('emissiveTexture');\n\t}\n\n\t/**\n\t * Settings affecting the material's use of its emissive texture. If no texture is attached,\n\t * {@link TextureInfo} is `null`.\n\t */\n\tpublic getEmissiveTextureInfo(): TextureInfo | null {\n\t\treturn this.getRef('emissiveTexture') ? this.getRef('emissiveTextureInfo') : null;\n\t}\n\n\t/** Sets emissive texture. See {@link Material.getEmissiveTexture getEmissiveTexture}. */\n\tpublic setEmissiveTexture(texture: Texture | null): this {\n\t\treturn this.setRef('emissiveTexture', texture, { channels: R | G | B, isColor: true });\n\t}\n\n\t/**********************************************************************************************\n\t * Normal.\n\t */\n\n\t/** Normal (surface detail) factor; linear multiplier. Affects `.normalTexture`. */\n\tpublic getNormalScale(): number {\n\t\treturn this.get('normalScale');\n\t}\n\n\t/** Normal (surface detail) factor; linear multiplier. Affects `.normalTexture`. */\n\tpublic setNormalScale(scale: number): this {\n\t\treturn this.set('normalScale', scale);\n\t}\n\n\t/**\n\t * Normal (surface detail) texture.\n\t *\n\t * A tangent space normal map. The texture contains RGB components. Each texel represents the\n\t * XYZ components of a normal vector in tangent space. Red [0 to 255] maps to X [-1 to 1].\n\t * Green [0 to 255] maps to Y [-1 to 1]. Blue [128 to 255] maps to Z [1/255 to 1]. The normal\n\t * vectors use OpenGL conventions where +X is right and +Y is up. +Z points toward the viewer.\n\t *\n\t * Reference:\n\t * - [glTF  material.normalTexture](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#materialnormaltexture)\n\t */\n\tpublic getNormalTexture(): Texture | null {\n\t\treturn this.getRef('normalTexture');\n\t}\n\n\t/**\n\t * Settings affecting the material's use of its normal texture. If no texture is attached,\n\t * {@link TextureInfo} is `null`.\n\t */\n\tpublic getNormalTextureInfo(): TextureInfo | null {\n\t\treturn this.getRef('normalTexture') ? this.getRef('normalTextureInfo') : null;\n\t}\n\n\t/** Sets normal (surface detail) texture. See {@link Material.getNormalTexture getNormalTexture}. */\n\tpublic setNormalTexture(texture: Texture | null): this {\n\t\treturn this.setRef('normalTexture', texture, { channels: R | G | B });\n\t}\n\n\t/**********************************************************************************************\n\t * Occlusion.\n\t */\n\n\t/** (Ambient) Occlusion factor; linear multiplier. Affects `.occlusionTexture`. */\n\tpublic getOcclusionStrength(): number {\n\t\treturn this.get('occlusionStrength');\n\t}\n\n\t/** Sets (ambient) occlusion factor; linear multiplier. Affects `.occlusionTexture`. */\n\tpublic setOcclusionStrength(strength: number): this {\n\t\treturn this.set('occlusionStrength', strength);\n\t}\n\n\t/**\n\t * (Ambient) Occlusion texture, generally used for subtle 'baked' shadowing effects that are\n\t * independent of an object's position, such as shading in inset areas and corners. Direct\n\t * lighting is not affected by occlusion, so at least one indirect light source must be present\n\t * in the scene for occlusion effects to be visible.\n\t *\n\t * The occlusion values are sampled from the R channel. Higher values indicate areas that\n\t * should receive full indirect lighting and lower values indicate no indirect lighting.\n\t *\n\t * Reference:\n\t * - [glTF  material.occlusionTexture](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#materialocclusiontexture)\n\t */\n\tpublic getOcclusionTexture(): Texture | null {\n\t\treturn this.getRef('occlusionTexture');\n\t}\n\n\t/**\n\t * Settings affecting the material's use of its occlusion texture. If no texture is attached,\n\t * {@link TextureInfo} is `null`.\n\t */\n\tpublic getOcclusionTextureInfo(): TextureInfo | null {\n\t\treturn this.getRef('occlusionTexture') ? this.getRef('occlusionTextureInfo') : null;\n\t}\n\n\t/** Sets (ambient) occlusion texture. See {@link Material.getOcclusionTexture getOcclusionTexture}. */\n\tpublic setOcclusionTexture(texture: Texture | null): this {\n\t\treturn this.setRef('occlusionTexture', texture, { channels: R });\n\t}\n\n\t/**********************************************************************************************\n\t * Metallic / roughness.\n\t */\n\n\t/**\n\t * Roughness factor; linear multiplier. Affects roughness channel of\n\t * `metallicRoughnessTexture`. See {@link Material.getMetallicRoughnessTexture getMetallicRoughnessTexture}.\n\t */\n\tpublic getRoughnessFactor(): number {\n\t\treturn this.get('roughnessFactor');\n\t}\n\n\t/**\n\t * Sets roughness factor; linear multiplier. Affects roughness channel of\n\t * `metallicRoughnessTexture`. See {@link Material.getMetallicRoughnessTexture getMetallicRoughnessTexture}.\n\t */\n\tpublic setRoughnessFactor(factor: number): this {\n\t\treturn this.set('roughnessFactor', factor);\n\t}\n\n\t/**\n\t * Metallic factor; linear multiplier. Affects roughness channel of\n\t * `metallicRoughnessTexture`. See {@link Material.getMetallicRoughnessTexture getMetallicRoughnessTexture}.\n\t */\n\tpublic getMetallicFactor(): number {\n\t\treturn this.get('metallicFactor');\n\t}\n\n\t/**\n\t * Sets metallic factor; linear multiplier. Affects roughness channel of\n\t * `metallicRoughnessTexture`. See {@link Material.getMetallicRoughnessTexture getMetallicRoughnessTexture}.\n\t */\n\tpublic setMetallicFactor(factor: number): this {\n\t\treturn this.set('metallicFactor', factor);\n\t}\n\n\t/**\n\t * Metallic roughness texture. The metalness values are sampled from the B channel. The\n\t * roughness values are sampled from the G channel. When a material is fully metallic,\n\t * or nearly so, it may require image-based lighting (i.e. an environment map) or global\n\t * illumination to appear well-lit.\n\t *\n\t * Reference:\n\t * - [glTF  material.pbrMetallicRoughness.metallicRoughnessTexture](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#pbrmetallicroughnessmetallicroughnesstexture)\n\t */\n\tpublic getMetallicRoughnessTexture(): Texture | null {\n\t\treturn this.getRef('metallicRoughnessTexture');\n\t}\n\n\t/**\n\t * Settings affecting the material's use of its metallic/roughness texture. If no texture is\n\t * attached, {@link TextureInfo} is `null`.\n\t */\n\tpublic getMetallicRoughnessTextureInfo(): TextureInfo | null {\n\t\treturn this.getRef('metallicRoughnessTexture') ? this.getRef('metallicRoughnessTextureInfo') : null;\n\t}\n\n\t/**\n\t * Sets metallic/roughness texture.\n\t * See {@link Material.getMetallicRoughnessTexture getMetallicRoughnessTexture}.\n\t */\n\tpublic setMetallicRoughnessTexture(texture: Texture | null): this {\n\t\treturn this.setRef('metallicRoughnessTexture', texture, { channels: G | B });\n\t}\n}\n", "import { Nullable, PropertyType } from '../constants.js';\nimport { ExtensibleProperty, IExtensibleProperty } from './extensible-property.js';\nimport type { Primitive } from './primitive.js';\n\ninterface IMesh extends IExtensibleProperty {\n\tweights: number[];\n\tprimitives: Primitive[];\n}\n\n/**\n * *Meshes define reusable geometry (triangles, lines, or points) and are instantiated by\n * {@link Node}s.*\n *\n * Each draw call required to render a mesh is represented as a {@link Primitive}. Meshes typically\n * have only a single {@link Primitive}, but may have more for various reasons. A mesh manages only\n * a list of primitives  materials, morph targets, and other properties are managed on a per-\n * primitive basis.\n *\n * When the same geometry and material should be rendered at multiple places in the scene, reuse\n * the same Mesh instance and attach it to multiple nodes for better efficiency. Where the geometry\n * is shared but the material is not, reusing {@link Accessor}s under different meshes and\n * primitives can similarly improve transmission efficiency, although some rendering efficiency is\n * lost as the number of materials in a scene increases.\n *\n * Usage:\n *\n * ```ts\n * const primitive = doc.createPrimitive()\n * \t.setAttribute('POSITION', positionAccessor)\n * \t.setAttribute('TEXCOORD_0', uvAccessor);\n * const mesh = doc.createMesh('myMesh')\n * \t.addPrimitive(primitive);\n * node.setMesh(mesh);\n * ```\n *\n * References:\n * - [glTF  Geometry](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#geometry)\n *\n * @category Properties\n */\nexport class Mesh extends ExtensibleProperty<IMesh> {\n\tpublic declare propertyType: PropertyType.MESH;\n\n\tprotected init(): void {\n\t\tthis.propertyType = PropertyType.MESH;\n\t}\n\n\tprotected getDefaults(): Nullable<IMesh> {\n\t\treturn Object.assign(super.getDefaults() as IExtensibleProperty, { weights: [], primitives: [] });\n\t}\n\n\t/** Adds a {@link Primitive} to the mesh's draw call list. */\n\tpublic addPrimitive(primitive: Primitive): this {\n\t\treturn this.addRef('primitives', primitive);\n\t}\n\n\t/** Removes a {@link Primitive} from the mesh's draw call list. */\n\tpublic removePrimitive(primitive: Primitive): this {\n\t\treturn this.removeRef('primitives', primitive);\n\t}\n\n\t/** Lists {@link Primitive} draw calls of the mesh. */\n\tpublic listPrimitives(): Primitive[] {\n\t\treturn this.listRefs('primitives');\n\t}\n\n\t/**\n\t * Initial weights of each {@link PrimitiveTarget} on this mesh. Each {@link Primitive} must\n\t * have the same number of targets. Most engines only support 4-8 active morph targets at a\n\t * time.\n\t */\n\tpublic getWeights(): number[] {\n\t\treturn this.get('weights');\n\t}\n\n\t/**\n\t * Initial weights of each {@link PrimitiveTarget} on this mesh. Each {@link Primitive} must\n\t * have the same number of targets. Most engines only support 4-8 active morph targets at a\n\t * time.\n\t */\n\tpublic setWeights(weights: number[]): this {\n\t\treturn this.set('weights', weights);\n\t}\n}\n", "import { multiply } from 'gl-matrix/mat4';\nimport { PropertyType, mat4, vec3, vec4, Nullable } from '../constants.js';\nimport { $attributes } from 'property-graph';\nimport { MathUtils } from '../utils/index.js';\nimport type { Camera } from './camera.js';\nimport { ExtensibleProperty, IExtensibleProperty } from './extensible-property.js';\nimport type { Mesh } from './mesh.js';\nimport { COPY_IDENTITY } from './property.js';\nimport type { Skin } from './skin.js';\nimport type { Scene } from './scene.js';\n\ninterface INode extends IExtensibleProperty {\n\ttranslation: vec3;\n\trotation: vec4;\n\tscale: vec3;\n\tweights: number[];\n\tcamera: Camera;\n\tmesh: Mesh;\n\tskin: Skin;\n\tchildren: Node[];\n}\n\n/**\n * *Nodes are the objects that comprise a {@link Scene}.*\n *\n * Each Node may have one or more children, and a transform (position, rotation, and scale) that\n * applies to all of its descendants. A Node may also reference (or \"instantiate\") other resources\n * at its location, including {@link Mesh}, Camera, Light, and Skin properties. A Node cannot be\n * part of more than one {@link Scene}.\n *\n * A Node's local transform is represented with array-like objects, intended to be compatible with\n * [gl-matrix](https://github.com/toji/gl-matrix), or with the `toArray`/`fromArray` methods of\n * libraries like three.js and babylon.js.\n *\n * Usage:\n *\n * ```ts\n * const node = doc.createNode('myNode')\n * \t.setMesh(mesh)\n * \t.setTranslation([0, 0, 0])\n * \t.addChild(otherNode);\n * ```\n *\n * References:\n * - [glTF  Nodes and Hierarchy](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#nodes-and-hierarchy)\n *\n * @category Properties\n */\nexport class Node extends ExtensibleProperty<INode> {\n\tpublic declare propertyType: PropertyType.NODE;\n\n\t/**\n\t * Internal reference to 1 parent Nodes, omitted from {@link Graph}.\n\t * @internal\n\t * @privateRemarks Requires non-graph state.\n\t */\n\tpublic _parentNode: Node | null = null;\n\t/**\n\t * Internal reference to N parent scenes, omitted from {@link Graph}.\n\t * @internal\n\t * @privateRemarks Requires non-graph state.\n\t */\n\tpublic _parentScenes = new Set<Scene>();\n\n\tprotected init(): void {\n\t\tthis.propertyType = PropertyType.NODE;\n\t}\n\n\tprotected getDefaults(): Nullable<INode> {\n\t\treturn Object.assign(super.getDefaults() as IExtensibleProperty, {\n\t\t\ttranslation: [0, 0, 0] as vec3,\n\t\t\trotation: [0, 0, 0, 1] as vec4,\n\t\t\tscale: [1, 1, 1] as vec3,\n\t\t\tweights: [],\n\t\t\tcamera: null,\n\t\t\tmesh: null,\n\t\t\tskin: null,\n\t\t\tchildren: [],\n\t\t});\n\t}\n\n\tpublic copy(other: this, resolve = COPY_IDENTITY): this {\n\t\t// Node cannot be copied, only cloned. Copying is shallow, but Nodes cannot have more than\n\t\t// one parent. Rather than leaving one of the two Nodes without children, throw an error here.\n\t\tif (resolve === COPY_IDENTITY) throw new Error('Node cannot be copied.');\n\t\treturn super.copy(other, resolve);\n\t}\n\n\t/**********************************************************************************************\n\t * Local transform.\n\t */\n\n\t/** Returns the translation (position) of this Node in local space. */\n\tpublic getTranslation(): vec3 {\n\t\treturn this.get('translation');\n\t}\n\n\t/** Returns the rotation (quaternion) of this Node in local space. */\n\tpublic getRotation(): vec4 {\n\t\treturn this.get('rotation');\n\t}\n\n\t/** Returns the scale of this Node in local space. */\n\tpublic getScale(): vec3 {\n\t\treturn this.get('scale');\n\t}\n\n\t/** Sets the translation (position) of this Node in local space. */\n\tpublic setTranslation(translation: vec3): this {\n\t\treturn this.set('translation', translation);\n\t}\n\n\t/** Sets the rotation (quaternion) of this Node in local space. */\n\tpublic setRotation(rotation: vec4): this {\n\t\treturn this.set('rotation', rotation);\n\t}\n\n\t/** Sets the scale of this Node in local space. */\n\tpublic setScale(scale: vec3): this {\n\t\treturn this.set('scale', scale);\n\t}\n\n\t/** Returns the local matrix of this Node. */\n\tpublic getMatrix(): mat4 {\n\t\treturn MathUtils.compose(\n\t\t\tthis.get('translation'),\n\t\t\tthis.get('rotation'),\n\t\t\tthis.get('scale'),\n\t\t\t[] as unknown as mat4\n\t\t);\n\t}\n\n\t/** Sets the local matrix of this Node. Matrix will be decomposed to TRS properties. */\n\tpublic setMatrix(matrix: mat4): this {\n\t\tconst translation = this.get('translation').slice() as vec3;\n\t\tconst rotation = this.get('rotation').slice() as vec4;\n\t\tconst scale = this.get('scale').slice() as vec3;\n\t\tMathUtils.decompose(matrix, translation, rotation, scale);\n\t\treturn this.set('translation', translation).set('rotation', rotation).set('scale', scale);\n\t}\n\n\t/**********************************************************************************************\n\t * World transform.\n\t */\n\n\t/** Returns the translation (position) of this Node in world space. */\n\tpublic getWorldTranslation(): vec3 {\n\t\tconst t = [0, 0, 0] as vec3;\n\t\tMathUtils.decompose(this.getWorldMatrix(), t, [0, 0, 0, 1], [1, 1, 1]);\n\t\treturn t;\n\t}\n\n\t/** Returns the rotation (quaternion) of this Node in world space. */\n\tpublic getWorldRotation(): vec4 {\n\t\tconst r = [0, 0, 0, 1] as vec4;\n\t\tMathUtils.decompose(this.getWorldMatrix(), [0, 0, 0], r, [1, 1, 1]);\n\t\treturn r;\n\t}\n\n\t/** Returns the scale of this Node in world space. */\n\tpublic getWorldScale(): vec3 {\n\t\tconst s = [1, 1, 1] as vec3;\n\t\tMathUtils.decompose(this.getWorldMatrix(), [0, 0, 0], [0, 0, 0, 1], s);\n\t\treturn s;\n\t}\n\n\t/** Returns the world matrix of this Node. */\n\tpublic getWorldMatrix(): mat4 {\n\t\t// Build ancestor chain.\n\t\tconst ancestors: Node[] = [];\n\t\t// eslint-disable-next-line @typescript-eslint/no-this-alias\n\t\tfor (let node: Node | null = this; node != null; node = node._parentNode) {\n\t\t\tancestors.push(node);\n\t\t}\n\n\t\t// Compute world matrix.\n\t\tlet ancestor: Node | undefined;\n\t\tconst worldMatrix = ancestors.pop()!.getMatrix();\n\t\twhile ((ancestor = ancestors.pop())) {\n\t\t\tmultiply(worldMatrix, worldMatrix, ancestor.getMatrix());\n\t\t}\n\n\t\treturn worldMatrix;\n\t}\n\n\t/**********************************************************************************************\n\t * Scene hierarchy.\n\t */\n\n\t/**\n\t * Adds the given Node as a child of this Node.\n\t *\n\t * Requirements:\n\t *\n\t * 1. Nodes MAY be root children of multiple {@link Scene Scenes}\n\t * 2. Nodes MUST NOT be children of >1 Node\n\t * 3. Nodes MUST NOT be children of both Nodes and {@link Scene Scenes}\n\t *\n\t * The `addChild` method enforces these restrictions automatically, and will\n\t * remove the new child from previous parents where needed. This behavior\n\t * may change in future major releases of the library.\n\t *\n\t * @privateRemarks Requires non-graph state.\n\t */\n\tpublic addChild(child: Node): this {\n\t\t// Remove existing parents.\n\t\tif (child._parentNode) child._parentNode.removeChild(child);\n\t\tif (child._parentScenes.size) {\n\t\t\tfor (const scene of child._parentScenes) {\n\t\t\t\tscene.removeChild(child);\n\t\t\t}\n\t\t}\n\n\t\t// Edge in graph.\n\t\tthis.addRef('children', child);\n\n\t\t// Set new parent.\n\t\t// TODO(cleanup): Avoid reaching into $attributes.\n\t\tchild._parentNode = this;\n\t\tconst childrenRefs = this[$attributes]['children'];\n\t\tconst ref = childrenRefs[childrenRefs.length - 1];\n\t\tref.addEventListener('dispose', () => (child._parentNode = null));\n\t\treturn this;\n\t}\n\n\t/** Removes a Node from this Node's child Node list. */\n\tpublic removeChild(child: Node): this {\n\t\treturn this.removeRef('children', child);\n\t}\n\n\t/** Lists all child Nodes of this Node. */\n\tpublic listChildren(): Node[] {\n\t\treturn this.listRefs('children');\n\t}\n\n\t/** @deprecated Use {@link Node.getParentNode} and {@link listNodeScenes} instead. */\n\tpublic getParent(): SceneNode | null {\n\t\tif (this._parentNode) return this._parentNode;\n\t\tconst scene = this.listParents().find((parent) => parent.propertyType === PropertyType.SCENE);\n\t\treturn (scene as unknown as SceneNode) || null;\n\t}\n\n\t/**\n\t * Returns the Node's unique parent Node within the scene graph. If the\n\t * Node has no parents, or is a direct child of the {@link Scene}\n\t * (\"root node\"), this method returns null.\n\t *\n\t * Unrelated to {@link Property.listParents}, which lists all resource\n\t * references from properties of any type ({@link Skin}, {@link Root}, ...).\n\t */\n\tpublic getParentNode(): Node | null {\n\t\treturn this._parentNode;\n\t}\n\n\t/**********************************************************************************************\n\t * Attachments.\n\t */\n\n\t/** Returns the {@link Mesh}, if any, instantiated at this Node. */\n\tpublic getMesh(): Mesh | null {\n\t\treturn this.getRef('mesh');\n\t}\n\n\t/**\n\t * Sets a {@link Mesh} to be instantiated at this Node. A single mesh may be instatiated by\n\t * multiple Nodes; reuse of this sort is strongly encouraged.\n\t */\n\tpublic setMesh(mesh: Mesh | null): this {\n\t\treturn this.setRef('mesh', mesh);\n\t}\n\n\t/** Returns the {@link Camera}, if any, instantiated at this Node. */\n\tpublic getCamera(): Camera | null {\n\t\treturn this.getRef('camera');\n\t}\n\n\t/** Sets a {@link Camera} to be instantiated at this Node. */\n\tpublic setCamera(camera: Camera | null): this {\n\t\treturn this.setRef('camera', camera);\n\t}\n\n\t/** Returns the {@link Skin}, if any, instantiated at this Node. */\n\tpublic getSkin(): Skin | null {\n\t\treturn this.getRef('skin');\n\t}\n\n\t/** Sets a {@link Skin} to be instantiated at this Node. */\n\tpublic setSkin(skin: Skin | null): this {\n\t\treturn this.setRef('skin', skin);\n\t}\n\n\t/**\n\t * Initial weights of each {@link PrimitiveTarget} for the mesh instance at this Node.\n\t * Most engines only support 4-8 active morph targets at a time.\n\t */\n\tpublic getWeights(): number[] {\n\t\treturn this.get('weights');\n\t}\n\n\t/**\n\t * Initial weights of each {@link PrimitiveTarget} for the mesh instance at this Node.\n\t * Most engines only support 4-8 active morph targets at a time.\n\t */\n\tpublic setWeights(weights: number[]): this {\n\t\treturn this.set('weights', weights);\n\t}\n\n\t/**********************************************************************************************\n\t * Helpers.\n\t */\n\n\t/** Visits this {@link Node} and its descendants, top-down. */\n\tpublic traverse(fn: (node: Node) => void): this {\n\t\tfn(this);\n\t\tfor (const child of this.listChildren()) child.traverse(fn);\n\t\treturn this;\n\t}\n}\n\ninterface SceneNode {\n\tpropertyType: PropertyType;\n\t_parent?: SceneNode | null;\n\taddChild(node: Node): this;\n\tremoveChild(node: Node): this;\n}\n", "import { BufferViewUsage, Nullable, PropertyType } from '../constants.js';\nimport type { GLTF } from '../types/gltf.js';\nimport type { Accessor } from './accessor.js';\nimport { ExtensibleProperty, IExtensibleProperty } from './extensible-property.js';\nimport type { Material } from './material.js';\nimport type { PrimitiveTarget } from './primitive-target.js';\n\ninterface IPrimitive extends IExtensibleProperty {\n\tmode: GLTF.MeshPrimitiveMode;\n\tmaterial: Material;\n\tindices: Accessor;\n\tattributes: { [key: string]: Accessor };\n\ttargets: PrimitiveTarget[];\n}\n\n/**\n * *Primitives are individual GPU draw calls comprising a {@link Mesh}.*\n *\n * Meshes typically have only a single Primitive, although various cases may require more. Each\n * primitive may be assigned vertex attributes, morph target attributes, and a material. Any of\n * these properties should be reused among multiple primitives where feasible.\n *\n * Primitives cannot be moved independently of other primitives within the same mesh, except\n * through the use of morph targets and skinning. If independent movement or other runtime\n * behavior is necessary (like raycasting or collisions) prefer to assign each primitive to a\n * different mesh. The number of GPU draw calls is typically not affected by grouping or\n * ungrouping primitives to a mesh.\n *\n * Each primitive may optionally be deformed by one or more morph targets, stored in a\n * {@link PrimitiveTarget}.\n *\n * Usage:\n *\n * ```ts\n * const primitive = doc.createPrimitive()\n * \t.setAttribute('POSITION', positionAccessor)\n * \t.setAttribute('TEXCOORD_0', uvAccessor)\n * \t.setMaterial(material);\n * mesh.addPrimitive(primitive);\n * node.setMesh(mesh);\n * ```\n *\n * References:\n * - [glTF  Geometry](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#geometry)\n *\n * @category Properties\n */\nexport class Primitive extends ExtensibleProperty<IPrimitive> {\n\tpublic declare propertyType: PropertyType.PRIMITIVE;\n\n\t/**********************************************************************************************\n\t * Constants.\n\t */\n\n\t/** Type of primitives to render. All valid values correspond to WebGL enums. */\n\tpublic static Mode: Record<string, GLTF.MeshPrimitiveMode> = {\n\t\t/** Draw single points. */\n\t\tPOINTS: 0,\n\t\t/** Draw lines. Each vertex connects to the one after it. */\n\t\tLINES: 1,\n\t\t/**\n\t\t * Draw lines. Each set of two vertices is treated as a separate line segment.\n\t\t * @deprecated See {@link https://github.com/KhronosGroup/glTF/issues/1883 KhronosGroup/glTF#1883}.\n\t\t */\n\t\tLINE_LOOP: 2,\n\t\t/** Draw a connected group of line segments from the first vertex to the last,  */\n\t\tLINE_STRIP: 3,\n\t\t/** Draw triangles. Each set of three vertices creates a separate triangle. */\n\t\tTRIANGLES: 4,\n\t\t/** Draw a connected strip of triangles. */\n\t\tTRIANGLE_STRIP: 5,\n\t\t/**\n\t\t * Draw a connected group of triangles. Each vertex connects to the previous and the first\n\t\t * vertex in the fan.\n\t\t * @deprecated See {@link https://github.com/KhronosGroup/glTF/issues/1883 KhronosGroup/glTF#1883}.\n\t\t */\n\t\tTRIANGLE_FAN: 6,\n\t};\n\n\t/**********************************************************************************************\n\t * Instance.\n\t */\n\n\tprotected init(): void {\n\t\tthis.propertyType = PropertyType.PRIMITIVE;\n\t}\n\n\tprotected getDefaults(): Nullable<IPrimitive> {\n\t\treturn Object.assign(super.getDefaults() as IExtensibleProperty, {\n\t\t\tmode: Primitive.Mode.TRIANGLES,\n\t\t\tmaterial: null,\n\t\t\tindices: null,\n\t\t\tattributes: {},\n\t\t\ttargets: [],\n\t\t});\n\t}\n\n\t/**********************************************************************************************\n\t * Primitive data.\n\t */\n\n\t/** Returns an {@link Accessor} with indices of vertices to be drawn. */\n\tpublic getIndices(): Accessor | null {\n\t\treturn this.getRef('indices');\n\t}\n\n\t/**\n\t * Sets an {@link Accessor} with indices of vertices to be drawn. In `TRIANGLES` draw mode,\n\t * each set of three indices define a triangle. The front face has a counter-clockwise (CCW)\n\t * winding order.\n\t */\n\tpublic setIndices(indices: Accessor | null): this {\n\t\treturn this.setRef('indices', indices, { usage: BufferViewUsage.ELEMENT_ARRAY_BUFFER });\n\t}\n\n\t/** Returns a vertex attribute as an {@link Accessor}. */\n\tpublic getAttribute(semantic: string): Accessor | null {\n\t\treturn this.getRefMap('attributes', semantic);\n\t}\n\n\t/**\n\t * Sets a vertex attribute to an {@link Accessor}. All attributes must have the same vertex\n\t * count.\n\t */\n\tpublic setAttribute(semantic: string, accessor: Accessor | null): this {\n\t\treturn this.setRefMap('attributes', semantic, accessor, { usage: BufferViewUsage.ARRAY_BUFFER });\n\t}\n\n\t/**\n\t * Lists all vertex attribute {@link Accessor}s associated with the primitive, excluding any\n\t * attributes used for morph targets. For example, `[positionAccessor, normalAccessor,\n\t * uvAccessor]`. Order will be consistent with the order returned by {@link .listSemantics}().\n\t */\n\tpublic listAttributes(): Accessor[] {\n\t\treturn this.listRefMapValues('attributes');\n\t}\n\n\t/**\n\t * Lists all vertex attribute semantics associated with the primitive, excluding any semantics\n\t * used for morph targets. For example, `['POSITION', 'NORMAL', 'TEXCOORD_0']`. Order will be\n\t * consistent with the order returned by {@link .listAttributes}().\n\t */\n\tpublic listSemantics(): string[] {\n\t\treturn this.listRefMapKeys('attributes');\n\t}\n\n\t/** Returns the material used to render the primitive. */\n\tpublic getMaterial(): Material | null {\n\t\treturn this.getRef('material');\n\t}\n\n\t/** Sets the material used to render the primitive. */\n\tpublic setMaterial(material: Material | null): this {\n\t\treturn this.setRef('material', material);\n\t}\n\n\t/**********************************************************************************************\n\t * Mode.\n\t */\n\n\t/**\n\t * Returns the GPU draw mode (`TRIANGLES`, `LINES`, `POINTS`...) as a WebGL enum value.\n\t *\n\t * Reference:\n\t * - [glTF  `primitive.mode`](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#primitivemode)\n\t */\n\tpublic getMode(): GLTF.MeshPrimitiveMode {\n\t\treturn this.get('mode');\n\t}\n\n\t/**\n\t * Sets the GPU draw mode (`TRIANGLES`, `LINES`, `POINTS`...) as a WebGL enum value.\n\t *\n\t * Reference:\n\t * - [glTF  `primitive.mode`](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#primitivemode)\n\t */\n\tpublic setMode(mode: GLTF.MeshPrimitiveMode): this {\n\t\treturn this.set('mode', mode);\n\t}\n\n\t/**********************************************************************************************\n\t * Morph targets.\n\t */\n\n\t/** Lists all morph targets associated with the primitive. */\n\tpublic listTargets(): PrimitiveTarget[] {\n\t\treturn this.listRefs('targets');\n\t}\n\n\t/**\n\t * Adds a morph target to the primitive. All primitives in the same mesh must have the same\n\t * number of targets.\n\t */\n\tpublic addTarget(target: PrimitiveTarget): this {\n\t\treturn this.addRef('targets', target);\n\t}\n\n\t/**\n\t * Removes a morph target from the primitive. All primitives in the same mesh must have the same\n\t * number of targets.\n\t */\n\tpublic removeTarget(target: PrimitiveTarget): this {\n\t\treturn this.removeRef('targets', target);\n\t}\n}\n", "import { BufferViewUsage, Nullable, PropertyType } from '../constants.js';\nimport type { Accessor } from './accessor.js';\nimport type { IExtensibleProperty } from './extensible-property.js';\nimport { Property } from './property.js';\n\ninterface IPrimitiveTarget extends IExtensibleProperty {\n\tattributes: { [key: string]: Accessor };\n}\n\n/**\n * *Morph target or shape key used to deform one {@link Primitive} in a {@link Mesh}.*\n *\n * A PrimitiveTarget contains a `POSITION` attribute (and optionally `NORMAL` and `TANGENT`) that\n * can additively deform the base attributes on a {@link Mesh} {@link Primitive}. Vertex values\n * of `0, 0, 0` in the target will have no effect, whereas a value of `0, 1, 0` would offset that\n * vertex in the base geometry by y+=1. Morph targets can be fully or partially applied: their\n * default state is controlled by {@link Mesh.getWeights}, which can also be overridden for a\n * particular instantiation of a {@link Mesh}, using {@link Node.getWeights}.\n *\n * Reference:\n * - [glTF  Morph Targets](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#morph-targets)\n *\n * @category Properties\n */\nexport class PrimitiveTarget extends Property<IPrimitiveTarget> {\n\tpublic declare propertyType: PropertyType.PRIMITIVE_TARGET;\n\n\tprotected init(): void {\n\t\tthis.propertyType = PropertyType.PRIMITIVE_TARGET;\n\t}\n\n\tprotected getDefaults(): Nullable<IPrimitiveTarget> {\n\t\treturn Object.assign(super.getDefaults() as IExtensibleProperty, { attributes: {} });\n\t}\n\n\t/** Returns a morph target vertex attribute as an {@link Accessor}. */\n\tpublic getAttribute(semantic: string): Accessor | null {\n\t\treturn this.getRefMap('attributes', semantic);\n\t}\n\n\t/**\n\t * Sets a morph target vertex attribute to an {@link Accessor}.\n\t */\n\tpublic setAttribute(semantic: string, accessor: Accessor | null): this {\n\t\treturn this.setRefMap('attributes', semantic, accessor, { usage: BufferViewUsage.ARRAY_BUFFER });\n\t}\n\n\t/**\n\t * Lists all morph target vertex attribute {@link Accessor}s associated. Order will be\n\t * consistent with the order returned by {@link .listSemantics}().\n\t */\n\tpublic listAttributes(): Accessor[] {\n\t\treturn this.listRefMapValues('attributes');\n\t}\n\n\t/**\n\t * Lists all morph target vertex attribute semantics associated. Order will be\n\t * consistent with the order returned by {@link .listAttributes}().\n\t */\n\tpublic listSemantics(): string[] {\n\t\treturn this.listRefMapKeys('attributes');\n\t}\n}\n", "import { $attributes } from 'property-graph';\nimport { Nullable, PropertyType } from '../constants.js';\nimport { ExtensibleProperty, IExtensibleProperty } from './extensible-property.js';\nimport type { Node } from './node.js';\nimport { COPY_IDENTITY } from './property.js';\n\ninterface IScene extends IExtensibleProperty {\n\tchildren: Node[];\n}\n\n/**\n * *Scenes represent a set of visual objects to render.*\n *\n * Typically a glTF file contains only a single Scene, although more are allowed and useful in some\n * cases. No particular meaning is associated with additional Scenes, except as defined by the\n * application. Scenes reference {@link Node}s, and a single Node cannot be a member of more than\n * one Scene.\n *\n * References:\n * - [glTF  Scenes](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#scenes)\n * - [glTF  Coordinate System and Units](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#coordinate-system-and-units)\n *\n * @category Properties\n */\nexport class Scene extends ExtensibleProperty<IScene> {\n\tpublic declare propertyType: PropertyType.SCENE;\n\n\tprotected init(): void {\n\t\tthis.propertyType = PropertyType.SCENE;\n\t}\n\n\tprotected getDefaults(): Nullable<IScene> {\n\t\treturn Object.assign(super.getDefaults() as IExtensibleProperty, { children: [] });\n\t}\n\n\tpublic copy(other: this, resolve = COPY_IDENTITY): this {\n\t\t// Scene cannot be copied, only cloned. Copying is shallow, but nodes cannot have more than\n\t\t// one parent. Rather than leaving one of the two Scenes without children, throw an error here.\n\t\tif (resolve === COPY_IDENTITY) throw new Error('Scene cannot be copied.');\n\t\treturn super.copy(other, resolve);\n\t}\n\n\t/**\n\t * Adds a {@link Node} to the Scene.\n\t *\n\t * Requirements:\n\t *\n\t * 1. Nodes MAY be root children of multiple {@link Scene Scenes}\n\t * 2. Nodes MUST NOT be children of >1 Node\n\t * 3. Nodes MUST NOT be children of both Nodes and {@link Scene Scenes}\n\t *\n\t * The `addChild` method enforces these restrictions automatically, and will\n\t * remove the new child from previous parents where needed. This behavior\n\t * may change in future major releases of the library.\n\t *\n\t * @privateRemarks Requires non-graph state.\n\t */\n\tpublic addChild(node: Node): this {\n\t\t// Remove existing parent.\n\t\tif (node._parentNode) node._parentNode.removeChild(node);\n\n\t\t// Edge in graph.\n\t\tthis.addRef('children', node);\n\n\t\t// Set new parent.\n\t\t// TODO(cleanup): Avoid reaching into $attributes.\n\t\tnode._parentScenes.add(this);\n\t\tconst childrenRefs = this[$attributes]['children'];\n\t\tconst ref = childrenRefs[childrenRefs.length - 1];\n\t\tref.addEventListener('dispose', () => node._parentScenes.delete(this));\n\t\treturn this;\n\t}\n\n\t/** Removes a {@link Node} from the Scene. */\n\tpublic removeChild(node: Node): this {\n\t\treturn this.removeRef('children', node);\n\t}\n\n\t/**\n\t * Lists all direct child {@link Node Nodes} in the Scene. Indirect\n\t * descendants (children of children) are not returned, but may be\n\t * reached recursively or with {@link Scene.traverse} instead.\n\t */\n\tpublic listChildren(): Node[] {\n\t\treturn this.listRefs('children');\n\t}\n\n\t/** Visits each {@link Node} in the Scene, including descendants, top-down. */\n\tpublic traverse(fn: (node: Node) => void): this {\n\t\tfor (const node of this.listChildren()) node.traverse(fn);\n\t\treturn this;\n\t}\n}\n", "import { BufferViewUsage, Nullable, PropertyType } from '../constants.js';\nimport type { Accessor } from './accessor.js';\nimport { ExtensibleProperty, IExtensibleProperty } from './extensible-property.js';\nimport type { Node } from './node.js';\n\ninterface ISkin extends IExtensibleProperty {\n\tskeleton: Node;\n\tinverseBindMatrices: Accessor;\n\tjoints: Node[];\n}\n\n/**\n * *Collection of {@link Node} joints and inverse bind matrices used with skinned {@link Mesh}\n * instances.*\n *\n * Reference\n * - [glTF  Skins](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#skins)\n *\n * @category Properties\n */\nexport class Skin extends ExtensibleProperty<ISkin> {\n\tpublic declare propertyType: PropertyType.SKIN;\n\n\tprotected init(): void {\n\t\tthis.propertyType = PropertyType.SKIN;\n\t}\n\n\tprotected getDefaults(): Nullable<ISkin> {\n\t\treturn Object.assign(super.getDefaults() as IExtensibleProperty, {\n\t\t\tskeleton: null,\n\t\t\tinverseBindMatrices: null,\n\t\t\tjoints: [],\n\t\t});\n\t}\n\n\t/**\n\t * {@link Node} used as a skeleton root. The node must be the closest common root of the joints\n\t * hierarchy or a direct or indirect parent node of the closest common root.\n\t */\n\tpublic getSkeleton(): Node | null {\n\t\treturn this.getRef('skeleton');\n\t}\n\n\t/**\n\t * {@link Node} used as a skeleton root. The node must be the closest common root of the joints\n\t * hierarchy or a direct or indirect parent node of the closest common root.\n\t */\n\tpublic setSkeleton(skeleton: Node | null): this {\n\t\treturn this.setRef('skeleton', skeleton);\n\t}\n\n\t/**\n\t * {@link Accessor} containing the floating-point 4x4 inverse-bind matrices. The default is\n\t * that each matrix is a 4x4 identity matrix, which implies that inverse-bind matrices were\n\t * pre-applied.\n\t */\n\tpublic getInverseBindMatrices(): Accessor | null {\n\t\treturn this.getRef('inverseBindMatrices');\n\t}\n\n\t/**\n\t * {@link Accessor} containing the floating-point 4x4 inverse-bind matrices. The default is\n\t * that each matrix is a 4x4 identity matrix, which implies that inverse-bind matrices were\n\t * pre-applied.\n\t */\n\tpublic setInverseBindMatrices(inverseBindMatrices: Accessor | null): this {\n\t\treturn this.setRef('inverseBindMatrices', inverseBindMatrices, {\n\t\t\tusage: BufferViewUsage.INVERSE_BIND_MATRICES,\n\t\t});\n\t}\n\n\t/** Adds a joint {@link Node} to this {@link Skin}. */\n\tpublic addJoint(joint: Node): this {\n\t\treturn this.addRef('joints', joint);\n\t}\n\n\t/** Removes a joint {@link Node} from this {@link Skin}. */\n\tpublic removeJoint(joint: Node): this {\n\t\treturn this.removeRef('joints', joint);\n\t}\n\n\t/** Lists joints ({@link Node}s used as joints or bones) in this {@link Skin}. */\n\tpublic listJoints(): Node[] {\n\t\treturn this.listRefs('joints');\n\t}\n}\n", "import { Nullable, PropertyType, vec2 } from '../constants.js';\nimport { BufferUtils, FileUtils, ImageUtils } from '../utils/index.js';\nimport { ExtensibleProperty, IExtensibleProperty } from './extensible-property.js';\n\ninterface ITexture extends IExtensibleProperty {\n\timage: Uint8Array | null;\n\tmimeType: string;\n\turi: string;\n}\n\n/**\n * *Texture, or images, referenced by {@link Material} properties.*\n *\n * Textures in glTF Transform are a combination of glTF's `texture` and `image` properties, and\n * should be unique within a document, such that no other texture contains the same\n * {@link Texture.getImage getImage()} data. Where duplicates may already exist, the `dedup({textures: true})`\n * transform can remove them. A {@link Document} with N texture properties will be exported to a\n * glTF file with N `image` properties, and the minimum number of `texture` properties necessary\n * for the materials that use it.\n *\n * For properties associated with a particular _use_ of a texture, see {@link TextureInfo}.\n *\n * Reference:\n * - [glTF  Textures](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#textures)\n * - [glTF  Images](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#images)\n *\n * @category Properties\n */\nexport class Texture extends ExtensibleProperty<ITexture> {\n\tpublic declare propertyType: PropertyType.TEXTURE;\n\n\tprotected init(): void {\n\t\tthis.propertyType = PropertyType.TEXTURE;\n\t}\n\n\tprotected getDefaults(): Nullable<ITexture> {\n\t\treturn Object.assign(super.getDefaults() as IExtensibleProperty, { image: null, mimeType: '', uri: '' });\n\t}\n\n\t/**********************************************************************************************\n\t * MIME type / format.\n\t */\n\n\t/** Returns the MIME type for this texture ('image/jpeg' or 'image/png'). */\n\tpublic getMimeType(): string {\n\t\treturn this.get('mimeType') || ImageUtils.extensionToMimeType(FileUtils.extension(this.get('uri')));\n\t}\n\n\t/**\n\t * Sets the MIME type for this texture ('image/jpeg' or 'image/png'). If the texture does not\n\t * have a URI, a MIME type is required for correct export.\n\t */\n\tpublic setMimeType(mimeType: string): this {\n\t\treturn this.set('mimeType', mimeType);\n\t}\n\n\t/**********************************************************************************************\n\t * URI / filename.\n\t */\n\n\t/** Returns the URI (e.g. 'path/to/file.png') for this texture. */\n\tpublic getURI(): string {\n\t\treturn this.get('uri');\n\t}\n\n\t/**\n\t * Sets the URI (e.g. 'path/to/file.png') for this texture. If the texture does not have a MIME\n\t * type, a URI is required for correct export.\n\t */\n\tpublic setURI(uri: string): this {\n\t\tthis.set('uri', uri);\n\t\tconst mimeType = ImageUtils.extensionToMimeType(FileUtils.extension(uri));\n\t\tif (mimeType) this.set('mimeType', mimeType);\n\t\treturn this;\n\t}\n\n\t/**********************************************************************************************\n\t * Image data.\n\t */\n\n\t/** Returns the raw image data for this texture. */\n\tpublic getImage(): Uint8Array | null {\n\t\treturn this.get('image');\n\t}\n\n\t/** Sets the raw image data for this texture. */\n\tpublic setImage(image: Uint8Array): this {\n\t\treturn this.set('image', BufferUtils.assertView(image));\n\t}\n\n\t/** Returns the size, in pixels, of this texture. */\n\tpublic getSize(): vec2 | null {\n\t\tconst image = this.get('image');\n\t\tif (!image) return null;\n\t\treturn ImageUtils.getSize(image, this.getMimeType());\n\t}\n}\n", "import { Nullable, PropertyType, VERSION } from '../constants.js';\nimport type { Extension } from '../extension.js';\nimport type { Graph } from 'property-graph';\nimport { Accessor } from './accessor.js';\nimport { Animation } from './animation.js';\nimport { Buffer } from './buffer.js';\nimport { Camera } from './camera.js';\nimport { Material } from './material.js';\nimport { Mesh } from './mesh.js';\nimport { Node } from './node.js';\nimport { COPY_IDENTITY, Property } from './property.js';\nimport { Scene } from './scene.js';\nimport { Skin } from './skin.js';\nimport { Texture } from './texture.js';\nimport { ExtensibleProperty, IExtensibleProperty } from './extensible-property.js';\nimport type { ExtensionProperty } from './extension-property.js';\n\ninterface IAsset {\n\tversion: string;\n\tminVersion?: string;\n\tgenerator?: string;\n\tcopyright?: string;\n\t[key: string]: unknown;\n}\n\ninterface IRoot extends IExtensibleProperty {\n\tasset: IAsset;\n\tdefaultScene: Scene;\n\n\taccessors: Accessor[];\n\tanimations: Animation[];\n\tbuffers: Buffer[];\n\tcameras: Camera[];\n\tmaterials: Material[];\n\tmeshes: Mesh[];\n\tnodes: Node[];\n\tscenes: Scene[];\n\tskins: Skin[];\n\ttextures: Texture[];\n}\n\n/**\n * *Root property of a glTF asset.*\n *\n * Any properties to be exported with a particular asset must be referenced (directly or\n * indirectly) by the root. Metadata about the asset's license, generator, and glTF specification\n * version are stored in the asset, accessible with {@link Root.getAsset}.\n *\n * Properties are added to the root with factory methods on its {@link Document}, and removed by\n * calling {@link Property.dispose}() on the resource. Any properties that have been created but\n * not disposed will be included when calling the various `root.list*()` methods.\n *\n * A document's root cannot be removed, and no other root may be created. Unlike other\n * {@link Property} types, the `.dispose()`, `.detach()` methods have no useful function on a\n * Root property.\n *\n * Usage:\n *\n * ```ts\n * const root = document.getRoot();\n * const scene = document.createScene('myScene');\n * const node = document.createNode('myNode');\n * scene.addChild(node);\n *\n * console.log(root.listScenes()); //  [scene x 1]\n * ```\n *\n * Reference: [glTF  Concepts](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#concepts)\n *\n * @category Properties\n */\nexport class Root extends ExtensibleProperty<IRoot> {\n\tpublic declare propertyType: PropertyType.ROOT;\n\n\tprivate readonly _extensions: Set<Extension> = new Set();\n\n\tprotected init(): void {\n\t\tthis.propertyType = PropertyType.ROOT;\n\t}\n\n\tprotected getDefaults(): Nullable<IRoot> {\n\t\treturn Object.assign(super.getDefaults() as IExtensibleProperty, {\n\t\t\tasset: {\n\t\t\t\tgenerator: `glTF-Transform ${VERSION}`,\n\t\t\t\tversion: '2.0',\n\t\t\t},\n\t\t\tdefaultScene: null,\n\t\t\taccessors: [],\n\t\t\tanimations: [],\n\t\t\tbuffers: [],\n\t\t\tcameras: [],\n\t\t\tmaterials: [],\n\t\t\tmeshes: [],\n\t\t\tnodes: [],\n\t\t\tscenes: [],\n\t\t\tskins: [],\n\t\t\ttextures: [],\n\t\t});\n\t}\n\n\t/** @internal */\n\tconstructor(graph: Graph<Property>) {\n\t\tsuper(graph);\n\t\tgraph.addEventListener('node:create', (event) => {\n\t\t\tthis._addChildOfRoot(event.target as Property);\n\t\t});\n\t}\n\n\tpublic clone(): this {\n\t\tthrow new Error('Root cannot be cloned.');\n\t}\n\n\tpublic copy(other: this, resolve = COPY_IDENTITY): this {\n\t\t// Root cannot be cloned in isolation: only with its Document. Extensions are managed by\n\t\t// the Document during cloning. The Root, and only the Root, should keep existing\n\t\t// references while copying to avoid overwriting during a merge.\n\t\tif (resolve === COPY_IDENTITY) throw new Error('Root cannot be copied.');\n\n\t\t// IMPORTANT: Root cannot call super.copy(), which removes existing references.\n\n\t\tthis.set('asset', { ...other.get('asset') });\n\t\tthis.setName(other.getName());\n\t\tthis.setExtras({ ...other.getExtras() });\n\t\tthis.setDefaultScene(other.getDefaultScene() ? resolve(other.getDefaultScene()!) : null);\n\n\t\tfor (const extensionName of other.listRefMapKeys('extensions')) {\n\t\t\tconst otherExtension = other.getExtension(extensionName) as ExtensionProperty;\n\t\t\tthis.setExtension(extensionName, resolve(otherExtension));\n\t\t}\n\n\t\treturn this;\n\t}\n\n\tprivate _addChildOfRoot(child: Property): this {\n\t\tif (child instanceof Scene) {\n\t\t\tthis.addRef('scenes', child);\n\t\t} else if (child instanceof Node) {\n\t\t\tthis.addRef('nodes', child);\n\t\t} else if (child instanceof Camera) {\n\t\t\tthis.addRef('cameras', child);\n\t\t} else if (child instanceof Skin) {\n\t\t\tthis.addRef('skins', child);\n\t\t} else if (child instanceof Mesh) {\n\t\t\tthis.addRef('meshes', child);\n\t\t} else if (child instanceof Material) {\n\t\t\tthis.addRef('materials', child);\n\t\t} else if (child instanceof Texture) {\n\t\t\tthis.addRef('textures', child);\n\t\t} else if (child instanceof Animation) {\n\t\t\tthis.addRef('animations', child);\n\t\t} else if (child instanceof Accessor) {\n\t\t\tthis.addRef('accessors', child);\n\t\t} else if (child instanceof Buffer) {\n\t\t\tthis.addRef('buffers', child);\n\t\t}\n\t\t// No error for untracked property types.\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns the `asset` object, which specifies the target glTF version of the asset. Additional\n\t * metadata can be stored in optional properties such as `generator` or `copyright`.\n\t *\n\t * Reference: [glTF  Asset](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#asset)\n\t */\n\tpublic getAsset(): IAsset {\n\t\treturn this.get('asset');\n\t}\n\n\t/**********************************************************************************************\n\t * Extensions.\n\t */\n\n\t/** Lists all {@link Extension} properties enabled for this root. */\n\tpublic listExtensionsUsed(): Extension[] {\n\t\treturn Array.from(this._extensions);\n\t}\n\n\t/** Lists all {@link Extension} properties enabled and required for this root. */\n\tpublic listExtensionsRequired(): Extension[] {\n\t\treturn this.listExtensionsUsed().filter((extension) => extension.isRequired());\n\t}\n\n\t/** @internal */\n\tpublic _enableExtension(extension: Extension): this {\n\t\tthis._extensions.add(extension);\n\t\treturn this;\n\t}\n\n\t/** @internal */\n\tpublic _disableExtension(extension: Extension): this {\n\t\tthis._extensions.delete(extension);\n\t\treturn this;\n\t}\n\n\t/**********************************************************************************************\n\t * Properties.\n\t */\n\n\t/** Lists all {@link Scene} properties associated with this root. */\n\tpublic listScenes(): Scene[] {\n\t\treturn this.listRefs('scenes');\n\t}\n\n\t/** Default {@link Scene} associated with this root. */\n\tpublic setDefaultScene(defaultScene: Scene | null): this {\n\t\treturn this.setRef('defaultScene', defaultScene);\n\t}\n\n\t/** Default {@link Scene} associated with this root. */\n\tpublic getDefaultScene(): Scene | null {\n\t\treturn this.getRef('defaultScene');\n\t}\n\n\t/** Lists all {@link Node} properties associated with this root. */\n\tpublic listNodes(): Node[] {\n\t\treturn this.listRefs('nodes');\n\t}\n\n\t/** Lists all {@link Camera} properties associated with this root. */\n\tpublic listCameras(): Camera[] {\n\t\treturn this.listRefs('cameras');\n\t}\n\n\t/** Lists all {@link Skin} properties associated with this root. */\n\tpublic listSkins(): Skin[] {\n\t\treturn this.listRefs('skins');\n\t}\n\n\t/** Lists all {@link Mesh} properties associated with this root. */\n\tpublic listMeshes(): Mesh[] {\n\t\treturn this.listRefs('meshes');\n\t}\n\n\t/** Lists all {@link Material} properties associated with this root. */\n\tpublic listMaterials(): Material[] {\n\t\treturn this.listRefs('materials');\n\t}\n\n\t/** Lists all {@link Texture} properties associated with this root. */\n\tpublic listTextures(): Texture[] {\n\t\treturn this.listRefs('textures');\n\t}\n\n\t/** Lists all {@link Animation} properties associated with this root. */\n\tpublic listAnimations(): Animation[] {\n\t\treturn this.listRefs('animations');\n\t}\n\n\t/** Lists all {@link Accessor} properties associated with this root. */\n\tpublic listAccessors(): Accessor[] {\n\t\treturn this.listRefs('accessors');\n\t}\n\n\t/** Lists all {@link Buffer} properties associated with this root. */\n\tpublic listBuffers(): Buffer[] {\n\t\treturn this.listRefs('buffers');\n\t}\n}\n", "import { PropertyType } from './constants.js';\nimport type { Extension } from './extension.js';\nimport { Graph } from 'property-graph';\nimport {\n\tAccessor,\n\tAnimation,\n\tAnimationChannel,\n\tAnimationSampler,\n\tBuffer,\n\tCamera,\n\tMaterial,\n\tMesh,\n\tNode,\n\tPrimitive,\n\tPrimitiveTarget,\n\tProperty,\n\tRoot,\n\tScene,\n\tSkin,\n\tTexture,\n} from './properties/index.js';\nimport { ILogger, Logger } from './utils/index.js';\n\nexport interface TransformContext {\n\tstack: string[];\n}\n\nexport type Transform = (doc: Document, context?: TransformContext) => void;\n\n/**\n * *Wraps a glTF asset and its resources for easier modification.*\n *\n * Documents manage glTF assets and the relationships among dependencies. The document wrapper\n * allow tools to read and write changes without dealing with array indices or byte offsets, which\n * would otherwise require careful management over the course of a file modification. An internal\n * graph structure allows any property in the glTF file to maintain references to its dependencies,\n * and makes it easy to determine where a particular property dependency is being used. For\n * example, finding a list of materials that use a particular texture is as simple as calling\n * {@link Texture.listParents}().\n *\n * A new resource {@link Property} (e.g. a {@link Mesh} or {@link Material}) is created by calling\n * 'create' methods on the document. Resources are destroyed by calling {@link Property.dispose}().\n *\n * ```ts\n * import fs from 'fs/promises';\n * import { Document } from '@gltf-transform/core';\n * import { dedup } from '@gltf-transform/functions';\n *\n * const document = new Document();\n *\n * const texture1 = document.createTexture('myTexture')\n * \t.setImage(await fs.readFile('path/to/image.png'))\n * \t.setMimeType('image/png');\n * const texture2 = document.createTexture('myTexture2')\n * \t.setImage(await fs.readFile('path/to/image2.png'))\n * \t.setMimeType('image/png');\n *\n * // Document containing duplicate copies of the same texture.\n * document.getRoot().listTextures(); //  [texture x 2]\n *\n * await document.transform(\n * \tdedup({textures: true}),\n * \t// ...\n * );\n *\n * // Document with duplicate textures removed.\n * document.getRoot().listTextures(); //  [texture x 1]\n * ```\n *\n * Reference:\n * - [glTF  Basics](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#gltf-basics)\n * - [glTF  Concepts](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#concepts)\n *\n * @category Documents\n */\nexport class Document {\n\tprivate _graph: Graph<Property> = new Graph<Property>();\n\tprivate _root: Root = new Root(this._graph);\n\tprivate _logger: ILogger = Logger.DEFAULT_INSTANCE;\n\n\t/**\n\t * Enables lookup of a Document from its Graph. For internal use, only.\n\t * @internal\n\t * @experimental\n\t */\n\tprivate static _GRAPH_DOCUMENTS = new WeakMap<Graph<Property>, Document>();\n\n\t/**\n\t * Returns the Document associated with a given Graph, if any.\n\t * @hidden\n\t * @experimental\n\t */\n\tpublic static fromGraph(graph: Graph<Property>): Document | null {\n\t\treturn Document._GRAPH_DOCUMENTS.get(graph) || null;\n\t}\n\n\t/** Creates a new Document, representing an empty glTF asset. */\n\tpublic constructor() {\n\t\tDocument._GRAPH_DOCUMENTS.set(this._graph, this);\n\t}\n\n\t/** Returns the glTF {@link Root} property. */\n\tpublic getRoot(): Root {\n\t\treturn this._root;\n\t}\n\n\t/**\n\t * Returns the {@link Graph} representing connectivity of resources within this document.\n\t * @hidden\n\t */\n\tpublic getGraph(): Graph<Property> {\n\t\treturn this._graph;\n\t}\n\n\t/** Returns the {@link Logger} instance used for any operations performed on this document. */\n\tpublic getLogger(): ILogger {\n\t\treturn this._logger;\n\t}\n\n\t/**\n\t * Overrides the {@link Logger} instance used for any operations performed on this document.\n\t *\n\t * Usage:\n\t *\n\t * ```ts\n\t * doc\n\t * \t.setLogger(new Logger(Logger.Verbosity.SILENT))\n\t * \t.transform(dedup(), weld());\n\t * ```\n\t */\n\tpublic setLogger(logger: ILogger): Document {\n\t\tthis._logger = logger;\n\t\treturn this;\n\t}\n\n\t/** Clones this Document, copying all resources within it. */\n\tpublic clone(): Document {\n\t\treturn new Document().setLogger(this._logger).merge(this);\n\t}\n\n\t/** Merges the content of another Document into this one, without affecting the original. */\n\tpublic merge(other: Document): this {\n\t\t// 1. Attach extensions.\n\t\tconst thisExtensions: { [key: string]: Extension } = {};\n\t\tfor (const otherExtension of other.getRoot().listExtensionsUsed()) {\n\t\t\tconst thisExtension = this.createExtension(otherExtension.constructor as new (doc: Document) => Extension);\n\t\t\tif (otherExtension.isRequired()) thisExtension.setRequired(true);\n\t\t\tthisExtensions[thisExtension.extensionName] = thisExtension;\n\t\t}\n\n\t\t// 2. Preconfigure the Root and merge history.\n\t\tconst visited = new Set<Property>();\n\t\tconst propertyMap = new Map<Property, Property>();\n\t\tvisited.add(other._root);\n\t\tpropertyMap.set(other._root, this._root);\n\n\t\t// 3. Create stub classes for every Property in other Document.\n\t\tfor (const edge of other._graph.listEdges()) {\n\t\t\tfor (const otherProp of [edge.getParent() as Property, edge.getChild() as Property]) {\n\t\t\t\tif (visited.has(otherProp)) continue;\n\n\t\t\t\tlet thisProp: Property;\n\t\t\t\tif (otherProp.propertyType === PropertyType.TEXTURE_INFO) {\n\t\t\t\t\t// TextureInfo lifecycle is bound to a Material or ExtensionProperty.\n\t\t\t\t\tthisProp = otherProp as Property;\n\t\t\t\t} else {\n\t\t\t\t\t// For other property types, create stub classes.\n\t\t\t\t\tconst PropertyClass = otherProp.constructor as new (g: Graph<Property>) => Property;\n\t\t\t\t\tthisProp = new PropertyClass(this._graph);\n\t\t\t\t}\n\n\t\t\t\tpropertyMap.set(otherProp as Property, thisProp);\n\t\t\t\tvisited.add(otherProp);\n\t\t\t}\n\t\t}\n\n\t\t// 4. Assemble the edges between Properties.\n\t\tconst resolve = (p: Property): Property => {\n\t\t\tconst resolved = propertyMap.get(p);\n\t\t\tif (!resolved) throw new Error('Could resolve property.');\n\t\t\treturn resolved;\n\t\t};\n\t\tfor (const otherProp of visited) {\n\t\t\tconst thisProp = propertyMap.get(otherProp);\n\t\t\tif (!thisProp) throw new Error('Could resolve property.');\n\t\t\t// TextureInfo copy handled by Material or ExtensionProperty.\n\t\t\tif (thisProp.propertyType !== PropertyType.TEXTURE_INFO) {\n\t\t\t\tthisProp.copy(otherProp, resolve);\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Applies a series of modifications to this document. Each transformation is asynchronous,\n\t * takes the {@link Document} as input, and returns nothing. Transforms are applied in the\n\t * order given, which may affect the final result.\n\t *\n\t * Usage:\n\t *\n\t * ```ts\n\t * await doc.transform(\n\t * \tdedup(),\n\t * \tprune()\n\t * );\n\t * ```\n\t *\n\t * @param transforms List of synchronous transformation functions to apply.\n\t */\n\tpublic async transform(...transforms: Transform[]): Promise<this> {\n\t\tconst stack = transforms.map((fn) => fn.name);\n\t\tfor (const transform of transforms) {\n\t\t\tawait transform(this, { stack });\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**********************************************************************************************\n\t * Extension factory method.\n\t */\n\n\t/**\n\t * Creates a new {@link Extension}, for the extension type of the given constructor. If the\n\t * extension is already enabled for this Document, the previous Extension reference is reused.\n\t */\n\tcreateExtension<T extends Extension>(ctor: new (doc: Document) => T): T {\n\t\tconst extensionName = (ctor as unknown as { EXTENSION_NAME: 'string' }).EXTENSION_NAME;\n\t\tconst prevExtension = this.getRoot()\n\t\t\t.listExtensionsUsed()\n\t\t\t.find((ext) => ext.extensionName === extensionName);\n\t\treturn (prevExtension || new ctor(this)) as T;\n\t}\n\n\t/**********************************************************************************************\n\t * Property factory methods.\n\t */\n\n\t/** Creates a new {@link Scene} attached to this document's {@link Root}. */\n\tcreateScene(name = ''): Scene {\n\t\treturn new Scene(this._graph, name);\n\t}\n\n\t/** Creates a new {@link Node} attached to this document's {@link Root}. */\n\tcreateNode(name = ''): Node {\n\t\treturn new Node(this._graph, name);\n\t}\n\n\t/** Creates a new {@link Camera} attached to this document's {@link Root}. */\n\tcreateCamera(name = ''): Camera {\n\t\treturn new Camera(this._graph, name);\n\t}\n\n\t/** Creates a new {@link Skin} attached to this document's {@link Root}. */\n\tcreateSkin(name = ''): Skin {\n\t\treturn new Skin(this._graph, name);\n\t}\n\n\t/** Creates a new {@link Mesh} attached to this document's {@link Root}. */\n\tcreateMesh(name = ''): Mesh {\n\t\treturn new Mesh(this._graph, name);\n\t}\n\n\t/**\n\t * Creates a new {@link Primitive}. Primitives must be attached to a {@link Mesh}\n\t * for use and export; they are not otherwise associated with a {@link Root}.\n\t */\n\tcreatePrimitive(): Primitive {\n\t\treturn new Primitive(this._graph);\n\t}\n\n\t/**\n\t * Creates a new {@link PrimitiveTarget}, or morph target. Targets must be attached to a\n\t * {@link Primitive} for use and export; they are not otherwise associated with a {@link Root}.\n\t */\n\tcreatePrimitiveTarget(name = ''): PrimitiveTarget {\n\t\treturn new PrimitiveTarget(this._graph, name);\n\t}\n\n\t/** Creates a new {@link Material} attached to this document's {@link Root}. */\n\tcreateMaterial(name = ''): Material {\n\t\treturn new Material(this._graph, name);\n\t}\n\n\t/** Creates a new {@link Texture} attached to this document's {@link Root}. */\n\tcreateTexture(name = ''): Texture {\n\t\treturn new Texture(this._graph, name);\n\t}\n\n\t/** Creates a new {@link Animation} attached to this document's {@link Root}. */\n\tcreateAnimation(name = ''): Animation {\n\t\treturn new Animation(this._graph, name);\n\t}\n\n\t/**\n\t * Creates a new {@link AnimationChannel}. Channels must be attached to an {@link Animation}\n\t * for use and export; they are not otherwise associated with a {@link Root}.\n\t */\n\tcreateAnimationChannel(name = ''): AnimationChannel {\n\t\treturn new AnimationChannel(this._graph, name);\n\t}\n\n\t/**\n\t * Creates a new {@link AnimationSampler}. Samplers must be attached to an {@link Animation}\n\t * for use and export; they are not otherwise associated with a {@link Root}.\n\t */\n\tcreateAnimationSampler(name = ''): AnimationSampler {\n\t\treturn new AnimationSampler(this._graph, name);\n\t}\n\n\t/** Creates a new {@link Accessor} attached to this document's {@link Root}. */\n\tcreateAccessor(name = '', buffer: Buffer | null = null): Accessor {\n\t\tif (!buffer) {\n\t\t\tbuffer = this.getRoot().listBuffers()[0];\n\t\t}\n\t\treturn new Accessor(this._graph, name).setBuffer(buffer);\n\t}\n\n\t/** Creates a new {@link Buffer} attached to this document's {@link Root}. */\n\tcreateBuffer(name = ''): Buffer {\n\t\treturn new Buffer(this._graph, name);\n\t}\n}\n", "import type { GraphEdgeEvent, GraphEvent, GraphNodeEvent } from 'property-graph';\nimport type { PropertyType } from './constants.js';\nimport type { Document } from './document.js';\nimport type { ReaderContext, WriterContext } from './io/index.js';\nimport { ExtensionProperty } from './properties/index.js';\n\n/**\n * *Base class for all Extensions.*\n *\n * Extensions enhance a glTF {@link Document} with additional features and schema, beyond the core\n * glTF specification. Common extensions may be imported from the `@gltf-transform/extensions`\n * package, or custom extensions may be created by extending this base class.\n *\n * An extension is added to a Document by calling {@link Document.createExtension} with the\n * extension constructor. The extension object may then be used to construct\n * {@link ExtensionProperty} instances, which are attached to properties throughout the Document\n * as prescribed by the extension itself.\n *\n * For more information on available extensions and their usage, see [Extensions](/extensions).\n *\n * Reference:\n * - [glTF  Extensions](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#specifying-extensions)\n * - [glTF Extension Registry](https://github.com/KhronosGroup/gltf/blob/main/extensions)\n *\n * @category Extensions\n */\nexport abstract class Extension {\n\t/** Official name of the extension. */\n\tpublic static EXTENSION_NAME: string;\n\t/** Official name of the extension. */\n\tpublic readonly extensionName: string = '';\n\t/**\n\t * Before reading, extension should be called for these {@link Property} types. *Most\n\t * extensions don't need to implement this.*\n\t * @hidden\n\t */\n\tpublic readonly prereadTypes: PropertyType[] = [];\n\t/**\n\t * Before writing, extension should be called for these {@link Property} types. *Most\n\t * extensions don't need to implement this.*\n\t * @hidden\n\t */\n\tpublic readonly prewriteTypes: PropertyType[] = [];\n\n\t/** @hidden Dependency IDs needed to read this extension, to be installed before I/O. */\n\tpublic readonly readDependencies: string[] = [];\n\t/** @hidden Dependency IDs needed to write this extension, to be installed before I/O. */\n\tpublic readonly writeDependencies: string[] = [];\n\n\t/** @hidden */\n\tprotected readonly document: Document;\n\n\t/** @hidden */\n\tprotected required = false;\n\n\t/** @hidden */\n\tprotected properties: Set<ExtensionProperty> = new Set();\n\n\t/** @hidden */\n\tprivate _listener: (event: unknown) => void;\n\n\t/** @hidden */\n\tconstructor(document: Document) {\n\t\tthis.document = document;\n\n\t\tdocument.getRoot()._enableExtension(this);\n\n\t\tthis._listener = (_event: unknown): void => {\n\t\t\tconst event = _event as GraphNodeEvent | GraphEdgeEvent | GraphEvent;\n\t\t\tconst target = event.target as ExtensionProperty | unknown;\n\t\t\tif (target instanceof ExtensionProperty && target.extensionName === this.extensionName) {\n\t\t\t\tif (event.type === 'node:create') this._addExtensionProperty(target);\n\t\t\t\tif (event.type === 'node:dispose') this._removeExtensionProperty(target);\n\t\t\t}\n\t\t};\n\n\t\tconst graph = document.getGraph();\n\t\tgraph.addEventListener('node:create', this._listener);\n\t\tgraph.addEventListener('node:dispose', this._listener);\n\t}\n\n\t/** Disables and removes the extension from the Document. */\n\tpublic dispose(): void {\n\t\tthis.document.getRoot()._disableExtension(this);\n\t\tconst graph = this.document.getGraph();\n\t\tgraph.removeEventListener('node:create', this._listener);\n\t\tgraph.removeEventListener('node:dispose', this._listener);\n\t\tfor (const property of this.properties) {\n\t\t\tproperty.dispose();\n\t\t}\n\t}\n\n\t/** @hidden Performs first-time setup for the extension. Must be idempotent. */\n\t// eslint-disable-next-line @typescript-eslint/no-empty-function\n\tpublic static register(): void {}\n\n\t/**\n\t * Indicates to the client whether it is OK to load the asset when this extension is not\n\t * recognized. Optional extensions are generally preferred, if there is not a good reason\n\t * to require a client to completely fail when an extension isn't known.\n\t */\n\tpublic isRequired(): boolean {\n\t\treturn this.required;\n\t}\n\n\t/**\n\t * Indicates to the client whether it is OK to load the asset when this extension is not\n\t * recognized. Optional extensions are generally preferred, if there is not a good reason\n\t * to require a client to completely fail when an extension isn't known.\n\t */\n\tpublic setRequired(required: boolean): this {\n\t\tthis.required = required;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Lists all {@link ExtensionProperty} instances associated with, or created by, this\n\t * extension. Includes only instances that are attached to the Document's graph; detached\n\t * instances will be excluded.\n\t */\n\tpublic listProperties(): ExtensionProperty[] {\n\t\treturn Array.from(this.properties);\n\t}\n\n\t/**********************************************************************************************\n\t * ExtensionProperty management.\n\t */\n\n\t/** @internal */\n\tprivate _addExtensionProperty(property: ExtensionProperty): this {\n\t\tthis.properties.add(property);\n\t\treturn this;\n\t}\n\n\t/** @internal */\n\tprivate _removeExtensionProperty(property: ExtensionProperty): this {\n\t\tthis.properties.delete(property);\n\t\treturn this;\n\t}\n\n\t/**********************************************************************************************\n\t * I/O implementation.\n\t */\n\n\t/** @hidden Installs dependencies required by the extension. */\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tpublic install(key: string, dependency: unknown): this {\n\t\treturn this;\n\t}\n\n\t/**\n\t * Used by the {@link PlatformIO} utilities when reading a glTF asset. This method may\n\t * optionally be implemented by an extension, and should then support any property type\n\t * declared by the Extension's {@link Extension.prereadTypes} list. The Extension will\n\t * be given a ReaderContext instance, and is expected to update either the context or its\n\t * {@link JSONDocument} with resources known to the Extension. *Most extensions don't need to\n\t * implement this.*\n\t * @hidden\n\t */\n\tpublic preread(_readerContext: ReaderContext, _propertyType: PropertyType): this {\n\t\treturn this;\n\t}\n\n\t/**\n\t * Used by the {@link PlatformIO} utilities when writing a glTF asset. This method may\n\t * optionally be implemented by an extension, and should then support any property type\n\t * declared by the Extension's {@link Extension.prewriteTypes} list. The Extension will\n\t * be given a WriterContext instance, and is expected to update either the context or its\n\t * {@link JSONDocument} with resources known to the Extension. *Most extensions don't need to\n\t * implement this.*\n\t * @hidden\n\t */\n\tpublic prewrite(_writerContext: WriterContext, _propertyType: PropertyType): this {\n\t\treturn this;\n\t}\n\n\t/**\n\t * Used by the {@link PlatformIO} utilities when reading a glTF asset. This method must be\n\t * implemented by each extension in order to support reading files. The extension will be\n\t * given a ReaderContext instance, and should update the current {@link Document} accordingly.\n\t * @hidden\n\t */\n\tpublic abstract read(readerContext: ReaderContext): this;\n\n\t/**\n\t * Used by the {@link PlatformIO} utilities when writing a glTF asset. This method must be\n\t * implemented by each extension in order to support writing files. The extension will be\n\t * given a WriterContext instance, and should modify the {@link JSONDocument} output\n\t * accordingly. Adding the extension name to the `extensionsUsed` and `extensionsRequired` list\n\t * is done automatically, and should not be included here.\n\t * @hidden\n\t */\n\tpublic abstract write(writerContext: WriterContext): this;\n}\n", "import type { JSONDocument } from '../json-document.js';\nimport type {\n\tAccessor,\n\tAnimation,\n\tBuffer,\n\tCamera,\n\tMaterial,\n\tMesh,\n\tNode,\n\tScene,\n\tSkin,\n\tTexture,\n\tTextureInfo,\n} from '../properties/index.js';\nimport type { GLTF } from '../types/gltf.js';\n\n/**\n * Model class providing glTF Transform objects representing each definition in the glTF file, used\n * by a {@link GLTFReader} and its {@link Extension} implementations. Indices of all properties will be\n * consistent with the glTF file.\n *\n * @hidden\n */\nexport class ReaderContext {\n\tpublic buffers: Buffer[] = [];\n\tpublic bufferViews: Uint8Array[] = [];\n\tpublic bufferViewBuffers: Buffer[] = [];\n\tpublic accessors: Accessor[] = [];\n\tpublic textures: Texture[] = [];\n\tpublic textureInfos: Map<TextureInfo, GLTF.ITextureInfo> = new Map();\n\tpublic materials: Material[] = [];\n\tpublic meshes: Mesh[] = [];\n\tpublic cameras: Camera[] = [];\n\tpublic nodes: Node[] = [];\n\tpublic skins: Skin[] = [];\n\tpublic animations: Animation[] = [];\n\tpublic scenes: Scene[] = [];\n\n\tconstructor(public readonly jsonDoc: JSONDocument) {}\n\n\tpublic setTextureInfo(textureInfo: TextureInfo, textureInfoDef: GLTF.ITextureInfo): void {\n\t\tthis.textureInfos.set(textureInfo, textureInfoDef);\n\n\t\tif (textureInfoDef.texCoord !== undefined) {\n\t\t\ttextureInfo.setTexCoord(textureInfoDef.texCoord);\n\t\t}\n\t\tif (textureInfoDef.extras !== undefined) {\n\t\t\ttextureInfo.setExtras(textureInfoDef.extras);\n\t\t}\n\n\t\tconst textureDef = this.jsonDoc.json.textures![textureInfoDef.index];\n\n\t\tif (textureDef.sampler === undefined) return;\n\n\t\tconst samplerDef = this.jsonDoc.json.samplers![textureDef.sampler];\n\n\t\tif (samplerDef.magFilter !== undefined) {\n\t\t\ttextureInfo.setMagFilter(samplerDef.magFilter);\n\t\t}\n\t\tif (samplerDef.minFilter !== undefined) {\n\t\t\ttextureInfo.setMinFilter(samplerDef.minFilter);\n\t\t}\n\t\tif (samplerDef.wrapS !== undefined) {\n\t\t\ttextureInfo.setWrapS(samplerDef.wrapS);\n\t\t}\n\t\tif (samplerDef.wrapT !== undefined) {\n\t\t\ttextureInfo.setWrapT(samplerDef.wrapT);\n\t\t}\n\t}\n}\n", "import { GLB_BUFFER, PropertyType, TypedArray, mat4, vec3, vec4, ComponentTypeToTypedArray } from '../constants.js';\nimport { Document } from '../document.js';\nimport type { Extension } from '../extension.js';\nimport type { JSONDocument } from '../json-document.js';\nimport { Accessor, AnimationSampler, Camera } from '../properties/index.js';\nimport type { GLTF } from '../types/gltf.js';\nimport { BufferUtils, FileUtils, ILogger, ImageUtils, Logger, MathUtils } from '../utils/index.js';\nimport { ReaderContext } from './reader-context.js';\n\nexport interface ReaderOptions {\n\tlogger?: ILogger;\n\textensions: (typeof Extension)[];\n\tdependencies: { [key: string]: unknown };\n}\n\nconst DEFAULT_OPTIONS: ReaderOptions = {\n\tlogger: Logger.DEFAULT_INSTANCE,\n\textensions: [],\n\tdependencies: {},\n};\n\n/** @internal */\nexport class GLTFReader {\n\tpublic static read(jsonDoc: JSONDocument, _options: ReaderOptions = DEFAULT_OPTIONS): Document {\n\t\tconst options = { ...DEFAULT_OPTIONS, ..._options } as Required<ReaderOptions>;\n\t\tconst { json } = jsonDoc;\n\t\tconst document = new Document().setLogger(options.logger);\n\n\t\tthis.validate(jsonDoc, options);\n\n\t\t/* Reader context. */\n\n\t\tconst context = new ReaderContext(jsonDoc);\n\n\t\t/** Asset. */\n\n\t\tconst assetDef = json.asset;\n\t\tconst asset = document.getRoot().getAsset();\n\n\t\tif (assetDef.copyright) asset.copyright = assetDef.copyright;\n\t\tif (assetDef.extras) asset.extras = assetDef.extras;\n\n\t\tif (json.extras !== undefined) {\n\t\t\tdocument.getRoot().setExtras({ ...json.extras });\n\t\t}\n\n\t\t/** Extensions (1/2). */\n\n\t\tconst extensionsUsed = json.extensionsUsed || [];\n\t\tconst extensionsRequired = json.extensionsRequired || [];\n\t\tfor (const Extension of options.extensions) {\n\t\t\tif (extensionsUsed.includes(Extension.EXTENSION_NAME)) {\n\t\t\t\tconst extension = document\n\t\t\t\t\t.createExtension(Extension as unknown as new (doc: Document) => Extension)\n\t\t\t\t\t.setRequired(extensionsRequired.includes(Extension.EXTENSION_NAME));\n\n\t\t\t\tfor (const key of extension.readDependencies) {\n\t\t\t\t\textension.install(key, options.dependencies[key]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/** Buffers. */\n\n\t\tconst bufferDefs = json.buffers || [];\n\t\tdocument\n\t\t\t.getRoot()\n\t\t\t.listExtensionsUsed()\n\t\t\t.filter((extension) => extension.prereadTypes.includes(PropertyType.BUFFER))\n\t\t\t.forEach((extension) => extension.preread(context, PropertyType.BUFFER));\n\t\tcontext.buffers = bufferDefs.map((bufferDef) => {\n\t\t\tconst buffer = document.createBuffer(bufferDef.name);\n\n\t\t\tif (bufferDef.extras) buffer.setExtras(bufferDef.extras);\n\n\t\t\tif (bufferDef.uri && bufferDef.uri.indexOf('__') !== 0) {\n\t\t\t\tbuffer.setURI(bufferDef.uri);\n\t\t\t}\n\n\t\t\treturn buffer;\n\t\t});\n\n\t\t/** Buffer views. */\n\n\t\tconst bufferViewDefs = json.bufferViews || [];\n\t\tcontext.bufferViewBuffers = bufferViewDefs.map((bufferViewDef, index) => {\n\t\t\tif (!context.bufferViews[index]) {\n\t\t\t\tconst bufferDef = jsonDoc.json.buffers![bufferViewDef.buffer];\n\t\t\t\tconst resource = bufferDef.uri ? jsonDoc.resources[bufferDef.uri] : jsonDoc.resources[GLB_BUFFER];\n\t\t\t\tconst byteOffset = bufferViewDef.byteOffset || 0;\n\t\t\t\tcontext.bufferViews[index] = BufferUtils.toView(resource, byteOffset, bufferViewDef.byteLength);\n\t\t\t}\n\n\t\t\treturn context.buffers[bufferViewDef.buffer];\n\t\t});\n\n\t\t/** Accessors. */\n\n\t\t// Accessor .count and .componentType properties are inferred dynamically.\n\t\tconst accessorDefs = json.accessors || [];\n\t\tcontext.accessors = accessorDefs.map((accessorDef) => {\n\t\t\tconst buffer = context.bufferViewBuffers[accessorDef.bufferView!];\n\t\t\tconst accessor = document.createAccessor(accessorDef.name, buffer).setType(accessorDef.type);\n\n\t\t\tif (accessorDef.extras) accessor.setExtras(accessorDef.extras);\n\n\t\t\tif (accessorDef.normalized !== undefined) {\n\t\t\t\taccessor.setNormalized(accessorDef.normalized);\n\t\t\t}\n\n\t\t\t// Sparse accessors, KHR_draco_mesh_compression, and EXT_meshopt_compression.\n\t\t\tif (accessorDef.bufferView === undefined) return accessor;\n\n\t\t\t// NOTICE: We mark sparse accessors at the end of the I/O reading process. Consider an\n\t\t\t// accessor to be 'sparse' if it (A) includes sparse value overrides, or (B) does not\n\t\t\t// define .bufferView _and_ no extension provides that data.\n\n\t\t\taccessor.setArray(getAccessorArray(accessorDef, context));\n\t\t\treturn accessor;\n\t\t});\n\n\t\t/** Textures. */\n\n\t\t// glTF Transform's \"Texture\" properties correspond 1:1 with glTF \"Image\" properties, and\n\t\t// with image files. The glTF file may contain more one texture per image, where images\n\t\t// are reused with different sampler properties.\n\t\tconst imageDefs = json.images || [];\n\t\tconst textureDefs = json.textures || [];\n\t\tdocument\n\t\t\t.getRoot()\n\t\t\t.listExtensionsUsed()\n\t\t\t.filter((extension) => extension.prereadTypes.includes(PropertyType.TEXTURE))\n\t\t\t.forEach((extension) => extension.preread(context, PropertyType.TEXTURE));\n\t\tcontext.textures = imageDefs.map((imageDef) => {\n\t\t\tconst texture = document.createTexture(imageDef.name);\n\n\t\t\t// glTF Image corresponds 1:1 with glTF Transform Texture. See `writer.ts`.\n\t\t\tif (imageDef.extras) texture.setExtras(imageDef.extras);\n\n\t\t\tif (imageDef.bufferView !== undefined) {\n\t\t\t\tconst bufferViewDef = json.bufferViews![imageDef.bufferView];\n\t\t\t\tconst bufferDef = jsonDoc.json.buffers![bufferViewDef.buffer];\n\t\t\t\tconst bufferData = bufferDef.uri ? jsonDoc.resources[bufferDef.uri] : jsonDoc.resources[GLB_BUFFER];\n\t\t\t\tconst byteOffset = bufferViewDef.byteOffset || 0;\n\t\t\t\tconst byteLength = bufferViewDef.byteLength;\n\t\t\t\tconst imageData = bufferData.slice(byteOffset, byteOffset + byteLength);\n\t\t\t\ttexture.setImage(imageData);\n\t\t\t} else if (imageDef.uri !== undefined) {\n\t\t\t\ttexture.setImage(jsonDoc.resources[imageDef.uri]);\n\t\t\t\tif (imageDef.uri.indexOf('__') !== 0) {\n\t\t\t\t\ttexture.setURI(imageDef.uri);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (imageDef.mimeType !== undefined) {\n\t\t\t\ttexture.setMimeType(imageDef.mimeType);\n\t\t\t} else if (imageDef.uri) {\n\t\t\t\tconst extension = FileUtils.extension(imageDef.uri);\n\t\t\t\ttexture.setMimeType(ImageUtils.extensionToMimeType(extension));\n\t\t\t}\n\n\t\t\treturn texture;\n\t\t});\n\n\t\t/** Materials. */\n\n\t\tconst materialDefs = json.materials || [];\n\t\tcontext.materials = materialDefs.map((materialDef) => {\n\t\t\tconst material = document.createMaterial(materialDef.name);\n\n\t\t\tif (materialDef.extras) material.setExtras(materialDef.extras);\n\n\t\t\t// Program state & blending.\n\n\t\t\tif (materialDef.alphaMode !== undefined) {\n\t\t\t\tmaterial.setAlphaMode(materialDef.alphaMode);\n\t\t\t}\n\n\t\t\tif (materialDef.alphaCutoff !== undefined) {\n\t\t\t\tmaterial.setAlphaCutoff(materialDef.alphaCutoff);\n\t\t\t}\n\n\t\t\tif (materialDef.doubleSided !== undefined) {\n\t\t\t\tmaterial.setDoubleSided(materialDef.doubleSided);\n\t\t\t}\n\n\t\t\t// Factors.\n\n\t\t\tconst pbrDef = materialDef.pbrMetallicRoughness || {};\n\n\t\t\tif (pbrDef.baseColorFactor !== undefined) {\n\t\t\t\tmaterial.setBaseColorFactor(pbrDef.baseColorFactor as vec4);\n\t\t\t}\n\n\t\t\tif (materialDef.emissiveFactor !== undefined) {\n\t\t\t\tmaterial.setEmissiveFactor(materialDef.emissiveFactor as vec3);\n\t\t\t}\n\n\t\t\tif (pbrDef.metallicFactor !== undefined) {\n\t\t\t\tmaterial.setMetallicFactor(pbrDef.metallicFactor);\n\t\t\t}\n\n\t\t\tif (pbrDef.roughnessFactor !== undefined) {\n\t\t\t\tmaterial.setRoughnessFactor(pbrDef.roughnessFactor);\n\t\t\t}\n\n\t\t\t// Textures.\n\n\t\t\tif (pbrDef.baseColorTexture !== undefined) {\n\t\t\t\tconst textureInfoDef = pbrDef.baseColorTexture;\n\t\t\t\tconst texture = context.textures[textureDefs[textureInfoDef.index].source!];\n\t\t\t\tmaterial.setBaseColorTexture(texture);\n\t\t\t\tcontext.setTextureInfo(material.getBaseColorTextureInfo()!, textureInfoDef);\n\t\t\t}\n\n\t\t\tif (materialDef.emissiveTexture !== undefined) {\n\t\t\t\tconst textureInfoDef = materialDef.emissiveTexture;\n\t\t\t\tconst texture = context.textures[textureDefs[textureInfoDef.index].source!];\n\t\t\t\tmaterial.setEmissiveTexture(texture);\n\t\t\t\tcontext.setTextureInfo(material.getEmissiveTextureInfo()!, textureInfoDef);\n\t\t\t}\n\n\t\t\tif (materialDef.normalTexture !== undefined) {\n\t\t\t\tconst textureInfoDef = materialDef.normalTexture;\n\t\t\t\tconst texture = context.textures[textureDefs[textureInfoDef.index].source!];\n\t\t\t\tmaterial.setNormalTexture(texture);\n\t\t\t\tcontext.setTextureInfo(material.getNormalTextureInfo()!, textureInfoDef);\n\t\t\t\tif (materialDef.normalTexture.scale !== undefined) {\n\t\t\t\t\tmaterial.setNormalScale(materialDef.normalTexture.scale);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (materialDef.occlusionTexture !== undefined) {\n\t\t\t\tconst textureInfoDef = materialDef.occlusionTexture;\n\t\t\t\tconst texture = context.textures[textureDefs[textureInfoDef.index].source!];\n\t\t\t\tmaterial.setOcclusionTexture(texture);\n\t\t\t\tcontext.setTextureInfo(material.getOcclusionTextureInfo()!, textureInfoDef);\n\t\t\t\tif (materialDef.occlusionTexture.strength !== undefined) {\n\t\t\t\t\tmaterial.setOcclusionStrength(materialDef.occlusionTexture.strength);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (pbrDef.metallicRoughnessTexture !== undefined) {\n\t\t\t\tconst textureInfoDef = pbrDef.metallicRoughnessTexture;\n\t\t\t\tconst texture = context.textures[textureDefs[textureInfoDef.index].source!];\n\t\t\t\tmaterial.setMetallicRoughnessTexture(texture);\n\t\t\t\tcontext.setTextureInfo(material.getMetallicRoughnessTextureInfo()!, textureInfoDef);\n\t\t\t}\n\n\t\t\treturn material;\n\t\t});\n\n\t\t/** Meshes. */\n\n\t\tconst meshDefs = json.meshes || [];\n\t\tdocument\n\t\t\t.getRoot()\n\t\t\t.listExtensionsUsed()\n\t\t\t.filter((extension) => extension.prereadTypes.includes(PropertyType.PRIMITIVE))\n\t\t\t.forEach((extension) => extension.preread(context, PropertyType.PRIMITIVE));\n\t\tcontext.meshes = meshDefs.map((meshDef) => {\n\t\t\tconst mesh = document.createMesh(meshDef.name);\n\n\t\t\tif (meshDef.extras) mesh.setExtras(meshDef.extras);\n\n\t\t\tif (meshDef.weights !== undefined) {\n\t\t\t\tmesh.setWeights(meshDef.weights);\n\t\t\t}\n\n\t\t\tconst primitiveDefs = meshDef.primitives || [];\n\t\t\tprimitiveDefs.forEach((primitiveDef) => {\n\t\t\t\tconst primitive = document.createPrimitive();\n\n\t\t\t\tif (primitiveDef.extras) primitive.setExtras(primitiveDef.extras);\n\n\t\t\t\tif (primitiveDef.material !== undefined) {\n\t\t\t\t\tprimitive.setMaterial(context.materials[primitiveDef.material]);\n\t\t\t\t}\n\n\t\t\t\tif (primitiveDef.mode !== undefined) {\n\t\t\t\t\tprimitive.setMode(primitiveDef.mode);\n\t\t\t\t}\n\n\t\t\t\tfor (const [semantic, index] of Object.entries(primitiveDef.attributes || {})) {\n\t\t\t\t\tprimitive.setAttribute(semantic, context.accessors[index]);\n\t\t\t\t}\n\n\t\t\t\tif (primitiveDef.indices !== undefined) {\n\t\t\t\t\tprimitive.setIndices(context.accessors[primitiveDef.indices]);\n\t\t\t\t}\n\n\t\t\t\tconst targetNames: string[] = (meshDef.extras && (meshDef.extras.targetNames as string[])) || [];\n\t\t\t\tconst targetDefs = primitiveDef.targets || [];\n\t\t\t\ttargetDefs.forEach((targetDef, targetIndex) => {\n\t\t\t\t\tconst targetName = targetNames[targetIndex] || targetIndex.toString();\n\t\t\t\t\tconst target = document.createPrimitiveTarget(targetName);\n\n\t\t\t\t\tfor (const [semantic, accessorIndex] of Object.entries(targetDef)) {\n\t\t\t\t\t\ttarget.setAttribute(semantic, context.accessors[accessorIndex]);\n\t\t\t\t\t}\n\n\t\t\t\t\tprimitive.addTarget(target);\n\t\t\t\t});\n\n\t\t\t\tmesh.addPrimitive(primitive);\n\t\t\t});\n\n\t\t\treturn mesh;\n\t\t});\n\n\t\t/** Cameras. */\n\n\t\tconst cameraDefs = json.cameras || [];\n\t\tcontext.cameras = cameraDefs.map((cameraDef) => {\n\t\t\tconst camera = document.createCamera(cameraDef.name).setType(cameraDef.type);\n\n\t\t\tif (cameraDef.extras) camera.setExtras(cameraDef.extras);\n\n\t\t\tif (cameraDef.type === Camera.Type.PERSPECTIVE) {\n\t\t\t\tconst perspectiveDef = cameraDef.perspective!;\n\t\t\t\tcamera.setYFov(perspectiveDef.yfov);\n\t\t\t\tcamera.setZNear(perspectiveDef.znear);\n\t\t\t\tif (perspectiveDef.zfar !== undefined) {\n\t\t\t\t\tcamera.setZFar(perspectiveDef.zfar);\n\t\t\t\t}\n\t\t\t\tif (perspectiveDef.aspectRatio !== undefined) {\n\t\t\t\t\tcamera.setAspectRatio(perspectiveDef.aspectRatio);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst orthoDef = cameraDef.orthographic!;\n\t\t\t\tcamera.setZNear(orthoDef.znear).setZFar(orthoDef.zfar).setXMag(orthoDef.xmag).setYMag(orthoDef.ymag);\n\t\t\t}\n\t\t\treturn camera;\n\t\t});\n\n\t\t/** Nodes. */\n\n\t\tconst nodeDefs = json.nodes || [];\n\n\t\tdocument\n\t\t\t.getRoot()\n\t\t\t.listExtensionsUsed()\n\t\t\t.filter((extension) => extension.prereadTypes.includes(PropertyType.NODE))\n\t\t\t.forEach((extension) => extension.preread(context, PropertyType.NODE));\n\n\t\tcontext.nodes = nodeDefs.map((nodeDef) => {\n\t\t\tconst node = document.createNode(nodeDef.name);\n\n\t\t\tif (nodeDef.extras) node.setExtras(nodeDef.extras);\n\n\t\t\tif (nodeDef.translation !== undefined) {\n\t\t\t\tnode.setTranslation(nodeDef.translation as vec3);\n\t\t\t}\n\n\t\t\tif (nodeDef.rotation !== undefined) {\n\t\t\t\tnode.setRotation(nodeDef.rotation as vec4);\n\t\t\t}\n\n\t\t\tif (nodeDef.scale !== undefined) {\n\t\t\t\tnode.setScale(nodeDef.scale as vec3);\n\t\t\t}\n\n\t\t\tif (nodeDef.matrix !== undefined) {\n\t\t\t\tconst translation = [0, 0, 0] as vec3;\n\t\t\t\tconst rotation = [0, 0, 0, 1] as vec4;\n\t\t\t\tconst scale = [1, 1, 1] as vec3;\n\n\t\t\t\tMathUtils.decompose(nodeDef.matrix as mat4, translation, rotation, scale);\n\n\t\t\t\tnode.setTranslation(translation);\n\t\t\t\tnode.setRotation(rotation);\n\t\t\t\tnode.setScale(scale);\n\t\t\t}\n\n\t\t\tif (nodeDef.weights !== undefined) {\n\t\t\t\tnode.setWeights(nodeDef.weights);\n\t\t\t}\n\n\t\t\t// Attachments (mesh, camera, skin) defined later in reading process.\n\n\t\t\treturn node;\n\t\t});\n\n\t\t/** Skins. */\n\n\t\tconst skinDefs = json.skins || [];\n\t\tcontext.skins = skinDefs.map((skinDef) => {\n\t\t\tconst skin = document.createSkin(skinDef.name);\n\n\t\t\tif (skinDef.extras) skin.setExtras(skinDef.extras);\n\n\t\t\tif (skinDef.inverseBindMatrices !== undefined) {\n\t\t\t\tskin.setInverseBindMatrices(context.accessors[skinDef.inverseBindMatrices]);\n\t\t\t}\n\n\t\t\tif (skinDef.skeleton !== undefined) {\n\t\t\t\tskin.setSkeleton(context.nodes[skinDef.skeleton]);\n\t\t\t}\n\n\t\t\tfor (const nodeIndex of skinDef.joints) {\n\t\t\t\tskin.addJoint(context.nodes[nodeIndex]);\n\t\t\t}\n\n\t\t\treturn skin;\n\t\t});\n\n\t\t/** Node attachments. */\n\n\t\tnodeDefs.map((nodeDef, nodeIndex) => {\n\t\t\tconst node = context.nodes[nodeIndex];\n\n\t\t\tconst children = nodeDef.children || [];\n\t\t\tchildren.forEach((childIndex) => node.addChild(context.nodes[childIndex]));\n\n\t\t\tif (nodeDef.mesh !== undefined) node.setMesh(context.meshes[nodeDef.mesh]);\n\n\t\t\tif (nodeDef.camera !== undefined) node.setCamera(context.cameras[nodeDef.camera]);\n\n\t\t\tif (nodeDef.skin !== undefined) node.setSkin(context.skins[nodeDef.skin]);\n\t\t});\n\n\t\t/** Animations. */\n\n\t\tconst animationDefs = json.animations || [];\n\t\tcontext.animations = animationDefs.map((animationDef) => {\n\t\t\tconst animation = document.createAnimation(animationDef.name);\n\n\t\t\tif (animationDef.extras) animation.setExtras(animationDef.extras);\n\n\t\t\tconst samplerDefs = animationDef.samplers || [];\n\t\t\tconst samplers = samplerDefs.map((samplerDef) => {\n\t\t\t\tconst sampler = document\n\t\t\t\t\t.createAnimationSampler()\n\t\t\t\t\t.setInput(context.accessors[samplerDef.input])\n\t\t\t\t\t.setOutput(context.accessors[samplerDef.output])\n\t\t\t\t\t.setInterpolation(samplerDef.interpolation || AnimationSampler.Interpolation.LINEAR);\n\n\t\t\t\tif (samplerDef.extras) sampler.setExtras(samplerDef.extras);\n\n\t\t\t\tanimation.addSampler(sampler);\n\t\t\t\treturn sampler;\n\t\t\t});\n\n\t\t\tconst channels = animationDef.channels || [];\n\t\t\tchannels.forEach((channelDef) => {\n\t\t\t\tconst channel = document\n\t\t\t\t\t.createAnimationChannel()\n\t\t\t\t\t.setSampler(samplers[channelDef.sampler])\n\t\t\t\t\t.setTargetPath(channelDef.target.path);\n\n\t\t\t\tif (channelDef.target.node !== undefined) channel.setTargetNode(context.nodes[channelDef.target.node]);\n\t\t\t\tif (channelDef.extras) channel.setExtras(channelDef.extras);\n\n\t\t\t\tanimation.addChannel(channel);\n\t\t\t});\n\n\t\t\treturn animation;\n\t\t});\n\n\t\t/** Scenes. */\n\n\t\tconst sceneDefs = json.scenes || [];\n\n\t\tdocument\n\t\t\t.getRoot()\n\t\t\t.listExtensionsUsed()\n\t\t\t.filter((extension) => extension.prereadTypes.includes(PropertyType.SCENE))\n\t\t\t.forEach((extension) => extension.preread(context, PropertyType.SCENE));\n\n\t\tcontext.scenes = sceneDefs.map((sceneDef) => {\n\t\t\tconst scene = document.createScene(sceneDef.name);\n\n\t\t\tif (sceneDef.extras) scene.setExtras(sceneDef.extras);\n\n\t\t\tconst children = sceneDef.nodes || [];\n\n\t\t\tchildren.map((nodeIndex) => context.nodes[nodeIndex]).forEach((node) => scene.addChild(node));\n\n\t\t\treturn scene;\n\t\t});\n\n\t\tif (json.scene !== undefined) {\n\t\t\tdocument.getRoot().setDefaultScene(context.scenes[json.scene]);\n\t\t}\n\n\t\t/** Extensions (2/2). */\n\n\t\tdocument\n\t\t\t.getRoot()\n\t\t\t.listExtensionsUsed()\n\t\t\t.forEach((extension) => extension.read(context));\n\n\t\t/** Post-processing. */\n\n\t\t// Consider an accessor to be 'sparse' if it (A) includes sparse value overrides,\n\t\t// or (B) does not define .bufferView _and_ no extension provides that data. Case\n\t\t// (B) represents a zero-filled accessor.\n\t\taccessorDefs.forEach((accessorDef, index) => {\n\t\t\tconst accessor = context.accessors[index];\n\t\t\tconst hasSparseValues = !!accessorDef.sparse;\n\t\t\tconst isZeroFilled = !accessorDef.bufferView && !accessor.getArray();\n\t\t\tif (hasSparseValues || isZeroFilled) {\n\t\t\t\taccessor.setSparse(true).setArray(getSparseArray(accessorDef, context));\n\t\t\t}\n\t\t});\n\n\t\treturn document;\n\t}\n\n\tprivate static validate(jsonDoc: JSONDocument, options: Required<ReaderOptions>): void {\n\t\tconst json = jsonDoc.json;\n\n\t\tif (json.asset.version !== '2.0') {\n\t\t\tthrow new Error(`Unsupported glTF version, \"${json.asset.version}\".`);\n\t\t}\n\n\t\tif (json.extensionsRequired) {\n\t\t\tfor (const extensionName of json.extensionsRequired) {\n\t\t\t\tif (!options.extensions.find((extension) => extension.EXTENSION_NAME === extensionName)) {\n\t\t\t\t\tthrow new Error(`Missing required extension, \"${extensionName}\".`);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (json.extensionsUsed) {\n\t\t\tfor (const extensionName of json.extensionsUsed) {\n\t\t\t\tif (!options.extensions.find((extension) => extension.EXTENSION_NAME === extensionName)) {\n\t\t\t\t\toptions.logger.warn(`Missing optional extension, \"${extensionName}\".`);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Returns the contents of an interleaved accessor, as a typed array.\n * @internal\n */\nfunction getInterleavedArray(accessorDef: GLTF.IAccessor, context: ReaderContext): TypedArray {\n\tconst jsonDoc = context.jsonDoc;\n\tconst bufferView = context.bufferViews[accessorDef.bufferView!];\n\tconst bufferViewDef = jsonDoc.json.bufferViews![accessorDef.bufferView!];\n\n\tconst TypedArray = ComponentTypeToTypedArray[accessorDef.componentType];\n\tconst elementSize = Accessor.getElementSize(accessorDef.type);\n\tconst componentSize = TypedArray.BYTES_PER_ELEMENT;\n\tconst accessorByteOffset = accessorDef.byteOffset || 0;\n\n\tconst array = new TypedArray(accessorDef.count * elementSize);\n\tconst view = new DataView(bufferView.buffer, bufferView.byteOffset, bufferView.byteLength);\n\tconst byteStride = bufferViewDef.byteStride!;\n\n\tfor (let i = 0; i < accessorDef.count; i++) {\n\t\tfor (let j = 0; j < elementSize; j++) {\n\t\t\tconst byteOffset = accessorByteOffset + i * byteStride + j * componentSize;\n\t\t\tlet value: number;\n\t\t\tswitch (accessorDef.componentType) {\n\t\t\t\tcase Accessor.ComponentType.FLOAT:\n\t\t\t\t\tvalue = view.getFloat32(byteOffset, true);\n\t\t\t\t\tbreak;\n\t\t\t\tcase Accessor.ComponentType.UNSIGNED_INT:\n\t\t\t\t\tvalue = view.getUint32(byteOffset, true);\n\t\t\t\t\tbreak;\n\t\t\t\tcase Accessor.ComponentType.UNSIGNED_SHORT:\n\t\t\t\t\tvalue = view.getUint16(byteOffset, true);\n\t\t\t\t\tbreak;\n\t\t\t\tcase Accessor.ComponentType.UNSIGNED_BYTE:\n\t\t\t\t\tvalue = view.getUint8(byteOffset);\n\t\t\t\t\tbreak;\n\t\t\t\tcase Accessor.ComponentType.SHORT:\n\t\t\t\t\tvalue = view.getInt16(byteOffset, true);\n\t\t\t\t\tbreak;\n\t\t\t\tcase Accessor.ComponentType.BYTE:\n\t\t\t\t\tvalue = view.getInt8(byteOffset);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(`Unexpected componentType \"${accessorDef.componentType}\".`);\n\t\t\t}\n\t\t\tarray[i * elementSize + j] = value;\n\t\t}\n\t}\n\n\treturn array;\n}\n\n/**\n * Returns the contents of an accessor, as a typed array.\n * @internal\n */\nfunction getAccessorArray(accessorDef: GLTF.IAccessor, context: ReaderContext): TypedArray {\n\tconst jsonDoc = context.jsonDoc;\n\tconst bufferView = context.bufferViews[accessorDef.bufferView!];\n\tconst bufferViewDef = jsonDoc.json.bufferViews![accessorDef.bufferView!];\n\n\tconst TypedArray = ComponentTypeToTypedArray[accessorDef.componentType];\n\tconst elementSize = Accessor.getElementSize(accessorDef.type);\n\tconst componentSize = TypedArray.BYTES_PER_ELEMENT;\n\tconst elementStride = elementSize * componentSize;\n\n\t// Interleaved buffer view.\n\tif (bufferViewDef.byteStride !== undefined && bufferViewDef.byteStride !== elementStride) {\n\t\treturn getInterleavedArray(accessorDef, context);\n\t}\n\n\tconst byteOffset = bufferView.byteOffset + (accessorDef.byteOffset || 0);\n\tconst byteLength = accessorDef.count * elementSize * componentSize;\n\n\t// Might optimize this to avoid deep copy later, but it's useful for now and not a known\n\t// bottleneck. See https://github.com/donmccurdy/glTF-Transform/issues/256.\n\treturn new TypedArray(bufferView.buffer.slice(byteOffset, byteOffset + byteLength));\n}\n\n/**\n * Returns the contents of a sparse accessor, as a typed array.\n * @internal\n */\nfunction getSparseArray(accessorDef: GLTF.IAccessor, context: ReaderContext): TypedArray {\n\tconst TypedArray = ComponentTypeToTypedArray[accessorDef.componentType];\n\tconst elementSize = Accessor.getElementSize(accessorDef.type);\n\n\tlet array: TypedArray;\n\tif (accessorDef.bufferView !== undefined) {\n\t\tarray = getAccessorArray(accessorDef, context);\n\t} else {\n\t\tarray = new TypedArray(accessorDef.count * elementSize);\n\t}\n\n\tconst sparseDef = accessorDef.sparse;\n\tif (!sparseDef) return array; // Zero-filled accessor.\n\n\tconst count = sparseDef.count;\n\tconst indicesDef = { ...accessorDef, ...sparseDef.indices, count, type: 'SCALAR' };\n\tconst valuesDef = { ...accessorDef, ...sparseDef.values, count };\n\tconst indices = getAccessorArray(indicesDef as GLTF.IAccessor, context);\n\tconst values = getAccessorArray(valuesDef, context);\n\n\t// Override indices given in the sparse data.\n\tfor (let i = 0; i < indicesDef.count; i++) {\n\t\tfor (let j = 0; j < elementSize; j++) {\n\t\t\tarray[indices[i] * elementSize + j] = values[i * elementSize + j];\n\t\t}\n\t}\n\n\treturn array;\n}\n", "import { BufferViewUsage, Format, PropertyType } from '../constants.js';\nimport type { Document } from '../document.js';\nimport type { JSONDocument } from '../json-document.js';\nimport type {\n\tAccessor,\n\tAnimation,\n\tBuffer,\n\tCamera,\n\tMaterial,\n\tMesh,\n\tNode,\n\tProperty,\n\tScene,\n\tSkin,\n\tTexture,\n\tTextureInfo,\n} from '../properties/index.js';\nimport type { GLTF } from '../types/gltf.js';\nimport { ILogger, ImageUtils } from '../utils/index.js';\nimport type { WriterOptions } from './writer.js';\n\ntype PropertyDef = GLTF.IScene | GLTF.INode | GLTF.IMaterial | GLTF.ISkin | GLTF.ITexture;\n\nenum BufferViewTarget {\n\tARRAY_BUFFER = 34962,\n\tELEMENT_ARRAY_BUFFER = 34963,\n}\n\n/**\n * Model class providing writing state to a {@link GLTFWriter} and its {@link Extension}\n * implementations.\n *\n * @hidden\n */\nexport class WriterContext {\n\t/** Explicit buffer view targets defined by glTF specification. */\n\tpublic static readonly BufferViewTarget = BufferViewTarget;\n\t/**\n\t * Implicit buffer view usage, not required by glTF specification, but nonetheless useful for\n\t * proper grouping of accessors into buffer views. Additional usages are defined by extensions,\n\t * like `EXT_mesh_gpu_instancing`.\n\t */\n\tpublic static readonly BufferViewUsage = BufferViewUsage;\n\t/** Maps usage type to buffer view target. Usages not mapped have undefined targets. */\n\tpublic static readonly USAGE_TO_TARGET: { [key: string]: BufferViewTarget | undefined } = {\n\t\t[BufferViewUsage.ARRAY_BUFFER]: BufferViewTarget.ARRAY_BUFFER,\n\t\t[BufferViewUsage.ELEMENT_ARRAY_BUFFER]: BufferViewTarget.ELEMENT_ARRAY_BUFFER,\n\t};\n\n\tpublic readonly accessorIndexMap = new Map<Accessor, number>();\n\tpublic readonly animationIndexMap = new Map<Animation, number>();\n\tpublic readonly bufferIndexMap = new Map<Buffer, number>();\n\tpublic readonly cameraIndexMap = new Map<Camera, number>();\n\tpublic readonly skinIndexMap = new Map<Skin, number>();\n\tpublic readonly materialIndexMap = new Map<Material, number>();\n\tpublic readonly meshIndexMap = new Map<Mesh, number>();\n\tpublic readonly nodeIndexMap = new Map<Node, number>();\n\tpublic readonly imageIndexMap = new Map<Texture, number>();\n\tpublic readonly textureDefIndexMap = new Map<string, number>(); // textureDef JSON -> index\n\tpublic readonly textureInfoDefMap = new Map<TextureInfo, GLTF.ITextureInfo>();\n\tpublic readonly samplerDefIndexMap = new Map<string, number>(); // samplerDef JSON -> index\n\tpublic readonly sceneIndexMap = new Map<Scene, number>();\n\n\tpublic readonly imageBufferViews: Uint8Array[] = [];\n\tpublic readonly otherBufferViews = new Map<Buffer, Uint8Array[]>();\n\tpublic readonly otherBufferViewsIndexMap = new Map<Uint8Array, number>();\n\tpublic readonly extensionData: { [key: string]: unknown } = {};\n\n\tpublic bufferURIGenerator: UniqueURIGenerator<Buffer>;\n\tpublic imageURIGenerator: UniqueURIGenerator<Texture>;\n\tpublic logger: ILogger;\n\n\tprivate readonly _accessorUsageMap = new Map<Accessor, BufferViewUsage | string>();\n\tpublic readonly accessorUsageGroupedByParent = new Set<string>(['ARRAY_BUFFER']);\n\tpublic readonly accessorParents = new Map<Property, Set<Accessor>>();\n\n\tconstructor(\n\t\tprivate readonly _doc: Document,\n\t\tpublic readonly jsonDoc: JSONDocument,\n\t\tpublic readonly options: Required<WriterOptions>\n\t) {\n\t\tconst root = _doc.getRoot();\n\t\tconst numBuffers = root.listBuffers().length;\n\t\tconst numImages = root.listTextures().length;\n\t\tthis.bufferURIGenerator = new UniqueURIGenerator(numBuffers > 1, () => options.basename || 'buffer');\n\t\tthis.imageURIGenerator = new UniqueURIGenerator(\n\t\t\tnumImages > 1,\n\t\t\t(texture) => getSlot(_doc, texture) || options.basename || 'texture'\n\t\t);\n\t\tthis.logger = _doc.getLogger();\n\t}\n\n\t/**\n\t * Creates a TextureInfo definition, and any Texture or Sampler definitions it requires. If\n\t * possible, Texture and Sampler definitions are shared.\n\t */\n\tpublic createTextureInfoDef(texture: Texture, textureInfo: TextureInfo): GLTF.ITextureInfo {\n\t\tconst samplerDef = {\n\t\t\tmagFilter: textureInfo.getMagFilter() || undefined,\n\t\t\tminFilter: textureInfo.getMinFilter() || undefined,\n\t\t\twrapS: textureInfo.getWrapS(),\n\t\t\twrapT: textureInfo.getWrapT(),\n\t\t} as GLTF.ISampler;\n\n\t\tconst samplerKey = JSON.stringify(samplerDef);\n\t\tif (!this.samplerDefIndexMap.has(samplerKey)) {\n\t\t\tthis.samplerDefIndexMap.set(samplerKey, this.jsonDoc.json.samplers!.length);\n\t\t\tthis.jsonDoc.json.samplers!.push(samplerDef);\n\t\t}\n\n\t\tconst textureDef = {\n\t\t\tsource: this.imageIndexMap.get(texture),\n\t\t\tsampler: this.samplerDefIndexMap.get(samplerKey),\n\t\t} as GLTF.ITexture;\n\n\t\tconst textureKey = JSON.stringify(textureDef);\n\t\tif (!this.textureDefIndexMap.has(textureKey)) {\n\t\t\tthis.textureDefIndexMap.set(textureKey, this.jsonDoc.json.textures!.length);\n\t\t\tthis.jsonDoc.json.textures!.push(textureDef);\n\t\t}\n\n\t\tconst textureInfoDef = {\n\t\t\tindex: this.textureDefIndexMap.get(textureKey),\n\t\t} as GLTF.ITextureInfo;\n\n\t\tif (textureInfo.getTexCoord() !== 0) {\n\t\t\ttextureInfoDef.texCoord = textureInfo.getTexCoord();\n\t\t}\n\t\tif (Object.keys(textureInfo.getExtras()).length > 0) {\n\t\t\ttextureInfoDef.extras = textureInfo.getExtras();\n\t\t}\n\n\t\tthis.textureInfoDefMap.set(textureInfo, textureInfoDef);\n\n\t\treturn textureInfoDef;\n\t}\n\n\tpublic createPropertyDef(property: Property): PropertyDef {\n\t\tconst def = {} as PropertyDef;\n\t\tif (property.getName()) {\n\t\t\tdef.name = property.getName();\n\t\t}\n\t\tif (Object.keys(property.getExtras()).length > 0) {\n\t\t\tdef.extras = property.getExtras();\n\t\t}\n\t\treturn def;\n\t}\n\n\tpublic createAccessorDef(accessor: Accessor): GLTF.IAccessor {\n\t\tconst accessorDef = this.createPropertyDef(accessor) as GLTF.IAccessor;\n\t\taccessorDef.type = accessor.getType();\n\t\taccessorDef.componentType = accessor.getComponentType();\n\t\taccessorDef.count = accessor.getCount();\n\n\t\tconst needsBounds = this._doc\n\t\t\t.getGraph()\n\t\t\t.listParentEdges(accessor)\n\t\t\t.some(\n\t\t\t\t(edge) =>\n\t\t\t\t\t(edge.getName() === 'attributes' && edge.getAttributes().key === 'POSITION') ||\n\t\t\t\t\tedge.getName() === 'input'\n\t\t\t);\n\t\tif (needsBounds) {\n\t\t\taccessorDef.max = accessor.getMax([]).map(Math.fround);\n\t\t\taccessorDef.min = accessor.getMin([]).map(Math.fround);\n\t\t}\n\n\t\tif (accessor.getNormalized()) {\n\t\t\taccessorDef.normalized = accessor.getNormalized();\n\t\t}\n\n\t\treturn accessorDef;\n\t}\n\n\tpublic createImageData(imageDef: GLTF.IImage, data: Uint8Array, texture: Texture): void {\n\t\tif (this.options.format === Format.GLB) {\n\t\t\tthis.imageBufferViews.push(data);\n\t\t\timageDef.bufferView = this.jsonDoc.json.bufferViews!.length;\n\t\t\tthis.jsonDoc.json.bufferViews!.push({\n\t\t\t\tbuffer: 0,\n\t\t\t\tbyteOffset: -1, // determined while iterating buffers, in Writer.ts.\n\t\t\t\tbyteLength: data.byteLength,\n\t\t\t});\n\t\t} else {\n\t\t\tconst extension = ImageUtils.mimeTypeToExtension(texture.getMimeType());\n\t\t\timageDef.uri = this.imageURIGenerator.createURI(texture, extension);\n\t\t\tthis.jsonDoc.resources[imageDef.uri] = data;\n\t\t}\n\t}\n\n\t/**\n\t * Returns implicit usage type of the given accessor, related to grouping accessors into\n\t * buffer views. Usage is a superset of buffer view target, including ARRAY_BUFFER and\n\t * ELEMENT_ARRAY_BUFFER, but also usages that do not match GPU buffer view targets such as\n\t * IBMs. Additional usages are defined by extensions, like `EXT_mesh_gpu_instancing`.\n\t */\n\tpublic getAccessorUsage(accessor: Accessor): BufferViewUsage | string {\n\t\tconst cachedUsage = this._accessorUsageMap.get(accessor);\n\t\tif (cachedUsage) return cachedUsage;\n\n\t\tif (accessor.getSparse()) return BufferViewUsage.SPARSE;\n\n\t\tfor (const edge of this._doc.getGraph().listParentEdges(accessor)) {\n\t\t\tconst { usage } = edge.getAttributes() as { usage: BufferViewUsage | undefined };\n\n\t\t\tif (usage) return usage;\n\n\t\t\tif (edge.getParent().propertyType !== PropertyType.ROOT) {\n\t\t\t\tthis.logger.warn(`Missing attribute \".usage\" on edge, \"${edge.getName()}\".`);\n\t\t\t}\n\t\t}\n\n\t\t// Group accessors with no specified usage into a miscellaneous buffer view.\n\t\treturn BufferViewUsage.OTHER;\n\t}\n\n\t/**\n\t * Sets usage for the given accessor. Some accessor types must be grouped into\n\t * buffer views with like accessors. This includes the specified buffer view \"targets\", but\n\t * also implicit usage like IBMs or instanced mesh attributes. If unspecified, an accessor\n\t * will be grouped with other accessors of unspecified usage.\n\t */\n\tpublic addAccessorToUsageGroup(accessor: Accessor, usage: BufferViewUsage | string): this {\n\t\tconst prevUsage = this._accessorUsageMap.get(accessor);\n\t\tif (prevUsage && prevUsage !== usage) {\n\t\t\tthrow new Error(`Accessor with usage \"${prevUsage}\" cannot be reused as \"${usage}\".`);\n\t\t}\n\t\tthis._accessorUsageMap.set(accessor, usage);\n\t\treturn this;\n\t}\n\n\t/** Lists accessors grouped by usage. Accessors with unspecified usage are not included. */\n\tpublic listAccessorUsageGroups(): { [key: string]: Accessor[] } {\n\t\tconst result = {} as { [key: string]: Accessor[] };\n\t\tfor (const [accessor, usage] of Array.from(this._accessorUsageMap.entries())) {\n\t\t\tresult[usage] = result[usage] || [];\n\t\t\tresult[usage].push(accessor);\n\t\t}\n\t\treturn result;\n\t}\n}\n\nexport class UniqueURIGenerator<T extends Texture | Buffer> {\n\tprivate counter = {} as Record<string, number>;\n\n\tconstructor(private readonly multiple: boolean, private readonly basename: (t: T) => string) {}\n\n\tpublic createURI(object: T, extension: string): string {\n\t\tif (object.getURI()) {\n\t\t\treturn object.getURI();\n\t\t} else if (!this.multiple) {\n\t\t\treturn `${this.basename(object)}.${extension}`;\n\t\t} else {\n\t\t\tconst basename = this.basename(object);\n\t\t\tthis.counter[basename] = this.counter[basename] || 1;\n\t\t\treturn `${basename}_${this.counter[basename]++}.${extension}`;\n\t\t}\n\t}\n}\n\n/** Returns the first slot (by name) to which the texture is assigned. */\nfunction getSlot(document: Document, texture: Texture): string {\n\tconst edge = document\n\t\t.getGraph()\n\t\t.listParentEdges(texture)\n\t\t.find((edge) => edge.getParent() !== document.getRoot());\n\treturn edge ? edge.getName().replace(/texture$/i, '') : '';\n}\n", "import {\n\tComponentTypeToTypedArray,\n\tFormat,\n\tGLB_BUFFER,\n\tPropertyType,\n\tTypedArray,\n\tVERSION,\n\tVertexLayout,\n} from '../constants.js';\nimport type { Document } from '../document.js';\nimport type { Extension } from '../extension.js';\nimport type { GraphEdge } from 'property-graph';\nimport type { JSONDocument } from '../json-document.js';\nimport { Accessor, AnimationSampler, Camera, Material, Property } from '../properties/index.js';\nimport type { GLTF } from '../types/gltf.js';\nimport { BufferUtils, Logger, MathUtils } from '../utils/index.js';\nimport { WriterContext } from './writer-context.js';\n\nconst { BufferViewUsage } = WriterContext;\nconst { UNSIGNED_INT, UNSIGNED_SHORT, UNSIGNED_BYTE } = Accessor.ComponentType;\n\nexport interface WriterOptions {\n\tformat: Format;\n\tlogger?: Logger;\n\tbasename?: string;\n\tvertexLayout?: VertexLayout;\n\tdependencies?: { [key: string]: unknown };\n\textensions?: (typeof Extension)[];\n}\n\n/**\n * @internal\n * @hidden\n */\nexport class GLTFWriter {\n\tpublic static write(doc: Document, options: Required<WriterOptions>): JSONDocument {\n\t\tconst root = doc.getRoot();\n\t\tconst json = {\n\t\t\tasset: { generator: `glTF-Transform ${VERSION}`, ...root.getAsset() },\n\t\t\textras: { ...root.getExtras() },\n\t\t} as GLTF.IGLTF;\n\t\tconst jsonDoc = { json, resources: {} } as JSONDocument;\n\n\t\tconst context = new WriterContext(doc, jsonDoc, options);\n\t\tconst logger = options.logger || Logger.DEFAULT_INSTANCE;\n\n\t\t/* Extensions (1/2). */\n\n\t\t// Extensions present on the Document are not written unless they are also registered with\n\t\t// the I/O class. This ensures that setup in `extension.register()` is completed, and\n\t\t// allows a Document to be written with specific extensions disabled.\n\t\tconst extensionsRegistered = new Set(options.extensions.map((ext) => ext.EXTENSION_NAME));\n\t\tconst extensionsUsed = doc\n\t\t\t.getRoot()\n\t\t\t.listExtensionsUsed()\n\t\t\t.filter((ext) => extensionsRegistered.has(ext.extensionName));\n\t\tconst extensionsRequired = doc\n\t\t\t.getRoot()\n\t\t\t.listExtensionsRequired()\n\t\t\t.filter((ext) => extensionsRegistered.has(ext.extensionName));\n\n\t\tif (extensionsUsed.length < doc.getRoot().listExtensionsUsed().length) {\n\t\t\tlogger.warn('Some extensions were not registered for I/O, and will not be written.');\n\t\t}\n\n\t\tfor (const extension of extensionsUsed) {\n\t\t\tfor (const key of extension.writeDependencies) {\n\t\t\t\textension.install(key, options.dependencies[key]);\n\t\t\t}\n\t\t}\n\n\t\t/* Utilities. */\n\n\t\tinterface BufferViewResult {\n\t\t\tbyteLength: number;\n\t\t\tbuffers: Uint8Array[];\n\t\t}\n\n\t\t/**\n\t\t * Pack a group of accessors into a sequential buffer view. Appends accessor and buffer view\n\t\t * definitions to the root JSON lists.\n\t\t *\n\t\t * @param accessors Accessors to be included.\n\t\t * @param bufferIndex Buffer to write to.\n\t\t * @param bufferByteOffset Current offset into the buffer, accounting for other buffer views.\n\t\t * @param bufferViewTarget (Optional) target use of the buffer view.\n\t\t */\n\t\tfunction concatAccessors(\n\t\t\taccessors: Accessor[],\n\t\t\tbufferIndex: number,\n\t\t\tbufferByteOffset: number,\n\t\t\tbufferViewTarget?: number\n\t\t): BufferViewResult {\n\t\t\tconst buffers: Uint8Array[] = [];\n\t\t\tlet byteLength = 0;\n\n\t\t\t// Create accessor definitions, determining size of final buffer view.\n\t\t\tfor (const accessor of accessors) {\n\t\t\t\tconst accessorDef = context.createAccessorDef(accessor);\n\t\t\t\taccessorDef.bufferView = json.bufferViews!.length;\n\n\t\t\t\tconst accessorArray = accessor.getArray()!;\n\t\t\t\tconst data = BufferUtils.pad(BufferUtils.toView(accessorArray));\n\t\t\t\taccessorDef.byteOffset = byteLength;\n\t\t\t\tbyteLength += data.byteLength;\n\t\t\t\tbuffers.push(data);\n\n\t\t\t\tcontext.accessorIndexMap.set(accessor, json.accessors!.length);\n\t\t\t\tjson.accessors!.push(accessorDef);\n\t\t\t}\n\n\t\t\t// Create buffer view definition.\n\t\t\tconst bufferViewData = BufferUtils.concat(buffers);\n\t\t\tconst bufferViewDef: GLTF.IBufferView = {\n\t\t\t\tbuffer: bufferIndex,\n\t\t\t\tbyteOffset: bufferByteOffset,\n\t\t\t\tbyteLength: bufferViewData.byteLength,\n\t\t\t};\n\t\t\tif (bufferViewTarget) bufferViewDef.target = bufferViewTarget;\n\t\t\tjson.bufferViews!.push(bufferViewDef);\n\n\t\t\treturn { buffers, byteLength };\n\t\t}\n\n\t\t/**\n\t\t * Pack a group of accessors into an interleaved buffer view. Appends accessor and buffer\n\t\t * view definitions to the root JSON lists. Buffer view target is implicitly attribute data.\n\t\t *\n\t\t * References:\n\t\t * - [Apple  Best Practices for Working with Vertex Data](https://developer.apple.com/library/archive/documentation/3DDrawing/Conceptual/OpenGLES_ProgrammingGuide/TechniquesforWorkingwithVertexData/TechniquesforWorkingwithVertexData.html)\n\t\t * - [Khronos  Vertex Specification Best Practices](https://www.khronos.org/opengl/wiki/Vertex_Specification_Best_Practices)\n\t\t *\n\t\t * @param accessors Accessors to be included.\n\t\t * @param bufferIndex Buffer to write to.\n\t\t * @param bufferByteOffset Offset into the buffer, accounting for other buffer views.\n\t\t */\n\t\tfunction interleaveAccessors(\n\t\t\taccessors: Accessor[],\n\t\t\tbufferIndex: number,\n\t\t\tbufferByteOffset: number\n\t\t): BufferViewResult {\n\t\t\tconst vertexCount = accessors[0].getCount();\n\t\t\tlet byteStride = 0;\n\n\t\t\t// Create accessor definitions, determining size and stride of final buffer view.\n\t\t\tfor (const accessor of accessors) {\n\t\t\t\tconst accessorDef = context.createAccessorDef(accessor);\n\t\t\t\taccessorDef.bufferView = json.bufferViews!.length;\n\t\t\t\taccessorDef.byteOffset = byteStride;\n\n\t\t\t\tconst elementSize = accessor.getElementSize();\n\t\t\t\tconst componentSize = accessor.getComponentSize();\n\t\t\t\tbyteStride += BufferUtils.padNumber(elementSize * componentSize);\n\n\t\t\t\tcontext.accessorIndexMap.set(accessor, json.accessors!.length);\n\t\t\t\tjson.accessors!.push(accessorDef);\n\t\t\t}\n\n\t\t\t// Allocate interleaved buffer view.\n\t\t\tconst byteLength = vertexCount * byteStride;\n\t\t\tconst buffer = new ArrayBuffer(byteLength);\n\t\t\tconst view = new DataView(buffer);\n\n\t\t\t// Write interleaved accessor data to the buffer view.\n\t\t\tfor (let i = 0; i < vertexCount; i++) {\n\t\t\t\tlet vertexByteOffset = 0;\n\t\t\t\tfor (const accessor of accessors) {\n\t\t\t\t\tconst elementSize = accessor.getElementSize();\n\t\t\t\t\tconst componentSize = accessor.getComponentSize();\n\t\t\t\t\tconst componentType = accessor.getComponentType();\n\t\t\t\t\tconst array = accessor.getArray()!;\n\t\t\t\t\tfor (let j = 0; j < elementSize; j++) {\n\t\t\t\t\t\tconst viewByteOffset = i * byteStride + vertexByteOffset + j * componentSize;\n\t\t\t\t\t\tconst value = array[i * elementSize + j];\n\t\t\t\t\t\tswitch (componentType) {\n\t\t\t\t\t\t\tcase Accessor.ComponentType.FLOAT:\n\t\t\t\t\t\t\t\tview.setFloat32(viewByteOffset, value, true);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase Accessor.ComponentType.BYTE:\n\t\t\t\t\t\t\t\tview.setInt8(viewByteOffset, value);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase Accessor.ComponentType.SHORT:\n\t\t\t\t\t\t\t\tview.setInt16(viewByteOffset, value, true);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase Accessor.ComponentType.UNSIGNED_BYTE:\n\t\t\t\t\t\t\t\tview.setUint8(viewByteOffset, value);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase Accessor.ComponentType.UNSIGNED_SHORT:\n\t\t\t\t\t\t\t\tview.setUint16(viewByteOffset, value, true);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase Accessor.ComponentType.UNSIGNED_INT:\n\t\t\t\t\t\t\t\tview.setUint32(viewByteOffset, value, true);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tthrow new Error('Unexpected component type: ' + componentType);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tvertexByteOffset += BufferUtils.padNumber(elementSize * componentSize);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Create buffer view definition.\n\t\t\tconst bufferViewDef: GLTF.IBufferView = {\n\t\t\t\tbuffer: bufferIndex,\n\t\t\t\tbyteOffset: bufferByteOffset,\n\t\t\t\tbyteLength: byteLength,\n\t\t\t\tbyteStride: byteStride,\n\t\t\t\ttarget: WriterContext.BufferViewTarget.ARRAY_BUFFER,\n\t\t\t};\n\t\t\tjson.bufferViews!.push(bufferViewDef);\n\n\t\t\treturn { byteLength, buffers: [new Uint8Array(buffer)] };\n\t\t}\n\n\t\t/**\n\t\t * Pack a group of sparse accessors. Appends accessor and buffer view\n\t\t * definitions to the root JSON lists.\n\t\t *\n\t\t * @param accessors Accessors to be included.\n\t\t * @param bufferIndex Buffer to write to.\n\t\t * @param bufferByteOffset Current offset into the buffer, accounting for other buffer views.\n\t\t */\n\t\tfunction concatSparseAccessors(\n\t\t\taccessors: Accessor[],\n\t\t\tbufferIndex: number,\n\t\t\tbufferByteOffset: number\n\t\t): BufferViewResult {\n\t\t\tconst buffers: Uint8Array[] = [];\n\t\t\tlet byteLength = 0;\n\n\t\t\tinterface SparseData {\n\t\t\t\taccessorDef: GLTF.IAccessor;\n\t\t\t\tcount: number;\n\t\t\t\tindices?: number[];\n\t\t\t\tvalues?: TypedArray;\n\t\t\t\tindicesByteOffset?: number;\n\t\t\t\tvaluesByteOffset?: number;\n\t\t\t}\n\t\t\tconst sparseData = new Map<Accessor, SparseData>();\n\t\t\tlet maxIndex = -Infinity;\n\n\t\t\t// (1) Write accessor definitions, gathering indices and values.\n\n\t\t\tfor (const accessor of accessors) {\n\t\t\t\tconst accessorDef = context.createAccessorDef(accessor);\n\t\t\t\tjson.accessors!.push(accessorDef);\n\t\t\t\tcontext.accessorIndexMap.set(accessor, json.accessors!.length - 1);\n\n\t\t\t\tconst indices = [];\n\t\t\t\tconst values = [];\n\n\t\t\t\tconst el = [] as number[];\n\t\t\t\tconst base = new Array(accessor.getElementSize()).fill(0);\n\n\t\t\t\tfor (let i = 0, il = accessor.getCount(); i < il; i++) {\n\t\t\t\t\taccessor.getElement(i, el);\n\t\t\t\t\tif (MathUtils.eq(el, base, 0)) continue;\n\n\t\t\t\t\tmaxIndex = Math.max(i, maxIndex);\n\t\t\t\t\tindices.push(i);\n\t\t\t\t\tfor (let j = 0; j < el.length; j++) values.push(el[j]);\n\t\t\t\t}\n\n\t\t\t\tconst count = indices.length;\n\t\t\t\tconst data: SparseData = { accessorDef, count };\n\t\t\t\tsparseData.set(accessor, data);\n\n\t\t\t\tif (count === 0) continue;\n\n\t\t\t\tif (count > accessor.getCount() / 3) {\n\t\t\t\t\t// Too late to write non-sparse values in the proper buffer views here.\n\t\t\t\t\tconst pct = ((100 * indices.length) / accessor.getCount()).toFixed(1);\n\t\t\t\t\tlogger.warn(`Sparse accessor with many non-zero elements (${pct}%) may increase file size.`);\n\t\t\t\t}\n\n\t\t\t\tconst ValueArray = ComponentTypeToTypedArray[accessor.getComponentType()];\n\t\t\t\tdata.indices = indices;\n\t\t\t\tdata.values = new ValueArray(values);\n\t\t\t}\n\n\t\t\t// (2) Early exit if all sparse accessors are just zero-filled arrays.\n\n\t\t\tif (!Number.isFinite(maxIndex)) {\n\t\t\t\treturn { buffers, byteLength };\n\t\t\t}\n\n\t\t\t// (3) Write index buffer view.\n\n\t\t\tconst IndexArray = maxIndex < 255 ? Uint8Array : maxIndex < 65535 ? Uint16Array : Uint32Array;\n\t\t\tconst IndexComponentType =\n\t\t\t\tmaxIndex < 255 ? UNSIGNED_BYTE : maxIndex < 65535 ? UNSIGNED_SHORT : UNSIGNED_INT;\n\n\t\t\tconst indicesBufferViewDef: GLTF.IBufferView = {\n\t\t\t\tbuffer: bufferIndex,\n\t\t\t\tbyteOffset: bufferByteOffset + byteLength,\n\t\t\t\tbyteLength: 0,\n\t\t\t};\n\t\t\tfor (const accessor of accessors) {\n\t\t\t\tconst data = sparseData.get(accessor)!;\n\t\t\t\tif (data.count === 0) continue;\n\n\t\t\t\tdata.indicesByteOffset = indicesBufferViewDef.byteLength;\n\n\t\t\t\tconst buffer = BufferUtils.pad(BufferUtils.toView(new IndexArray(data.indices!)));\n\t\t\t\tbuffers.push(buffer);\n\t\t\t\tbyteLength += buffer.byteLength;\n\t\t\t\tindicesBufferViewDef.byteLength += buffer.byteLength;\n\t\t\t}\n\t\t\tjson.bufferViews!.push(indicesBufferViewDef);\n\t\t\tconst indicesBufferViewIndex = json.bufferViews!.length - 1;\n\n\t\t\t// (4) Write value buffer view.\n\n\t\t\tconst valuesBufferViewDef: GLTF.IBufferView = {\n\t\t\t\tbuffer: bufferIndex,\n\t\t\t\tbyteOffset: bufferByteOffset + byteLength,\n\t\t\t\tbyteLength: 0,\n\t\t\t};\n\t\t\tfor (const accessor of accessors) {\n\t\t\t\tconst data = sparseData.get(accessor)!;\n\t\t\t\tif (data.count === 0) continue;\n\n\t\t\t\tdata.valuesByteOffset = valuesBufferViewDef.byteLength;\n\n\t\t\t\tconst buffer = BufferUtils.pad(BufferUtils.toView(data.values!));\n\t\t\t\tbuffers.push(buffer);\n\t\t\t\tbyteLength += buffer.byteLength;\n\t\t\t\tvaluesBufferViewDef.byteLength += buffer.byteLength;\n\t\t\t}\n\t\t\tjson.bufferViews!.push(valuesBufferViewDef);\n\t\t\tconst valuesBufferViewIndex = json.bufferViews!.length - 1;\n\n\t\t\t// (5) Write accessor sparse entries.\n\n\t\t\tfor (const accessor of accessors) {\n\t\t\t\tconst data = sparseData.get(accessor) as Required<SparseData>;\n\t\t\t\tif (data.count === 0) continue;\n\n\t\t\t\tdata.accessorDef.sparse = {\n\t\t\t\t\tcount: data.count,\n\t\t\t\t\tindices: {\n\t\t\t\t\t\tbufferView: indicesBufferViewIndex,\n\t\t\t\t\t\tbyteOffset: data.indicesByteOffset,\n\t\t\t\t\t\tcomponentType: IndexComponentType,\n\t\t\t\t\t},\n\t\t\t\t\tvalues: {\n\t\t\t\t\t\tbufferView: valuesBufferViewIndex,\n\t\t\t\t\t\tbyteOffset: data.valuesByteOffset,\n\t\t\t\t\t},\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn { buffers, byteLength };\n\t\t}\n\n\t\t/* Data use pre-processing. */\n\n\t\tconst accessorRefs = new Map<Accessor, GraphEdge<Property, Accessor>[]>();\n\n\t\t// Gather all accessors, creating a map to look up their uses.\n\t\tfor (const ref of doc.getGraph().listEdges()) {\n\t\t\tif (ref.getParent() === root) continue;\n\n\t\t\tconst child = ref.getChild();\n\n\t\t\tif (child instanceof Accessor) {\n\t\t\t\tconst uses = accessorRefs.get(child) || [];\n\t\t\t\tuses.push(ref as GraphEdge<Property, Accessor>);\n\t\t\t\taccessorRefs.set(child, uses);\n\t\t\t}\n\t\t}\n\n\t\tjson.accessors = [];\n\t\tjson.bufferViews = [];\n\n\t\t/* Textures. */\n\n\t\t// glTF Transform's \"Texture\" properties correspond 1:1 with glTF \"Image\" properties, and\n\t\t// with image files. The glTF file may contain more one texture per image, where images\n\t\t// are reused with different sampler properties.\n\t\tjson.samplers = [];\n\t\tjson.textures = [];\n\t\tjson.images = root.listTextures().map((texture, textureIndex) => {\n\t\t\tconst imageDef = context.createPropertyDef(texture) as GLTF.IImage;\n\n\t\t\tif (texture.getMimeType()) {\n\t\t\t\timageDef.mimeType = texture.getMimeType();\n\t\t\t}\n\n\t\t\tconst image = texture.getImage();\n\t\t\tif (image) {\n\t\t\t\tcontext.createImageData(imageDef, image, texture);\n\t\t\t}\n\n\t\t\tcontext.imageIndexMap.set(texture, textureIndex);\n\t\t\treturn imageDef;\n\t\t});\n\n\t\t/* Accessors. */\n\n\t\textensionsUsed\n\t\t\t.filter((extension) => extension.prewriteTypes.includes(PropertyType.ACCESSOR))\n\t\t\t.forEach((extension) => extension.prewrite(context, PropertyType.ACCESSOR));\n\t\troot.listAccessors().forEach((accessor) => {\n\t\t\t// Attributes are grouped and interleaved in one buffer view per mesh primitive.\n\t\t\t// Indices for all primitives are grouped into a single buffer view. IBMs are grouped\n\t\t\t// into a single buffer view. Other usage (if specified by extensions) also goes into\n\t\t\t// a dedicated buffer view. Everything else goes into a miscellaneous buffer view.\n\n\t\t\t// Certain accessor usage should group data into buffer views by the accessor parent.\n\t\t\t// The `accessorParents` map uses the first parent of each accessor for this purpose.\n\t\t\tconst groupByParent = context.accessorUsageGroupedByParent;\n\t\t\tconst accessorParents = context.accessorParents;\n\n\t\t\t// Skip if already written by an extension.\n\t\t\tif (context.accessorIndexMap.has(accessor)) return;\n\n\t\t\t// Assign usage for core accessor usage types (explicit targets and implicit usage).\n\t\t\tconst accessorEdges = accessorRefs.get(accessor) || [];\n\t\t\tconst usage = context.getAccessorUsage(accessor);\n\t\t\tcontext.addAccessorToUsageGroup(accessor, usage);\n\n\t\t\t// For accessor usage that requires grouping by parent (vertex and instance\n\t\t\t// attributes) organize buffer views accordingly.\n\t\t\tif (groupByParent.has(usage)) {\n\t\t\t\tconst parent = accessorEdges[0].getParent();\n\t\t\t\tconst parentAccessors = accessorParents.get(parent) || new Set<Accessor>();\n\t\t\t\tparentAccessors.add(accessor);\n\t\t\t\taccessorParents.set(parent, parentAccessors);\n\t\t\t}\n\t\t});\n\n\t\t/* Buffers, buffer views. */\n\n\t\textensionsUsed\n\t\t\t.filter((extension) => extension.prewriteTypes.includes(PropertyType.BUFFER))\n\t\t\t.forEach((extension) => extension.prewrite(context, PropertyType.BUFFER));\n\n\t\tconst hasBinaryResources =\n\t\t\troot.listAccessors().length > 0 || root.listTextures().length > 0 || context.otherBufferViews.size > 0;\n\t\tif (hasBinaryResources && root.listBuffers().length === 0) {\n\t\t\tthrow new Error('Buffer required for Document resources, but none was found.');\n\t\t}\n\n\t\tjson.buffers = [];\n\t\troot.listBuffers().forEach((buffer, index) => {\n\t\t\tconst bufferDef = context.createPropertyDef(buffer) as GLTF.IBuffer;\n\t\t\tconst groupByParent = context.accessorUsageGroupedByParent;\n\t\t\tconst accessorParents = context.accessorParents;\n\n\t\t\tconst bufferAccessors = buffer\n\t\t\t\t.listParents()\n\t\t\t\t.filter((property) => property instanceof Accessor) as Accessor[];\n\t\t\tconst bufferAccessorsSet = new Set(bufferAccessors);\n\n\t\t\t// Write accessor groups to buffer views.\n\n\t\t\tconst buffers: Uint8Array[] = [];\n\t\t\tconst bufferIndex = json.buffers!.length;\n\t\t\tlet bufferByteLength = 0;\n\n\t\t\tconst usageGroups = context.listAccessorUsageGroups();\n\n\t\t\tfor (const usage in usageGroups) {\n\t\t\t\tif (groupByParent.has(usage)) {\n\t\t\t\t\t// Accessors grouped by (first) parent, including vertex and instance attributes.\n\t\t\t\t\tfor (const parentAccessors of Array.from(accessorParents.values())) {\n\t\t\t\t\t\tconst accessors = Array.from(parentAccessors)\n\t\t\t\t\t\t\t.filter((a) => bufferAccessorsSet.has(a))\n\t\t\t\t\t\t\t.filter((a) => context.getAccessorUsage(a) === usage);\n\t\t\t\t\t\tif (!accessors.length) continue;\n\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tusage !== BufferViewUsage.ARRAY_BUFFER ||\n\t\t\t\t\t\t\toptions.vertexLayout === VertexLayout.INTERLEAVED\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t// Case 1: Non-vertex data OR interleaved vertex data.\n\n\t\t\t\t\t\t\t// Instanced data is not interleaved, see:\n\t\t\t\t\t\t\t// https://github.com/KhronosGroup/glTF/pull/1888\n\t\t\t\t\t\t\tconst result =\n\t\t\t\t\t\t\t\tusage === BufferViewUsage.ARRAY_BUFFER\n\t\t\t\t\t\t\t\t\t? interleaveAccessors(accessors, bufferIndex, bufferByteLength)\n\t\t\t\t\t\t\t\t\t: concatAccessors(accessors, bufferIndex, bufferByteLength);\n\t\t\t\t\t\t\tbufferByteLength += result.byteLength;\n\t\t\t\t\t\t\tbuffers.push(...result.buffers);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Case 2: Non-interleaved vertex data.\n\n\t\t\t\t\t\t\tfor (const accessor of accessors) {\n\t\t\t\t\t\t\t\t// We 'interleave' a single accessor because the method pads to\n\t\t\t\t\t\t\t\t// 4-byte boundaries, which concatAccessors() does not.\n\t\t\t\t\t\t\t\tconst result = interleaveAccessors([accessor], bufferIndex, bufferByteLength);\n\t\t\t\t\t\t\t\tbufferByteLength += result.byteLength;\n\t\t\t\t\t\t\t\tbuffers.push(...result.buffers);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Accessors concatenated end-to-end, including indices, IBMs, and other data.\n\t\t\t\t\tconst accessors = usageGroups[usage].filter((a) => bufferAccessorsSet.has(a));\n\t\t\t\t\tif (!accessors.length) continue;\n\n\t\t\t\t\tconst target =\n\t\t\t\t\t\tusage === BufferViewUsage.ELEMENT_ARRAY_BUFFER\n\t\t\t\t\t\t\t? WriterContext.BufferViewTarget.ELEMENT_ARRAY_BUFFER\n\t\t\t\t\t\t\t: undefined;\n\t\t\t\t\tconst result =\n\t\t\t\t\t\tusage === BufferViewUsage.SPARSE\n\t\t\t\t\t\t\t? concatSparseAccessors(accessors, bufferIndex, bufferByteLength)\n\t\t\t\t\t\t\t: concatAccessors(accessors, bufferIndex, bufferByteLength, target);\n\t\t\t\t\tbufferByteLength += result.byteLength;\n\t\t\t\t\tbuffers.push(...result.buffers);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// We only support embedded images in GLB, where the embedded buffer must be the first.\n\t\t\t// Additional buffers are currently left empty (see EXT_meshopt_compression fallback).\n\t\t\tif (context.imageBufferViews.length && index === 0) {\n\t\t\t\tfor (let i = 0; i < context.imageBufferViews.length; i++) {\n\t\t\t\t\tjson.bufferViews![json.images![i].bufferView!].byteOffset = bufferByteLength;\n\t\t\t\t\tbufferByteLength += context.imageBufferViews[i].byteLength;\n\t\t\t\t\tbuffers.push(context.imageBufferViews[i]);\n\n\t\t\t\t\tif (bufferByteLength % 8) {\n\t\t\t\t\t\t// See: https://github.com/KhronosGroup/glTF/issues/1935\n\t\t\t\t\t\tconst imagePadding = 8 - (bufferByteLength % 8);\n\t\t\t\t\t\tbufferByteLength += imagePadding;\n\t\t\t\t\t\tbuffers.push(new Uint8Array(imagePadding));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (context.otherBufferViews.has(buffer)) {\n\t\t\t\tfor (const data of context.otherBufferViews.get(buffer)!) {\n\t\t\t\t\tjson.bufferViews!.push({\n\t\t\t\t\t\tbuffer: bufferIndex,\n\t\t\t\t\t\tbyteOffset: bufferByteLength,\n\t\t\t\t\t\tbyteLength: data.byteLength,\n\t\t\t\t\t});\n\t\t\t\t\tcontext.otherBufferViewsIndexMap.set(data, json.bufferViews!.length - 1);\n\t\t\t\t\tbufferByteLength += data.byteLength;\n\t\t\t\t\tbuffers.push(data);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (bufferByteLength) {\n\t\t\t\t// Assign buffer URI.\n\t\t\t\tlet uri: string;\n\t\t\t\tif (options.format === Format.GLB) {\n\t\t\t\t\turi = GLB_BUFFER;\n\t\t\t\t} else {\n\t\t\t\t\turi = context.bufferURIGenerator.createURI(buffer, 'bin');\n\t\t\t\t\tbufferDef.uri = uri;\n\t\t\t\t}\n\n\t\t\t\t// Write buffer views to buffer.\n\t\t\t\tbufferDef.byteLength = bufferByteLength;\n\t\t\t\tjsonDoc.resources[uri] = BufferUtils.concat(buffers);\n\t\t\t}\n\n\t\t\tjson.buffers!.push(bufferDef);\n\t\t\tcontext.bufferIndexMap.set(buffer, index);\n\t\t});\n\n\t\tif (root.listAccessors().find((a) => !a.getBuffer())) {\n\t\t\tlogger.warn('Skipped writing one or more Accessors: no Buffer assigned.');\n\t\t}\n\n\t\t/* Materials. */\n\n\t\tjson.materials = root.listMaterials().map((material, index) => {\n\t\t\tconst materialDef = context.createPropertyDef(material) as GLTF.IMaterial;\n\n\t\t\t// Program state & blending.\n\n\t\t\tif (material.getAlphaMode() !== Material.AlphaMode.OPAQUE) {\n\t\t\t\tmaterialDef.alphaMode = material.getAlphaMode();\n\t\t\t}\n\t\t\tif (material.getAlphaMode() === Material.AlphaMode.MASK) {\n\t\t\t\tmaterialDef.alphaCutoff = material.getAlphaCutoff();\n\t\t\t}\n\t\t\tif (material.getDoubleSided()) materialDef.doubleSided = true;\n\n\t\t\t// Factors.\n\n\t\t\tmaterialDef.pbrMetallicRoughness = {};\n\t\t\tif (!MathUtils.eq(material.getBaseColorFactor(), [1, 1, 1, 1])) {\n\t\t\t\tmaterialDef.pbrMetallicRoughness.baseColorFactor = material.getBaseColorFactor();\n\t\t\t}\n\t\t\tif (!MathUtils.eq(material.getEmissiveFactor(), [0, 0, 0])) {\n\t\t\t\tmaterialDef.emissiveFactor = material.getEmissiveFactor();\n\t\t\t}\n\t\t\tif (material.getRoughnessFactor() !== 1) {\n\t\t\t\tmaterialDef.pbrMetallicRoughness.roughnessFactor = material.getRoughnessFactor();\n\t\t\t}\n\t\t\tif (material.getMetallicFactor() !== 1) {\n\t\t\t\tmaterialDef.pbrMetallicRoughness.metallicFactor = material.getMetallicFactor();\n\t\t\t}\n\n\t\t\t// Textures.\n\n\t\t\tif (material.getBaseColorTexture()) {\n\t\t\t\tconst texture = material.getBaseColorTexture()!;\n\t\t\t\tconst textureInfo = material.getBaseColorTextureInfo()!;\n\t\t\t\tmaterialDef.pbrMetallicRoughness.baseColorTexture = context.createTextureInfoDef(texture, textureInfo);\n\t\t\t}\n\n\t\t\tif (material.getEmissiveTexture()) {\n\t\t\t\tconst texture = material.getEmissiveTexture()!;\n\t\t\t\tconst textureInfo = material.getEmissiveTextureInfo()!;\n\t\t\t\tmaterialDef.emissiveTexture = context.createTextureInfoDef(texture, textureInfo);\n\t\t\t}\n\n\t\t\tif (material.getNormalTexture()) {\n\t\t\t\tconst texture = material.getNormalTexture()!;\n\t\t\t\tconst textureInfo = material.getNormalTextureInfo()!;\n\t\t\t\tconst textureInfoDef = context.createTextureInfoDef(\n\t\t\t\t\ttexture,\n\t\t\t\t\ttextureInfo\n\t\t\t\t) as GLTF.IMaterialNormalTextureInfo;\n\t\t\t\tif (material.getNormalScale() !== 1) {\n\t\t\t\t\ttextureInfoDef.scale = material.getNormalScale();\n\t\t\t\t}\n\t\t\t\tmaterialDef.normalTexture = textureInfoDef;\n\t\t\t}\n\n\t\t\tif (material.getOcclusionTexture()) {\n\t\t\t\tconst texture = material.getOcclusionTexture()!;\n\t\t\t\tconst textureInfo = material.getOcclusionTextureInfo()!;\n\t\t\t\tconst textureInfoDef = context.createTextureInfoDef(\n\t\t\t\t\ttexture,\n\t\t\t\t\ttextureInfo\n\t\t\t\t) as GLTF.IMaterialOcclusionTextureInfo;\n\t\t\t\tif (material.getOcclusionStrength() !== 1) {\n\t\t\t\t\ttextureInfoDef.strength = material.getOcclusionStrength();\n\t\t\t\t}\n\t\t\t\tmaterialDef.occlusionTexture = textureInfoDef;\n\t\t\t}\n\n\t\t\tif (material.getMetallicRoughnessTexture()) {\n\t\t\t\tconst texture = material.getMetallicRoughnessTexture()!;\n\t\t\t\tconst textureInfo = material.getMetallicRoughnessTextureInfo()!;\n\t\t\t\tmaterialDef.pbrMetallicRoughness.metallicRoughnessTexture = context.createTextureInfoDef(\n\t\t\t\t\ttexture,\n\t\t\t\t\ttextureInfo\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tcontext.materialIndexMap.set(material, index);\n\t\t\treturn materialDef;\n\t\t});\n\n\t\t/* Meshes. */\n\n\t\tjson.meshes = root.listMeshes().map((mesh, index) => {\n\t\t\tconst meshDef = context.createPropertyDef(mesh) as GLTF.IMesh;\n\n\t\t\tlet targetNames: string[] | null = null;\n\n\t\t\tmeshDef.primitives = mesh.listPrimitives().map((primitive) => {\n\t\t\t\tconst primitiveDef: GLTF.IMeshPrimitive = { attributes: {} };\n\n\t\t\t\tprimitiveDef.mode = primitive.getMode();\n\n\t\t\t\tconst material = primitive.getMaterial();\n\t\t\t\tif (material) {\n\t\t\t\t\tprimitiveDef.material = context.materialIndexMap.get(material);\n\t\t\t\t}\n\n\t\t\t\tif (Object.keys(primitive.getExtras()).length) {\n\t\t\t\t\tprimitiveDef.extras = primitive.getExtras();\n\t\t\t\t}\n\n\t\t\t\tconst indices = primitive.getIndices();\n\t\t\t\tif (indices) {\n\t\t\t\t\tprimitiveDef.indices = context.accessorIndexMap.get(indices);\n\t\t\t\t}\n\n\t\t\t\tfor (const semantic of primitive.listSemantics()) {\n\t\t\t\t\tprimitiveDef.attributes[semantic] = context.accessorIndexMap.get(\n\t\t\t\t\t\tprimitive.getAttribute(semantic)!\n\t\t\t\t\t)!;\n\t\t\t\t}\n\n\t\t\t\tfor (const target of primitive.listTargets()) {\n\t\t\t\t\tconst targetDef = {} as { [name: string]: number };\n\n\t\t\t\t\tfor (const semantic of target.listSemantics()) {\n\t\t\t\t\t\ttargetDef[semantic] = context.accessorIndexMap.get(target.getAttribute(semantic)!)!;\n\t\t\t\t\t}\n\n\t\t\t\t\tprimitiveDef.targets = primitiveDef.targets || [];\n\t\t\t\t\tprimitiveDef.targets.push(targetDef);\n\t\t\t\t}\n\n\t\t\t\tif (primitive.listTargets().length && !targetNames) {\n\t\t\t\t\ttargetNames = primitive.listTargets().map((target) => target.getName());\n\t\t\t\t}\n\n\t\t\t\treturn primitiveDef;\n\t\t\t});\n\n\t\t\tif (mesh.getWeights().length) {\n\t\t\t\tmeshDef.weights = mesh.getWeights();\n\t\t\t}\n\n\t\t\tif (targetNames) {\n\t\t\t\tmeshDef.extras = meshDef.extras || {};\n\t\t\t\tmeshDef.extras['targetNames'] = targetNames;\n\t\t\t}\n\n\t\t\tcontext.meshIndexMap.set(mesh, index);\n\t\t\treturn meshDef;\n\t\t});\n\n\t\t/** Cameras. */\n\n\t\tjson.cameras = root.listCameras().map((camera, index) => {\n\t\t\tconst cameraDef = context.createPropertyDef(camera) as GLTF.ICamera;\n\t\t\tcameraDef.type = camera.getType();\n\t\t\tif (cameraDef.type === Camera.Type.PERSPECTIVE) {\n\t\t\t\tcameraDef.perspective = {\n\t\t\t\t\tznear: camera.getZNear(),\n\t\t\t\t\tzfar: camera.getZFar(),\n\t\t\t\t\tyfov: camera.getYFov(),\n\t\t\t\t};\n\t\t\t\tconst aspectRatio = camera.getAspectRatio();\n\t\t\t\tif (aspectRatio !== null) {\n\t\t\t\t\tcameraDef.perspective.aspectRatio = aspectRatio;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcameraDef.orthographic = {\n\t\t\t\t\tznear: camera.getZNear(),\n\t\t\t\t\tzfar: camera.getZFar(),\n\t\t\t\t\txmag: camera.getXMag(),\n\t\t\t\t\tymag: camera.getYMag(),\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tcontext.cameraIndexMap.set(camera, index);\n\t\t\treturn cameraDef;\n\t\t});\n\n\t\t/* Nodes. */\n\n\t\tjson.nodes = root.listNodes().map((node, index) => {\n\t\t\tconst nodeDef = context.createPropertyDef(node) as GLTF.INode;\n\n\t\t\tif (!MathUtils.eq(node.getTranslation(), [0, 0, 0])) {\n\t\t\t\tnodeDef.translation = node.getTranslation();\n\t\t\t}\n\n\t\t\tif (!MathUtils.eq(node.getRotation(), [0, 0, 0, 1])) {\n\t\t\t\tnodeDef.rotation = node.getRotation();\n\t\t\t}\n\n\t\t\tif (!MathUtils.eq(node.getScale(), [1, 1, 1])) {\n\t\t\t\tnodeDef.scale = node.getScale();\n\t\t\t}\n\n\t\t\tif (node.getWeights().length) {\n\t\t\t\tnodeDef.weights = node.getWeights();\n\t\t\t}\n\n\t\t\t// Attachments (mesh, camera, skin) defined later in writing process.\n\n\t\t\tcontext.nodeIndexMap.set(node, index);\n\t\t\treturn nodeDef;\n\t\t});\n\n\t\t/** Skins. */\n\n\t\tjson.skins = root.listSkins().map((skin, index) => {\n\t\t\tconst skinDef = context.createPropertyDef(skin) as GLTF.ISkin;\n\n\t\t\tconst inverseBindMatrices = skin.getInverseBindMatrices();\n\t\t\tif (inverseBindMatrices) {\n\t\t\t\tskinDef.inverseBindMatrices = context.accessorIndexMap.get(inverseBindMatrices);\n\t\t\t}\n\n\t\t\tconst skeleton = skin.getSkeleton();\n\t\t\tif (skeleton) {\n\t\t\t\tskinDef.skeleton = context.nodeIndexMap.get(skeleton);\n\t\t\t}\n\n\t\t\tskinDef.joints = skin.listJoints().map((joint) => context.nodeIndexMap.get(joint)!);\n\n\t\t\tcontext.skinIndexMap.set(skin, index);\n\t\t\treturn skinDef;\n\t\t});\n\n\t\t/** Node attachments. */\n\n\t\troot.listNodes().forEach((node, index) => {\n\t\t\tconst nodeDef = json.nodes![index];\n\n\t\t\tconst mesh = node.getMesh();\n\t\t\tif (mesh) {\n\t\t\t\tnodeDef.mesh = context.meshIndexMap.get(mesh);\n\t\t\t}\n\n\t\t\tconst camera = node.getCamera();\n\t\t\tif (camera) {\n\t\t\t\tnodeDef.camera = context.cameraIndexMap.get(camera);\n\t\t\t}\n\n\t\t\tconst skin = node.getSkin();\n\t\t\tif (skin) {\n\t\t\t\tnodeDef.skin = context.skinIndexMap.get(skin);\n\t\t\t}\n\n\t\t\tif (node.listChildren().length > 0) {\n\t\t\t\tnodeDef.children = node.listChildren().map((node) => context.nodeIndexMap.get(node)!);\n\t\t\t}\n\t\t});\n\n\t\t/** Animations. */\n\n\t\tjson.animations = root.listAnimations().map((animation, index) => {\n\t\t\tconst animationDef = context.createPropertyDef(animation) as GLTF.IAnimation;\n\n\t\t\tconst samplerIndexMap: Map<AnimationSampler, number> = new Map();\n\n\t\t\tanimationDef.samplers = animation.listSamplers().map((sampler, samplerIndex) => {\n\t\t\t\tconst samplerDef = context.createPropertyDef(sampler) as GLTF.IAnimationSampler;\n\t\t\t\tsamplerDef.input = context.accessorIndexMap.get(sampler.getInput()!)!;\n\t\t\t\tsamplerDef.output = context.accessorIndexMap.get(sampler.getOutput()!)!;\n\t\t\t\tsamplerDef.interpolation = sampler.getInterpolation();\n\t\t\t\tsamplerIndexMap.set(sampler, samplerIndex);\n\t\t\t\treturn samplerDef;\n\t\t\t});\n\n\t\t\tanimationDef.channels = animation.listChannels().map((channel) => {\n\t\t\t\tconst channelDef = context.createPropertyDef(channel) as GLTF.IAnimationChannel;\n\t\t\t\tchannelDef.sampler = samplerIndexMap.get(channel.getSampler()!)!;\n\t\t\t\tchannelDef.target = {\n\t\t\t\t\tnode: context.nodeIndexMap.get(channel.getTargetNode()!)!,\n\t\t\t\t\tpath: channel.getTargetPath()!,\n\t\t\t\t};\n\t\t\t\treturn channelDef;\n\t\t\t});\n\n\t\t\tcontext.animationIndexMap.set(animation, index);\n\t\t\treturn animationDef;\n\t\t});\n\n\t\t/* Scenes. */\n\n\t\tjson.scenes = root.listScenes().map((scene, index) => {\n\t\t\tconst sceneDef = context.createPropertyDef(scene) as GLTF.IScene;\n\t\t\tsceneDef.nodes = scene.listChildren().map((node) => context.nodeIndexMap.get(node)!);\n\t\t\tcontext.sceneIndexMap.set(scene, index);\n\t\t\treturn sceneDef;\n\t\t});\n\n\t\tconst defaultScene = root.getDefaultScene();\n\t\tif (defaultScene) {\n\t\t\tjson.scene = root.listScenes().indexOf(defaultScene);\n\t\t}\n\n\t\t/* Extensions (2/2). */\n\n\t\tjson.extensionsUsed = extensionsUsed.map((ext) => ext.extensionName);\n\t\tjson.extensionsRequired = extensionsRequired.map((ext) => ext.extensionName);\n\t\textensionsUsed.forEach((extension) => extension.write(context));\n\n\t\t//\n\n\t\tclean(json as unknown as Record<string, unknown>);\n\n\t\treturn jsonDoc;\n\t}\n}\n\n/**\n * Removes empty and null values from an object.\n * @param object\n * @internal\n */\nfunction clean(object: Record<string, unknown>): void {\n\tconst unused: string[] = [];\n\n\tfor (const key in object) {\n\t\tconst value = object[key];\n\t\tif (Array.isArray(value) && value.length === 0) {\n\t\t\tunused.push(key);\n\t\t} else if (value === null || value === '') {\n\t\t\tunused.push(key);\n\t\t} else if (value && typeof value === 'object' && Object.keys(value).length === 0) {\n\t\t\tunused.push(key);\n\t\t}\n\t}\n\n\tfor (const key of unused) {\n\t\tdelete object[key];\n\t}\n}\n", "import { Format, GLB_BUFFER, VertexLayout } from '../constants.js';\nimport type { Document } from '../document.js';\nimport type { Extension } from '../extension.js';\nimport type { JSONDocument } from '../json-document.js';\nimport type { GLTF } from '../types/gltf.js';\nimport { BufferUtils, FileUtils, ILogger, Logger, uuid } from '../utils/index.js';\nimport { GLTFReader } from './reader.js';\nimport { GLTFWriter, WriterOptions } from './writer.js';\n\nenum ChunkType {\n\tJSON = 0x4e4f534a,\n\tBIN = 0x004e4942,\n}\n\ntype PublicWriterOptions = Partial<Pick<WriterOptions, 'format' | 'basename'>>;\n\n/**\n * *Abstract I/O service.*\n *\n * The most common use of the I/O service is to read/write a {@link Document} with a given path.\n * Methods are also available for converting in-memory representations of raw glTF files, both\n * binary (*Uint8Array*) and JSON ({@link JSONDocument}).\n *\n * For platform-specific implementations, see {@link NodeIO}, {@link WebIO}, and {@link DenoIO}.\n *\n * @category I/O\n */\nexport abstract class PlatformIO {\n\tprotected _logger: ILogger = Logger.DEFAULT_INSTANCE;\n\tprivate _extensions = new Set<typeof Extension>();\n\tprivate _dependencies: { [key: string]: unknown } = {};\n\tprivate _vertexLayout = VertexLayout.INTERLEAVED;\n\n\t/** @hidden */\n\tpublic lastReadBytes = 0;\n\n\t/** @hidden */\n\tpublic lastWriteBytes = 0;\n\n\t/** Sets the {@link Logger} used by this I/O instance. Defaults to Logger.DEFAULT_INSTANCE. */\n\tpublic setLogger(logger: ILogger): this {\n\t\tthis._logger = logger;\n\t\treturn this;\n\t}\n\n\t/** Registers extensions, enabling I/O class to read and write glTF assets requiring them. */\n\tpublic registerExtensions(extensions: (typeof Extension)[]): this {\n\t\tfor (const extension of extensions) {\n\t\t\tthis._extensions.add(extension);\n\t\t\textension.register();\n\t\t}\n\t\treturn this;\n\t}\n\n\t/** Registers dependencies used (e.g. by extensions) in the I/O process. */\n\tpublic registerDependencies(dependencies: { [key: string]: unknown }): this {\n\t\tObject.assign(this._dependencies, dependencies);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sets the vertex layout method used by this I/O instance. Defaults to\n\t * VertexLayout.INTERLEAVED.\n\t */\n\tpublic setVertexLayout(layout: VertexLayout): this {\n\t\tthis._vertexLayout = layout;\n\t\treturn this;\n\t}\n\n\t/**********************************************************************************************\n\t * Abstract.\n\t */\n\n\tprotected abstract readURI(uri: string, type: 'view'): Promise<Uint8Array>;\n\tprotected abstract readURI(uri: string, type: 'text'): Promise<string>;\n\tprotected abstract readURI(uri: string, type: 'view' | 'text'): Promise<Uint8Array | string>;\n\n\tprotected abstract resolve(base: string, path: string): string;\n\tprotected abstract dirname(uri: string): string;\n\n\t/**********************************************************************************************\n\t * Public Read API.\n\t */\n\n\t/** Reads a {@link Document} from the given URI. */\n\tpublic async read(uri: string): Promise<Document> {\n\t\treturn await this.readJSON(await this.readAsJSON(uri));\n\t}\n\n\t/** Loads a URI and returns a {@link JSONDocument} struct, without parsing. */\n\tpublic async readAsJSON(uri: string): Promise<JSONDocument> {\n\t\tconst view = await this.readURI(uri, 'view');\n\t\tthis.lastReadBytes = view.byteLength;\n\t\tconst jsonDoc = isGLB(view)\n\t\t\t? this._binaryToJSON(view)\n\t\t\t: { json: JSON.parse(BufferUtils.decodeText(view)), resources: {} };\n\t\t// Read external resources first, before Data URIs are replaced.\n\t\tawait this._readResourcesExternal(jsonDoc, this.dirname(uri));\n\t\tthis._readResourcesInternal(jsonDoc);\n\t\treturn jsonDoc;\n\t}\n\n\t/** Converts glTF-formatted JSON and a resource map to a {@link Document}. */\n\tpublic async readJSON(jsonDoc: JSONDocument): Promise<Document> {\n\t\tjsonDoc = this._copyJSON(jsonDoc);\n\t\tthis._readResourcesInternal(jsonDoc);\n\t\treturn GLTFReader.read(jsonDoc, {\n\t\t\textensions: Array.from(this._extensions),\n\t\t\tdependencies: this._dependencies,\n\t\t\tlogger: this._logger,\n\t\t});\n\t}\n\n\t/** Converts a GLB-formatted Uint8Array to a {@link JSONDocument}. */\n\tpublic async binaryToJSON(glb: Uint8Array): Promise<JSONDocument> {\n\t\tconst jsonDoc = this._binaryToJSON(BufferUtils.assertView(glb));\n\t\tthis._readResourcesInternal(jsonDoc);\n\t\tconst json = jsonDoc.json;\n\n\t\t// Check for external references, which can't be resolved by this method.\n\t\tif (json.buffers && json.buffers.some((bufferDef) => isExternalBuffer(jsonDoc, bufferDef))) {\n\t\t\tthrow new Error('Cannot resolve external buffers with binaryToJSON().');\n\t\t} else if (json.images && json.images.some((imageDef) => isExternalImage(jsonDoc, imageDef))) {\n\t\t\tthrow new Error('Cannot resolve external images with binaryToJSON().');\n\t\t}\n\n\t\treturn jsonDoc;\n\t}\n\n\t/** Converts a GLB-formatted Uint8Array to a {@link Document}. */\n\tpublic async readBinary(glb: Uint8Array): Promise<Document> {\n\t\treturn this.readJSON(await this.binaryToJSON(BufferUtils.assertView(glb)));\n\t}\n\n\t/**********************************************************************************************\n\t * Public Write API.\n\t */\n\n\t/** Converts a {@link Document} to glTF-formatted JSON and a resource map. */\n\tpublic async writeJSON(doc: Document, _options: PublicWriterOptions = {}): Promise<JSONDocument> {\n\t\tif (_options.format === Format.GLB && doc.getRoot().listBuffers().length > 1) {\n\t\t\tthrow new Error('GLB must have 01 buffers.');\n\t\t}\n\t\treturn GLTFWriter.write(doc, {\n\t\t\tformat: _options.format || Format.GLTF,\n\t\t\tbasename: _options.basename || '',\n\t\t\tlogger: this._logger,\n\t\t\tvertexLayout: this._vertexLayout,\n\t\t\tdependencies: { ...this._dependencies },\n\t\t\textensions: Array.from(this._extensions),\n\t\t} as Required<WriterOptions>);\n\t}\n\n\t/** Converts a {@link Document} to a GLB-formatted Uint8Array. */\n\tpublic async writeBinary(doc: Document): Promise<Uint8Array> {\n\t\tconst { json, resources } = await this.writeJSON(doc, { format: Format.GLB });\n\n\t\tconst header = new Uint32Array([0x46546c67, 2, 12]);\n\n\t\tconst jsonText = JSON.stringify(json);\n\t\tconst jsonChunkData = BufferUtils.pad(BufferUtils.encodeText(jsonText), 0x20);\n\t\tconst jsonChunkHeader = BufferUtils.toView(new Uint32Array([jsonChunkData.byteLength, 0x4e4f534a]));\n\t\tconst jsonChunk = BufferUtils.concat([jsonChunkHeader, jsonChunkData]);\n\t\theader[header.length - 1] += jsonChunk.byteLength;\n\n\t\tconst binBuffer = Object.values(resources)[0];\n\t\tif (!binBuffer || !binBuffer.byteLength) {\n\t\t\treturn BufferUtils.concat([BufferUtils.toView(header), jsonChunk]);\n\t\t}\n\n\t\tconst binChunkData = BufferUtils.pad(binBuffer, 0x00);\n\t\tconst binChunkHeader = BufferUtils.toView(new Uint32Array([binChunkData.byteLength, 0x004e4942]));\n\t\tconst binChunk = BufferUtils.concat([binChunkHeader, binChunkData]);\n\t\theader[header.length - 1] += binChunk.byteLength;\n\n\t\treturn BufferUtils.concat([BufferUtils.toView(header), jsonChunk, binChunk]);\n\t}\n\n\t/**********************************************************************************************\n\t * Internal.\n\t */\n\n\tprivate async _readResourcesExternal(jsonDoc: JSONDocument, base: string): Promise<void> {\n\t\tconst images = jsonDoc.json.images || [];\n\t\tconst buffers = jsonDoc.json.buffers || [];\n\t\tconst pendingResources: Array<Promise<void>> = [...images, ...buffers].map(\n\t\t\tasync (resource: GLTF.IBuffer | GLTF.IImage): Promise<void> => {\n\t\t\t\tconst uri = resource.uri;\n\t\t\t\tif (!uri || uri.match(/data:/)) return Promise.resolve();\n\n\t\t\t\tjsonDoc.resources[uri] = await this.readURI(this.resolve(base, uri), 'view');\n\t\t\t\tthis.lastReadBytes += jsonDoc.resources[uri].byteLength;\n\t\t\t}\n\t\t);\n\t\tawait Promise.all(pendingResources);\n\t}\n\n\tprivate _readResourcesInternal(jsonDoc: JSONDocument): void {\n\t\t// NOTICE: This method may be called more than once during the loading\n\t\t// process (e.g. WebIO.read) and should handle that safely.\n\n\t\tfunction resolveResource(resource: GLTF.IBuffer | GLTF.IImage) {\n\t\t\tif (!resource.uri) return;\n\n\t\t\tif (resource.uri in jsonDoc.resources) {\n\t\t\t\tBufferUtils.assertView(jsonDoc.resources[resource.uri]);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (resource.uri.match(/data:/)) {\n\t\t\t\t// Rewrite Data URIs to something short and unique.\n\t\t\t\tconst resourceUUID = `__${uuid()}.${FileUtils.extension(resource.uri)}`;\n\t\t\t\tjsonDoc.resources[resourceUUID] = BufferUtils.createBufferFromDataURI(resource.uri);\n\t\t\t\tresource.uri = resourceUUID;\n\t\t\t}\n\t\t}\n\n\t\t// Unpack images.\n\t\tconst images = jsonDoc.json.images || [];\n\t\timages.forEach((image: GLTF.IImage) => {\n\t\t\tif (image.bufferView === undefined && image.uri === undefined) {\n\t\t\t\tthrow new Error('Missing resource URI or buffer view.');\n\t\t\t}\n\n\t\t\tresolveResource(image);\n\t\t});\n\n\t\t// Unpack buffers.\n\t\tconst buffers = jsonDoc.json.buffers || [];\n\t\tbuffers.forEach(resolveResource);\n\t}\n\n\t/**\n\t * Creates a shallow copy of glTF-formatted {@link JSONDocument}.\n\t *\n\t * Images, Buffers, and Resources objects are deep copies so that PlatformIO can safely\n\t * modify them during the parsing process. Other properties are shallow copies, and buffers\n\t * are passed by reference.\n\t */\n\tprivate _copyJSON(jsonDoc: JSONDocument): JSONDocument {\n\t\tconst { images, buffers } = jsonDoc.json;\n\n\t\tjsonDoc = { json: { ...jsonDoc.json }, resources: { ...jsonDoc.resources } };\n\n\t\tif (images) {\n\t\t\tjsonDoc.json.images = images.map((image) => ({ ...image }));\n\t\t}\n\t\tif (buffers) {\n\t\t\tjsonDoc.json.buffers = buffers.map((buffer) => ({ ...buffer }));\n\t\t}\n\n\t\treturn jsonDoc;\n\t}\n\n\t/** Internal version of binaryToJSON; does not warn about external resources. */\n\tprivate _binaryToJSON(glb: Uint8Array): JSONDocument {\n\t\t// Decode and verify GLB header.\n\t\tif (!isGLB(glb)) {\n\t\t\tthrow new Error('Invalid glTF 2.0 binary.');\n\t\t}\n\n\t\t// Decode JSON chunk.\n\n\t\tconst jsonChunkHeader = new Uint32Array(glb.buffer, glb.byteOffset + 12, 2);\n\t\tif (jsonChunkHeader[1] !== ChunkType.JSON) {\n\t\t\tthrow new Error('Missing required GLB JSON chunk.');\n\t\t}\n\n\t\tconst jsonByteOffset = 20;\n\t\tconst jsonByteLength = jsonChunkHeader[0];\n\t\tconst jsonText = BufferUtils.decodeText(BufferUtils.toView(glb, jsonByteOffset, jsonByteLength));\n\t\tconst json = JSON.parse(jsonText) as GLTF.IGLTF;\n\n\t\t// Decode BIN chunk.\n\n\t\tconst binByteOffset = jsonByteOffset + jsonByteLength;\n\t\tif (glb.byteLength <= binByteOffset) {\n\t\t\treturn { json, resources: {} };\n\t\t}\n\n\t\tconst binChunkHeader = new Uint32Array(glb.buffer, glb.byteOffset + binByteOffset, 2);\n\t\tif (binChunkHeader[1] !== ChunkType.BIN) {\n\t\t\tthrow new Error('Expected GLB BIN in second chunk.');\n\t\t}\n\n\t\tconst binByteLength = binChunkHeader[0];\n\t\tconst binBuffer = BufferUtils.toView(glb, binByteOffset + 8, binByteLength);\n\n\t\treturn { json, resources: { [GLB_BUFFER]: binBuffer } };\n\t}\n}\n\nfunction isExternalBuffer(jsonDocument: JSONDocument, bufferDef: GLTF.IBuffer): boolean {\n\treturn bufferDef.uri !== undefined && !(bufferDef.uri in jsonDocument.resources);\n}\n\nfunction isExternalImage(jsonDocument: JSONDocument, imageDef: GLTF.IImage): boolean {\n\treturn imageDef.uri !== undefined && !(imageDef.uri in jsonDocument.resources) && imageDef.bufferView === undefined;\n}\n\nfunction isGLB(view: Uint8Array): boolean {\n\tif (view.byteLength < 3 * Uint32Array.BYTES_PER_ELEMENT) return false;\n\tconst header = new Uint32Array(view.buffer, view.byteOffset, 3);\n\treturn header[0] === 0x46546c67 && header[1] === 2;\n}\n", "import { Format } from '../constants.js';\nimport type { Document } from '../document.js';\nimport { FileUtils } from '../utils/index.js';\nimport { PlatformIO } from './platform-io.js';\nimport { HTTPUtils } from '../utils/index.js';\n\n/**\n * *I/O service for Node.js.*\n *\n * The most common use of the I/O service is to read/write a {@link Document} with a given path.\n * Methods are also available for converting in-memory representations of raw glTF files, both\n * binary (*Uint8Array*) and JSON ({@link JSONDocument}).\n *\n * Usage:\n *\n * ```typescript\n * import { NodeIO } from '@gltf-transform/core';\n *\n * const io = new NodeIO();\n *\n * // Read.\n * let document;\n * document = await io.read('model.glb'); //  Document\n * document = await io.readBinary(glb);   // Uint8Array  Document\n *\n * // Write.\n * await io.write('model.glb', document);      //  void\n * const glb = await io.writeBinary(document); // Document  Uint8Array\n * ```\n *\n * By default, NodeIO can only read/write paths on disk. To enable HTTP requests, provide a Fetch\n * API implementation (such as [`node-fetch`](https://www.npmjs.com/package/node-fetch)) and enable\n * {@link NodeIO.setAllowHTTP setAllowHTTP}. HTTP requests may optionally be configured with\n * [RequestInit](https://developer.mozilla.org/en-US/docs/Web/API/fetch#parameters) parameters.\n *\n * ```typescript\n * import fetch from 'node-fetch';\n *\n * const io = new NodeIO(fetch, {headers: {...}}).setAllowHTTP(true);\n *\n * const document = await io.read('https://example.com/path/to/model.glb');\n * ```\n *\n * @category I/O\n */\nexport class NodeIO extends PlatformIO {\n\tprivate declare _fs;\n\tprivate declare _path;\n\tprivate readonly _fetch: typeof fetch | null;\n\tprivate readonly _fetchConfig: RequestInit;\n\n\tprivate _init: Promise<void>;\n\tprivate _fetchEnabled = false;\n\n\t/**\n\t * Constructs a new NodeIO service. Instances are reusable. By default, only NodeIO can only\n\t * read/write paths on disk. To enable HTTP requests, provide a Fetch API implementation and\n\t * enable {@link NodeIO.setAllowHTTP setAllowHTTP}.\n\t *\n\t * @param fetch Implementation of Fetch API.\n\t * @param fetchConfig Configuration object for Fetch API.\n\t */\n\tconstructor(_fetch: unknown = null, _fetchConfig = HTTPUtils.DEFAULT_INIT) {\n\t\tsuper();\n\t\tthis._fetch = _fetch as typeof fetch | null;\n\t\tthis._fetchConfig = _fetchConfig;\n\t\tthis._init = this.init();\n\t}\n\n\tpublic async init(): Promise<void> {\n\t\tif (this._init) return this._init;\n\t\treturn Promise.all([import('fs'), import('path')]).then(([fs, path]) => {\n\t\t\tthis._fs = fs.promises;\n\t\t\tthis._path = path;\n\t\t});\n\t}\n\n\tpublic setAllowHTTP(allow: boolean): this {\n\t\tif (allow && !this._fetch) {\n\t\t\tthrow new Error('NodeIO requires a Fetch API implementation for HTTP requests.');\n\t\t}\n\t\tthis._fetchEnabled = allow;\n\t\treturn this;\n\t}\n\n\tprotected async readURI(uri: string, type: 'view'): Promise<Uint8Array>;\n\tprotected async readURI(uri: string, type: 'text'): Promise<string>;\n\tprotected async readURI(uri: string, type: 'view' | 'text'): Promise<Uint8Array | string> {\n\t\tawait this.init();\n\t\tif (HTTPUtils.isAbsoluteURL(uri)) {\n\t\t\tif (!this._fetchEnabled || !this._fetch) {\n\t\t\t\tthrow new Error('Network request blocked. Allow HTTP requests explicitly, if needed.');\n\t\t\t}\n\n\t\t\tconst response = await this._fetch(uri, this._fetchConfig);\n\t\t\tswitch (type) {\n\t\t\t\tcase 'view':\n\t\t\t\t\treturn new Uint8Array(await response.arrayBuffer());\n\t\t\t\tcase 'text':\n\t\t\t\t\treturn response.text();\n\t\t\t}\n\t\t} else {\n\t\t\tswitch (type) {\n\t\t\t\tcase 'view':\n\t\t\t\t\treturn this._fs.readFile(uri);\n\t\t\t\tcase 'text':\n\t\t\t\t\treturn this._fs.readFile(uri, 'utf8');\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected resolve(base: string, path: string): string {\n\t\tif (HTTPUtils.isAbsoluteURL(base) || HTTPUtils.isAbsoluteURL(path)) {\n\t\t\treturn HTTPUtils.resolve(base, path);\n\t\t}\n\t\t// https://github.com/KhronosGroup/glTF/issues/1449\n\t\t// https://stackoverflow.com/a/27278490/1314762\n\t\treturn this._path.resolve(base, decodeURIComponent(path));\n\t}\n\n\tprotected dirname(uri: string): string {\n\t\tif (HTTPUtils.isAbsoluteURL(uri)) {\n\t\t\treturn HTTPUtils.dirname(uri);\n\t\t}\n\t\treturn this._path.dirname(uri);\n\t}\n\n\t/**********************************************************************************************\n\t * Public.\n\t */\n\n\t/** Writes a {@link Document} instance to a local path. */\n\tpublic async write(uri: string, doc: Document): Promise<void> {\n\t\tawait this.init();\n\t\tconst isGLB = !!uri.match(/\\.glb$/);\n\t\tawait (isGLB ? this._writeGLB(uri, doc) : this._writeGLTF(uri, doc));\n\t}\n\n\t/**********************************************************************************************\n\t * Private.\n\t */\n\n\t/** @internal */\n\tprivate async _writeGLTF(uri: string, doc: Document): Promise<void> {\n\t\tthis.lastWriteBytes = 0;\n\t\tconst { json, resources } = await this.writeJSON(doc, {\n\t\t\tformat: Format.GLTF,\n\t\t\tbasename: FileUtils.basename(uri),\n\t\t});\n\t\tconst { _fs: fs, _path: path } = this;\n\t\tconst dir = path.dirname(uri);\n\t\tconst jsonContent = JSON.stringify(json, null, 2);\n\t\tthis.lastWriteBytes += jsonContent.length;\n\t\tawait fs.writeFile(uri, jsonContent);\n\t\tconst pending = Object.keys(resources).map(async (resourceURI) => {\n\t\t\tif (HTTPUtils.isAbsoluteURL(resourceURI)) {\n\t\t\t\tif (HTTPUtils.extension(resourceURI) === 'bin') {\n\t\t\t\t\tthrow new Error(`Cannot write buffer to path \"${resourceURI}\".`);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst resource = Buffer.from(resources[resourceURI]);\n\t\t\tconst resourcePath = path.join(dir, resourceURI);\n\t\t\tawait fs.mkdir(path.dirname(resourcePath), { recursive: true });\n\t\t\tawait fs.writeFile(resourcePath, resource);\n\t\t\tthis.lastWriteBytes += resource.byteLength;\n\t\t});\n\t\tawait Promise.all(pending);\n\t}\n\n\t/** @internal */\n\tprivate async _writeGLB(uri: string, doc: Document): Promise<void> {\n\t\tconst buffer = Buffer.from(await this.writeBinary(doc));\n\t\tawait this._fs.writeFile(uri, buffer);\n\t\tthis.lastWriteBytes = buffer.byteLength;\n\t}\n}\n", "import { PlatformIO } from './platform-io.js';\n\ninterface Path {\n\tresolve(base: string, path: string): string;\n\tdirname(uri: string): string;\n}\n\n/**\n * *I/O service for [Deno](https://deno.land/).*\n *\n * The most common use of the I/O service is to read/write a {@link Document} with a given path.\n * Methods are also available for converting in-memory representations of raw glTF files, both\n * binary (*Uint8Array*) and JSON ({@link JSONDocument}).\n *\n * _*NOTICE:* Support for the Deno environment is currently experimental. See\n * [glTF-Transform#457](https://github.com/donmccurdy/glTF-Transform/issues/457)._\n *\n * Usage:\n *\n * ```typescript\n * import { DenoIO } from 'https://esm.sh/@gltf-transform/core';\n * import * as path from 'https://deno.land/std/path/mod.ts';\n *\n * const io = new DenoIO(path);\n *\n * // Read.\n * let document;\n * document = io.read('model.glb');  //  Document\n * document = io.readBinary(glb);    // Uint8Array  Document\n *\n * // Write.\n * const glb = io.writeBinary(document);  // Document  Uint8Array\n * ```\n *\n * @category I/O\n */\nexport class DenoIO extends PlatformIO {\n\tprivate _path: Path;\n\n\tconstructor(path: unknown) {\n\t\tsuper();\n\t\tthis._path = path as Path;\n\t}\n\n\tprotected async readURI(uri: string, type: 'view'): Promise<Uint8Array>;\n\tprotected async readURI(uri: string, type: 'text'): Promise<string>;\n\tprotected async readURI(uri: string, type: 'view' | 'text'): Promise<Uint8Array | string> {\n\t\t// TODO(cleanup): The @ts-ignore rules below are necessary for typedoc, but not for normal\n\t\t// compilation with microbundle. Clean this up when possible.\n\t\tswitch (type) {\n\t\t\tcase 'view':\n\t\t\t\t// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n\t\t\t\t// @ts-ignore\n\t\t\t\treturn Deno.readFile(uri);\n\t\t\tcase 'text':\n\t\t\t\t// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n\t\t\t\t// @ts-ignore\n\t\t\t\treturn Deno.readTextFile(uri);\n\t\t}\n\t}\n\n\tprotected resolve(base: string, path: string): string {\n\t\t// https://github.com/KhronosGroup/glTF/issues/1449\n\t\t// https://stackoverflow.com/a/27278490/1314762\n\t\treturn this._path.resolve(base, decodeURIComponent(path));\n\t}\n\n\tprotected dirname(uri: string): string {\n\t\treturn this._path.dirname(uri);\n\t}\n}\n", "import { PlatformIO } from './platform-io.js';\nimport { HTTPUtils } from '../utils/index.js';\n\n/**\n * *I/O service for Web.*\n *\n * The most common use of the I/O service is to read/write a {@link Document} with a given path.\n * Methods are also available for converting in-memory representations of raw glTF files, both\n * binary (*Uint8Array*) and JSON ({@link JSONDocument}).\n *\n * Usage:\n *\n * ```typescript\n * import { WebIO } from '@gltf-transform/core';\n *\n * const io = new WebIO({credentials: 'include'});\n *\n * // Read.\n * let document;\n * document = await io.read('model.glb');  //  Document\n * document = await io.readBinary(glb);    // Uint8Array  Document\n *\n * // Write.\n * const glb = await io.writeBinary(document); // Document  Uint8Array\n * ```\n *\n * @category I/O\n */\nexport class WebIO extends PlatformIO {\n\tprivate readonly _fetchConfig: RequestInit;\n\n\t/**\n\t * Constructs a new WebIO service. Instances are reusable.\n\t * @param fetchConfig Configuration object for Fetch API.\n\t */\n\tconstructor(fetchConfig = HTTPUtils.DEFAULT_INIT) {\n\t\tsuper();\n\t\tthis._fetchConfig = fetchConfig;\n\t}\n\n\tprotected async readURI(uri: string, type: 'view'): Promise<Uint8Array>;\n\tprotected async readURI(uri: string, type: 'text'): Promise<string>;\n\tprotected async readURI(uri: string, type: 'view' | 'text'): Promise<Uint8Array | string> {\n\t\tconst response = await fetch(uri, this._fetchConfig);\n\t\tswitch (type) {\n\t\t\tcase 'view':\n\t\t\t\treturn new Uint8Array(await response.arrayBuffer());\n\t\t\tcase 'text':\n\t\t\t\treturn response.text();\n\t\t}\n\t}\n\n\tprotected resolve(base: string, path: string): string {\n\t\treturn HTTPUtils.resolve(base, path);\n\t}\n\n\tprotected dirname(uri: string): string {\n\t\treturn HTTPUtils.dirname(uri);\n\t}\n}\n", "import { Mesh3 } from '../geometry/3d/Mesh3'\nimport { Node3 } from '../core/Node3'\nimport { GfxApp } from '../core/GfxApp'\nimport { MeshParser } from './MeshParser'\nimport { Document, WebIO } from '@gltf-transform/core';\n\nexport class MeshLoader\n{\n    static loadGLTF(filename: string, callback: ((rootNode: Node3) => void) | null = null, recursive = true): Node3\n    {\n\n        GfxApp.getInstance().assetManager.requestedAssets.push(filename);\n\n        const root = new Node3();\n\n        const io = new WebIO();\n        io.read(filename).then((document: Document) => {\n            \n            MeshParser.parseGLTF(document, root);\n            if(callback)\n            {\n                callback(root);\n            }\n            GfxApp.getInstance().assetManager.loadedAssets.push(filename);\n\n        })\n        .catch(() => {\n            GfxApp.getInstance().assetManager.errorAssets.push(filename);\n            console.error('Unable to fetch GLTF file: ' + filename);\n        });\n\n        return root;\n    }\n\n    /**\n     * Loads an OBJ file\n     * \n     * @param filename - The relative path to the OBJ file\n     * @param callback - An optional callback that is called when the file has been loaded\n     * @returns A Mesh object containing the data loaded from the file\n     */  \n    static loadOBJ(filename: string, callback: ((loadedMesh: Mesh3) => void) | null = null): Mesh3\n    {\n        GfxApp.getInstance().assetManager.requestedAssets.push(filename);\n\n        const mesh = new Mesh3();\n\n        fetch(filename).then((response: Response) => {\n            if(!response.ok)\n                throw new Error();\n            return response.blob();\n        })\n        .then((data: Blob) => {\n            data.text().then((text: string) => {\n\n                MeshParser.parseOBJ(text, mesh);\n                if(callback)\n                {\n                    callback(mesh);\n                }\n                GfxApp.getInstance().assetManager.loadedAssets.push(filename);\n\n            });\n        })\n        .catch(() => {\n            GfxApp.getInstance().assetManager.errorAssets.push(filename);\n            console.error('Unable to load OBJ file: ' + filename);\n        });\n\n        return mesh;\n    }\n\n    /**\n     * Loads a PLY file\n     * \n     * @param filename - The relative path to the PLY file\n     * @param callback - An optional callback that is called when the file has been loaded\n     * @returns A Mesh object containing the data loaded from the file\n     */  \n    static loadPLY(filename: string, callback: ((loadedMesh: Mesh3) => void) | null = null): Mesh3\n    {\n        GfxApp.getInstance().assetManager.requestedAssets.push(filename);\n\n        const mesh = new Mesh3();\n\n        fetch(filename).then((response: Response) => {\n            if(!response.ok)\n                throw new Error();\n            return response.blob();\n        })\n        .then((data: Blob) => {\n            data.arrayBuffer().then((buffer: ArrayBuffer) => {\n\n                MeshParser.parsePLY(buffer, mesh);\n                if(callback)\n                {\n                    callback(mesh);\n                }\n                GfxApp.getInstance().assetManager.loadedAssets.push(filename);\n\n            });\n        })\n        .catch(() => {\n            GfxApp.getInstance().assetManager.errorAssets.push(filename);\n            console.error('Unable to load PLY file: ' + filename);\n        });\n\n        return mesh;\n    }\n}", "import { FileWriter } from './FileWriter'\nimport { Mesh3 } from '../geometry/3d/Mesh3'\nimport { Node3 } from '../core/Node3'\nimport { Document, Format, WebIO, Node, Buffer } from '@gltf-transform/core'; \n\nexport class MeshWriter\n{\n    static saveOBJ(filename: string, mesh: Mesh3): void\n    {\n        let output = '# Generated by GopherGfx\\n';\n        output += '# Vertices: ' + mesh.vertexCount + '\\n';\n        output += '# Faces: ' + mesh.triangleCount + '\\n';\n        output += '\\n';\n\n        const vertices = mesh.getVertices();\n        const normals = mesh.getNormals();\n        const uvs = mesh.getTextureCoordinates();\n        const indices = mesh.getIndices();\n\n        if(mesh.hasVertexColors)\n        {\n            const colors = mesh.getColors();\n            for(let i = 0; i < mesh.vertexCount; i++)\n            {\n                output += 'v ' + vertices[i*3].toFixed(6) + ' '  + vertices[i*3+1].toFixed(6) + ' '  + vertices[i*3+2].toFixed(6) + ' ' +\n                    colors[i*4].toFixed(6) + ' '  + colors[i*4+1].toFixed(6) + ' '  + colors[i*4+2].toFixed(6) + '\\n';\n\n                output += 'vn ' + normals[i*3].toFixed(6) + ' '  + normals[i*3+1].toFixed(6) + ' '  + normals[i*3+2].toFixed(6) + '\\n';\n                output += 'vt ' + uvs[i*2].toFixed(6) + ' '  + uvs[i*2+1].toFixed(6) + '\\n';\n            }\n        }\n        else\n        {\n            for(let i = 0; i < mesh.vertexCount; i++)\n            {\n                output += 'v ' + vertices[i*3].toFixed(6) + ' '  + vertices[i*3+1].toFixed(6) + ' '  + vertices[i*3+2].toFixed(6) + '\\n';\n\n                output += 'vn ' + normals[i*3].toFixed(6) + ' '  + normals[i*3+1].toFixed(6) + ' '  + normals[i*3+2].toFixed(6) + '\\n';\n                output += 'vt ' + uvs[i*2].toFixed(6) + ' '  + uvs[i*2+1].toFixed(6) + '\\n';\n            }\n        }\n        \n\n        output += '\\n';\n\n        for(let i = 0; i < indices.length; i+=3)\n        {\n            output += 'f ' + (indices[i]+1) + ' '  + (indices[i+1]+1) + ' '  + (indices[i+2]+1) + '\\n';\n        }\n        \n        FileWriter.saveAscii(filename, output);\n    }\n\n    static savePLY(filename: string, mesh: Mesh3, binary = true): void\n    {\n        const vertices = mesh.getVertices();\n        const normals = mesh.getNormals();\n        const uvs = mesh.getTextureCoordinates();\n        const indices = mesh.getIndices();\n\n        let colors: number[] = [];\n        if(mesh.hasVertexColors)\n            colors = mesh.getColors();\n\n        let header = 'ply\\n';\n\n        if(binary)\n        {\n            header += 'format binary_little_endian 1.0\\n';\n        }\n        else\n        {\n            header += 'format ascii 1.0\\n';\n        }\n\n        header += 'comment Generated by GopherGfx\\n';\n\n        header += 'element vertex ' + mesh.vertexCount + '\\n';\n        header += 'property float x\\n';\n        header += 'property float y\\n';\n        header += 'property float z\\n';\n        \n        header += 'property float nx\\n';\n        header += 'property float ny\\n';\n        header += 'property float nz\\n';\n\n        header += 'property float texture_u\\n';\n        header += 'property float texture_v\\n';\n        \n        if(mesh.hasVertexColors)\n        {\n            header += 'property uchar red\\n';\n            header += 'property uchar green\\n';\n            header += 'property uchar blue\\n';\n            header += 'property uchar alpha\\n';\n        }\n\n        header += 'element face ' + mesh.triangleCount + '\\n';\n        header += 'property list uchar int vertex_indices\\n'\n        header += 'end_header\\n';\n        \n        if(binary)\n        {\n            // Encode the text from the header as binary data\n            const encoder = new TextEncoder();\n            const headerData = encoder.encode(header);\n\n            // Compute the size of the binary array buffer\n            const bytesPerVertex = 36;\n            const bytesPerFace = 13;\n            const buffer = new ArrayBuffer(headerData.length + mesh.vertexCount * bytesPerVertex + mesh.triangleCount * bytesPerFace);\n\n            // Copy header data into the buffer\n            const output = new Uint8Array(buffer);\n            output.set(headerData, 0);\n\n            // Create a data view into the buffer\n            const view = new DataView(buffer);\n\n            let byteCounter = headerData.length;\n            for(let i = 0; i < mesh.vertexCount; i++)\n            {\n                view.setFloat32(byteCounter, vertices[i*3], true); \n                byteCounter+=4;\n\n                view.setFloat32(byteCounter, vertices[i*3+1], true); \n                byteCounter+=4;\n\n                view.setFloat32(byteCounter, vertices[i*3+2], true); \n                byteCounter+=4;\n\n                view.setFloat32(byteCounter, normals[i*3], true); \n                byteCounter+=4;\n\n                view.setFloat32(byteCounter, normals[i*3+1], true); \n                byteCounter+=4;\n\n                view.setFloat32(byteCounter, normals[i*3+2], true); \n                byteCounter+=4;\n\n                view.setFloat32(byteCounter, uvs[i*2], true); \n                byteCounter+=4;\n\n                view.setFloat32(byteCounter, uvs[i*2+1], true); \n                byteCounter+=4;\n\n                if(mesh.hasVertexColors)\n                {\n                    view.setUint8(byteCounter, Math.floor(colors[i*4]*255)); \n                    byteCounter+=1;\n\n                    view.setUint8(byteCounter, Math.floor(colors[i*4+1]*255)); \n                    byteCounter+=1;\n\n                    view.setUint8(byteCounter, Math.floor(colors[i*4+2]*255)); \n                    byteCounter+=1;\n\n                    view.setUint8(byteCounter, Math.floor(colors[i*4+3]*255)); \n                    byteCounter+=1;\n                }\n            }\n\n            for(let i = 0; i <  mesh.triangleCount; i++)\n            {\n                view.setUint8(byteCounter, 3);\n                byteCounter+=1;\n\n                view.setInt32(byteCounter, indices[i*3], true);\n                byteCounter+=4;\n\n                view.setInt32(byteCounter, indices[i*3+1], true);\n                byteCounter+=4;\n\n                view.setInt32(byteCounter, indices[i*3+2], true);\n                byteCounter+=4;\n            }\n\n            FileWriter.saveBinary(filename, output);\n        }\n        else\n        {\n            let output = header;\n\n            for(let i = 0; i < mesh.vertexCount; i++)\n            {\n                output += vertices[i*3].toFixed(6) + ' '  + vertices[i*3+1].toFixed(6) + ' '  + vertices[i*3+2].toFixed(6);\n                output += ' ' + normals[i*3].toFixed(6) + ' '  + normals[i*3+1].toFixed(6) + ' '  + normals[i*3+2].toFixed(6);\n\n                output += ' ' + uvs[i*2].toFixed(6) + ' '  + uvs[i*2+1].toFixed(6);\n                if(mesh.hasVertexColors)\n                    output += ' ' + Math.floor(colors[i*4]*255) + ' '  + Math.floor(colors[i*4+1]*255) + ' '  + Math.floor(colors[i*4+2]*255) + ' '  + Math.floor(colors[i*4+3]*255);\n                \n                    output += '\\n';\n            }\n\n            for(let i = 0; i < indices.length; i+=3)\n            {\n                output += '3 ' + indices[i] + ' '  + indices[i+1] + ' '  + indices[i+2] + '\\n';\n            }\n            \n            FileWriter.saveAscii(filename, output);\n        }\n    }\n\n    static saveGLTF(filename: string, transform: Node3): void\n    {\n        const doc = MeshWriter.createGLTF(transform);\n        MeshWriter.writeJSON(filename, doc); \n    }\n\n    static saveGLB(filename: string, transform: Node3): void\n    {\n        const doc = MeshWriter.createGLTF(transform);\n        const io = new WebIO();\n        io.writeBinary(doc).then((data: Uint8Array) => {\n            FileWriter.saveBinary(filename, data);\n        });\n    }\n\n    private static createGLTF(transform: Node3): Document\n    {\n        const doc = new Document();\n        const buffer = doc.createBuffer();\n        const scene = doc.createScene();\n        const node = doc.createNode();\n        scene.addChild(node);\n\n        MeshWriter.createGLTFRecursive(transform, doc, buffer, node);\n\n        return doc;\n    }\n\n    private static createGLTFRecursive(transform: Node3, doc: Document, buffer: Buffer, node: Node)\n    {\n        const position = transform.position;\n        const rotation = transform.rotation;\n        const scale = transform.scale;\n        node.setTranslation([position.x, position.y, position.z]);\n        node.setRotation([rotation.x, rotation.y, rotation.z, rotation.w]);\n        node.setScale([scale.x, scale.y, scale.z]);\n\n        if(transform instanceof Mesh3)\n        {\n            const vertices = transform.getVertices();\n            const normals = transform.getNormals();\n            const uvs = transform.getTextureCoordinates();\n            const indices = transform.getIndices();\n\n            const mesh = doc.createMesh();\n            node.setMesh(mesh);\n\n            const primitive = doc.createPrimitive();\n\n            const gltfPosition = doc\n                .createAccessor()\n                .setArray(new Float32Array(vertices))\n                .setType(\"VEC3\")\n                .setBuffer(buffer);\n            primitive.setAttribute(\"POSITION\", gltfPosition);\n\n            const gltfNormals = doc\n                .createAccessor()\n                .setArray(new Float32Array(normals))\n                .setType(\"VEC3\")\n                .setBuffer(buffer);\n            primitive.setAttribute(\"NORMAL\", gltfNormals);\n\n            if(transform.hasVertexColors)\n            {\n                const colors = transform.getColors();\n                \n                const gltfColors = doc\n                    .createAccessor()\n                    .setArray(new Float32Array(colors))\n                    .setType(\"VEC4\")\n                    .setBuffer(buffer);\n                primitive.setAttribute(\"COLOR_0\", gltfColors);\n            }\n\n            const gltfUVs = doc\n                .createAccessor()\n                .setArray(new Float32Array(uvs))\n                .setType(\"VEC2\")\n                .setBuffer(buffer);\n            primitive.setAttribute(\"TEXCOORD_0\", gltfUVs);\n\n            const gltfIndices = doc\n                .createAccessor()\n                .setArray(new Uint32Array(indices))\n                .setType(\"SCALAR\")\n                .setBuffer(buffer);\n            primitive.setIndices(gltfIndices);\n\n            const materialColor = transform.material.getColor();\n            const material = doc.createMaterial()\n                .setBaseColorFactor([materialColor.r, materialColor.g, materialColor.b, materialColor.a]);\n\n            primitive.setMaterial(material);\n\n            mesh.addPrimitive(primitive);\n        }\n\n        for(let i=0; i < transform.children.length; i++)\n        {\n            const child = doc.createNode();\n            node.addChild(child);\n\n            MeshWriter.createGLTFRecursive(transform.children[i], doc, buffer, child);\n        }\n    }\n\n    private static async writeJSON(filename: string, doc: Document): Promise<void>\n    {\n        const io = new WebIO();\n        const { json, resources } = await io.writeJSON(doc, {format: Format.GLTF, basename: filename});\n\n        const base64url = await new Promise((r) => {\n            const reader = new FileReader();\n            reader.onload = () => r(reader.result);\n            reader.readAsDataURL(new Blob([resources[filename + '.bin']]));\n        });\n\n        json.buffers![0].uri = base64url as string;\n\n        FileWriter.saveAscii(filename, JSON.stringify(json, null, 2));\n    } \n}", "// @ts-ignore\nimport phongVertexShader from '../shaders/phong.vert'\n// @ts-ignore\nimport phongFragmentShader from '../shaders/phong.frag'\n\nimport { Material3 } from './Material3';\nimport { ShaderProgram } from './ShaderProgram';\nimport { Mesh3 } from '../geometry/3d/Mesh3';\nimport { Camera } from '../core/Camera';\nimport { Node3 } from '../core/Node3';\nimport { LightManager } from '../lights/LightManager';\nimport { Texture } from './Texture';\nimport { Vector3 } from '../math/Vector3'\nimport { Color } from '../math/Color' \n\nexport class PhongMaterial extends Material3\n{\n    public texture: Texture | null;\n    public ambientColor: Color;\n    public diffuseColor: Color;\n    public specularColor: Color;\n    public shininess: number;\n\n    public static shader = new ShaderProgram(phongVertexShader, phongFragmentShader);\n\n    private kAmbientUniform: WebGLUniformLocation | null;\n    private kDiffuseUniform: WebGLUniformLocation | null;\n    private kSpecularUniform: WebGLUniformLocation | null;\n    private shininessUniform: WebGLUniformLocation | null;\n    \n    private textureUniform: WebGLUniformLocation | null;\n    private useTextureUniform: WebGLUniformLocation | null;\n\n    private eyePositionUniform: WebGLUniformLocation | null;\n    private modelUniform: WebGLUniformLocation | null;\n    private viewUniform: WebGLUniformLocation | null;\n    private projectionUniform: WebGLUniformLocation | null;\n    private normalUniform: WebGLUniformLocation | null;\n\n    private numLightsUniform: WebGLUniformLocation | null;\n    private lightTypesUniform: WebGLUniformLocation | null;\n    private lightPositionsUniform: WebGLUniformLocation | null;\n    private ambientIntensitiesUniform: WebGLUniformLocation | null;\n    private diffuseIntensitiesUniform: WebGLUniformLocation | null;\n    private specularIntensitiesUniform: WebGLUniformLocation | null;\n\n    private positionAttribute: number;\n    private normalAttribute: number;\n    private colorAttribute: number;\n    private texCoordAttribute: number;\n\n    constructor()\n    {\n        super();\n\n        this.texture = null;\n        this.ambientColor = new Color(1, 1, 1);\n        this.diffuseColor = new Color(1, 1, 1);\n        this.specularColor = new Color(0, 0, 0);\n        this.shininess = 30;\n\n        PhongMaterial.shader.initialize(this.gl);\n\n        this.kAmbientUniform = PhongMaterial.shader.getUniform(this.gl, 'kAmbient');\n        this.kDiffuseUniform = PhongMaterial.shader.getUniform(this.gl, 'kDiffuse');\n        this.kSpecularUniform = PhongMaterial.shader.getUniform(this.gl, 'kSpecular');\n        this.shininessUniform = PhongMaterial.shader.getUniform(this.gl, 'shininess');\n\n        this.textureUniform = PhongMaterial.shader.getUniform(this.gl, 'textureImage');\n        this.useTextureUniform = PhongMaterial.shader.getUniform(this.gl, 'useTexture');\n\n        this.eyePositionUniform = PhongMaterial.shader.getUniform(this.gl, 'eyePosition');\n        this.viewUniform = PhongMaterial.shader.getUniform(this.gl, 'viewMatrix');\n        this.modelUniform = PhongMaterial.shader.getUniform(this.gl, 'modelMatrix');\n        this.projectionUniform = PhongMaterial.shader.getUniform(this.gl, 'projectionMatrix');\n        this.normalUniform = PhongMaterial.shader.getUniform(this.gl, 'normalMatrix');\n\n        this.numLightsUniform = PhongMaterial.shader.getUniform(this.gl, 'numLights');\n        this.lightTypesUniform = PhongMaterial.shader.getUniform(this.gl, 'lightTypes');\n        this.lightPositionsUniform = PhongMaterial.shader.getUniform(this.gl, 'lightPositions');\n        this.ambientIntensitiesUniform = PhongMaterial.shader.getUniform(this.gl, 'ambientIntensities');\n        this.diffuseIntensitiesUniform = PhongMaterial.shader.getUniform(this.gl, 'diffuseIntensities');\n        this.specularIntensitiesUniform = PhongMaterial.shader.getUniform(this.gl, 'specularIntensities');\n\n        this.positionAttribute = PhongMaterial.shader.getAttribute(this.gl, 'position');\n        this.normalAttribute = PhongMaterial.shader.getAttribute(this.gl, 'normal');\n        this.colorAttribute = PhongMaterial.shader.getAttribute(this.gl, 'color');\n        this.texCoordAttribute = PhongMaterial.shader.getAttribute(this.gl, 'texCoord');   \n    }\n\n    draw(mesh: Mesh3, camera: Camera, lightManager: LightManager): void\n    {\n        if(!this.visible || mesh.triangleCount == 0)\n            return;\n\n        this.initialize();\n\n        // Switch to this shader\n        this.gl.useProgram(PhongMaterial.shader.getProgram());\n\n        // Set the camera uniforms\n        const worldMatrix = mesh.localToWorldMatrix;\n        const cameraPosition = new Vector3();\n        cameraPosition.transformPoint(camera.localToWorldMatrix);\n        this.gl.uniform3f(this.eyePositionUniform, cameraPosition.x, cameraPosition.y, cameraPosition.z);\n        this.gl.uniformMatrix4fv(this.modelUniform, false, worldMatrix.mat);\n        this.gl.uniformMatrix4fv(this.viewUniform, false, camera.viewMatrix.mat);\n        this.gl.uniformMatrix4fv(this.projectionUniform, false, camera.projectionMatrix.mat);\n        this.gl.uniformMatrix4fv(this.normalUniform, false, worldMatrix.inverse().transpose().mat);\n\n        // Set the material property uniforms\n        this.gl.uniform3f(this.kAmbientUniform, this.ambientColor.r, this.ambientColor.g, this.ambientColor.b);\n        this.gl.uniform3f(this.kDiffuseUniform, this.diffuseColor.r, this.diffuseColor.g, this.diffuseColor.b);\n        this.gl.uniform3f(this.kSpecularUniform,this.specularColor.r, this.specularColor.g, this.specularColor.b);\n        this.gl.uniform1f(this.shininessUniform, this.shininess);\n\n        // Set the light uniforms\n        this.gl.uniform1i(this.numLightsUniform, lightManager.getNumLights());\n        this.gl.uniform1iv(this.lightTypesUniform, lightManager.lightTypes);\n        this.gl.uniform3fv(this.lightPositionsUniform, lightManager.lightPositions);\n        this.gl.uniform3fv(this.ambientIntensitiesUniform, lightManager.ambientIntensities);\n        this.gl.uniform3fv(this.diffuseIntensitiesUniform, lightManager.diffuseIntensities);\n        this.gl.uniform3fv(this.specularIntensitiesUniform, lightManager.specularIntensities);\n\n        // Set the vertex positions\n        this.gl.enableVertexAttribArray(this.positionAttribute);\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, mesh.positionBuffer);\n        this.gl.vertexAttribPointer(this.positionAttribute, 3, this.gl.FLOAT, false, 0, 0);\n\n        // Set the vertex normals\n        this.gl.enableVertexAttribArray(this.normalAttribute);\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, mesh.normalBuffer);\n        this.gl.vertexAttribPointer(this.normalAttribute, 3, this.gl.FLOAT, false, 0, 0);\n\n        // Set the vertex colors\n        if(mesh.hasVertexColors)\n        {\n            this.gl.enableVertexAttribArray(this.colorAttribute);\n            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, mesh.colorBuffer);\n            this.gl.vertexAttribPointer(this.colorAttribute, 4, this.gl.FLOAT, false, 0, 0);\n        }\n        else\n        {\n            this.gl.disableVertexAttribArray(this.colorAttribute);\n            this.gl.vertexAttrib4f(this.colorAttribute, 1, 1, 1, 1);\n        }\n\n        if(this.texture)\n        {\n            // Activate the texture in the shader\n            this.gl.uniform1i(this.useTextureUniform, 1);\n\n            // Set the texture\n            this.gl.activeTexture(this.gl.TEXTURE0 + this.texture.id)\n            this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture.texture);\n            this.gl.uniform1i(this.textureUniform, this.texture.id);\n\n            // Set the texture coordinates\n            this.gl.enableVertexAttribArray(this.texCoordAttribute);\n            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, mesh.texCoordBuffer);\n            this.gl.vertexAttribPointer(this.texCoordAttribute, 2, this.gl.FLOAT, false, 0, 0);\n        }\n        else\n        {\n            // Disable the texture in the shader\n            this.gl.uniform1i(this.useTextureUniform, 0);\n            this.gl.disableVertexAttribArray(this.texCoordAttribute);\n        }\n\n        // Draw the triangles\n        this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, mesh.indexBuffer);\n        this.gl.drawElements(this.gl.TRIANGLES, mesh.triangleCount*3, this.gl.UNSIGNED_SHORT, 0);\n    }\n\n    setColor(color: Color): void\n    {\n        this.ambientColor.copy(color);\n        this.diffuseColor.copy(color);\n        this.specularColor.copy(color);\n    }\n\n    getColor(): Color\n    {\n        return this.diffuseColor;\n    }\n}", "// @ts-ignore\nimport wireframeVertexShader from '../shaders/wireframe.vert'\n// @ts-ignore\nimport wireframeFragmentShader from '../shaders/wireframe.frag'\n\nimport { Material3 } from './Material3';\nimport { ShaderProgram } from './ShaderProgram';\nimport { Mesh3 } from '../geometry/3d/Mesh3';\nimport { Camera } from '../core/Camera';\nimport { Node3 } from '../core/Node3';\nimport { LightManager } from '../lights/LightManager';\nimport { Color } from '../math/Color';\nimport { Matrix4 } from '../math/Matrix4'\n\n\nexport class WireframeMaterial extends Material3\n{\n    public static shader = new ShaderProgram(wireframeVertexShader, wireframeFragmentShader);\n    public static wireframeBuffers: Map<Mesh3, WebGLBuffer> = new Map();\n\n    public color: Color;\n\n    private positionAttribute: number;\n    private modelViewUniform: WebGLUniformLocation | null;\n    private projectionUniform: WebGLUniformLocation | null;\n    private colorUniform: WebGLUniformLocation | null;\n\n    constructor()\n    {\n        super();\n\n        this.color = new Color(1, 1, 1, 1);\n\n        WireframeMaterial.shader.initialize(this.gl);\n        this.positionAttribute = WireframeMaterial.shader.getAttribute(this.gl, 'position');\n        this.modelViewUniform = WireframeMaterial.shader.getUniform(this.gl, 'modelViewMatrix');\n        this.projectionUniform = WireframeMaterial.shader.getUniform(this.gl, 'projectionMatrix');\n        this.colorUniform = WireframeMaterial.shader.getUniform(this.gl, 'color');\n    }\n\n    draw(mesh: Mesh3, camera: Camera, lightManager: LightManager): void\n    {\n        if(!this.visible || mesh.triangleCount == 0)\n            return;\n\n        this.initialize();\n            \n        // Switch to this shader\n        this.gl.useProgram(WireframeMaterial.shader.getProgram());\n\n        // Set the uniform matrices\n        this.gl.uniformMatrix4fv(this.modelViewUniform, false, Matrix4.multiply(camera.viewMatrix, mesh.localToWorldMatrix).mat);\n        this.gl.uniformMatrix4fv(this.projectionUniform, false, camera.projectionMatrix.mat);\n        this.gl.uniform4f(this.colorUniform, this.color.r, this.color.g, this.color.b, this.color.a);\n\n        // // Set the vertex positions\n        this.gl.enableVertexAttribArray(this.positionAttribute);\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, mesh.positionBuffer);\n        this.gl.vertexAttribPointer(this.positionAttribute, 3, this.gl.FLOAT, false, 0, 0);\n\n        if(!WireframeMaterial.wireframeBuffers.get(mesh))\n        {\n            this.updateWireframeBuffer(mesh);\n        }\n\n        this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, WireframeMaterial.wireframeBuffers.get(mesh) as WebGLBuffer);\n        this.gl.drawElements(this.gl.LINES, mesh.triangleCount * 6, this.gl.UNSIGNED_SHORT, 0);\n    }\n\n    public updateWireframeBuffer(mesh: Mesh3): void\n    {\n        let wireframeBuffer: WebGLBuffer | null | undefined;\n        wireframeBuffer = WireframeMaterial.wireframeBuffers.get(mesh);\n\n        if(!wireframeBuffer)\n        {\n            wireframeBuffer = this.gl.createBuffer();\n            \n            if(wireframeBuffer)\n                WireframeMaterial.wireframeBuffers.set(mesh, wireframeBuffer);\n        }\n\n        const indexArray = new Uint16Array(mesh.triangleCount * 3);\n        this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, mesh.indexBuffer);\n        this.gl.getBufferSubData(this.gl.ELEMENT_ARRAY_BUFFER, 0, indexArray);\n        const indices = [... indexArray];\n\n        const wireframeIndices: number[] = [];\n        for(let i=0; i < mesh.triangleCount; i++)\n        {\n            wireframeIndices.push(indices[i*3]);\n            wireframeIndices.push(indices[i*3+1]);\n\n            wireframeIndices.push(indices[i*3+1]);\n            wireframeIndices.push(indices[i*3+2]);\n\n            wireframeIndices.push(indices[i*3+2]);\n            wireframeIndices.push(indices[i*3]);\n        }\n\n        this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, wireframeBuffer);\n        this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(wireframeIndices), this.gl.STATIC_DRAW);\n    }\n\n    setColor(color: Color): void\n    {\n        this.color.copy(color);\n    }\n\n    getColor(): Color\n    {\n        return this.color;\n    }\n}", "import { Material3 } from './Material3';\nimport { WireframeMaterial } from './WireframeMaterial'\nimport { Camera } from '../core/Camera';\nimport { Node3 } from '../core/Node3'\nimport { LightManager } from '../lights/LightManager';\nimport { Color } from '../math/Color' \nimport { Mesh3 } from '../geometry/3d/Mesh3';\nimport { Geometry3Factory } from '../geometry/Geometry3Factory';\nimport { Line3 } from '../geometry/3d/Line3';\nimport { BoundingBox3 } from '../math/BoundingBox3';\nimport { Vector3 } from '../math/Vector3'\nimport { Quaternion } from '../math/Quaternion';\nimport { Matrix4 } from '../math/Matrix4';\n\nexport enum BoundingVolumeMode\n{\n    ORIENTED_BOUNDING_BOX,\n    AXIS_ALIGNED_BOUNDING_BOX,\n    BOUNDING_SPHERE\n}\n\nexport class BoundingVolumeMaterial extends Material3\n{\n    public mode: BoundingVolumeMode;\n    \n    public readonly color: Color;\n    public readonly wireframeMaterial: WireframeMaterial;\n\n    private sphere: Mesh3;\n    private box: Line3;\n    \n    constructor(mode = BoundingVolumeMode.ORIENTED_BOUNDING_BOX, color = new Color(1, 1, 1, 1))\n    {\n        super();\n\n        this.mode = mode;\n        this.color = Color.copy(color);\n\n        this.sphere = Geometry3Factory.createSphere(1, 1);\n\n        const boundingBox = new BoundingBox3();\n        boundingBox.max.set(0.5, 0.5, 0.5);\n        boundingBox.min.set(-0.5, -0.5, -0.5);\n\n        this.box = new Line3();\n        this.box.createFromBox(boundingBox);\n        this.box.color = this.color;\n\n        this.wireframeMaterial = new WireframeMaterial();\n        this.wireframeMaterial.color = this.color;\n        this.sphere.material = this.wireframeMaterial;\n    }\n\n    draw(object: Node3, camera: Camera, lightManager: LightManager): void\n    {\n        if(this.mode == BoundingVolumeMode.ORIENTED_BOUNDING_BOX)\n        {\n            const boxPosition = Vector3.add(object.boundingBox.min, object.boundingBox.max);\n            boxPosition.multiplyScalar(0.5);\n\n            const boxScale = new Vector3(\n                object.boundingBox.max.x - object.boundingBox.min.x,\n                object.boundingBox.max.y - object.boundingBox.min.y,\n                object.boundingBox.max.z - object.boundingBox.min.z\n            );\n            \n            const boxMatrix = Matrix4.makeScale(boxScale);\n            boxMatrix.mat[12] = boxPosition.x;\n            boxMatrix.mat[13] = boxPosition.y;\n            boxMatrix.mat[14] = boxPosition.z;\n\n            this.box.localToWorldMatrix.copy(boxMatrix);\n            this.box.localToWorldMatrix.premultiply(object.localToWorldMatrix);\n\n            this.box.draw(object, camera, lightManager);\n        }\n        else if(this.mode == BoundingVolumeMode.AXIS_ALIGNED_BOUNDING_BOX)\n        {\n            const abb = object.worldBoundingBox;\n\n            const boxPosition = Vector3.add(abb.min, abb.max);\n            boxPosition.multiplyScalar(0.5);\n\n            const boxScale = new Vector3(\n                abb.max.x - abb.min.x,\n                abb.max.y - abb.min.y,\n                abb.max.z - abb.min.z\n            );\n\n            const boxMatrix = Matrix4.makeScale(boxScale);\n            boxMatrix.mat[12] = boxPosition.x;\n            boxMatrix.mat[13] = boxPosition.y;\n            boxMatrix.mat[14] = boxPosition.z;\n\n            this.box.localToWorldMatrix.copy(boxMatrix);\n\n            this.box.draw(object, camera, lightManager);\n        }\n        else if(this.mode == BoundingVolumeMode.BOUNDING_SPHERE)\n        {\n            const sphereScale = new Vector3(object.boundingSphere.radius, object.boundingSphere.radius, object.boundingSphere.radius);\n\n            const sphereMatrix = Matrix4.makeScale(sphereScale);\n            sphereMatrix.mat[12] = object.boundingSphere.center.x;\n            sphereMatrix.mat[13] = object.boundingSphere.center.y;\n            sphereMatrix.mat[14] = object.boundingSphere.center.z;\n\n            this.sphere.localToWorldMatrix.copy(sphereMatrix);\n            this.sphere.localToWorldMatrix.premultiply(object.localToWorldMatrix);\n            this.sphere.draw(object, camera, lightManager);\n        }\n    }\n\n    setColor(color: Color): void\n    {\n        this.color.copy(color);\n    }\n\n    getColor(): Color\n    {\n        return this.color;\n    }\n}", "import { GfxApp } from '../core/GfxApp';\n\n/**\n * Represents an image texture\n * \n * @class Texture\n */\nexport class Texture\n{\n    private static numTextures = 0;\n\n    protected readonly gl: WebGL2RenderingContext;\n\n    /**\n     * The internal object used by WebGL to draw this texture\n     */\n    public texture: WebGLTexture | null;\n\n    /**\n     * The WebGL texture ID used to draw this texture\n     */\n    public id: number;\n\n    /** \n     * The width of the original (non-mipmapped) texture image data or 'undefined' if\n     * the image has not yet completed loading.\n     */\n    public width: number | undefined;\n\n    /** \n     * The height of the original (non-mipmapped) texture image data or 'undefined' if\n     * the image has not yet completed loading.\n     */\n    public height: number | undefined;\n\n    /**\n     * Create a new instance of a texture.\n     * \n     * @param url URL to load the texture from (can be absolute, e.g.\n     * \"http://unlikely-url.com/some-image.jpg\", or relative, e.g.\n     * \"./some-image.jpg\"). Can be null to start out with, in which case the\n     * texture will be empty.\n     */\n    constructor(source: string | null | ImageData = new ImageData(new Uint8ClampedArray([255, 0, 255, 255]), 1, 1))\n    {\n        this.gl  = GfxApp.getInstance().renderer.gl;\n\n        this.texture = this.gl.createTexture();\n        this.id = Texture.numTextures;\n        Texture.numTextures++;\n\n        this.gl.activeTexture(this.gl.TEXTURE0 + this.id);\n        this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture);\n        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.REPEAT);\n        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.REPEAT);\n        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.NEAREST_MIPMAP_LINEAR);\n        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);\n\n        if (source instanceof ImageData) {\n            this.width = source.width;\n            this.height = source.height;\n            this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.width, this.height, 0, this.gl.RGBA, \n                this.gl.UNSIGNED_BYTE, source.data);\n        } else if (typeof source == \"string\") {\n            this.width = undefined;\n            this.height = undefined;\n            this.load(source);\n        } else {\n            this.width = 1;\n            this.height = 1;\n            this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.width, this.height, 0, this.gl.RGBA, \n                this.gl.UNSIGNED_BYTE, new Uint8Array([255, 0, 255, 255]));  \n        }\n    }\n\n    /**\n     * Load an image into this texture.\n     * \n     * @param url URL to load the texture from (can be absolute, e.g.\n     * \"http://unlikely-url.com/some-image.jpg\", or relative, e.g.\n     * \"./some-image.jpg\"). Can be null to start out with, in which case the\n     * texture will be empty.\n     */\n    load(url: string): void\n    {\n        GfxApp.getInstance().assetManager.requestedAssets.push(url);\n\n        const image = new Image();\n        image.addEventListener('load', (event: Event)=>{ this.imageLoaded(image, url) }, false);\n        image.addEventListener('error', (event: Event)=>{ this.imageNotFound(url) }, false);\n        image.src = url;\n    }\n\n    /**\n     * Callback function for image loaded events\n     * \n     * @param image HTML DOM image element produced by loading the image texture\n     * @param url Original URL the image was loaded from (used as an internal identifier for the image asset)\n     */\n    imageLoaded(image: HTMLImageElement, url: string): void\n    {\n        GfxApp.getInstance().assetManager.loadedAssets.push(url);\n\n        this.width = image.width;\n        this.height = image.height;\n        this.gl.activeTexture(this.gl.TEXTURE0 + this.id);\n        this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture);\n        this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, image);\n        this.gl.generateMipmap(this.gl.TEXTURE_2D);\n    }\n\n    /**\n     * Copies the pixel data from an ImageData source into the texture\n     * \n     * @param imageData An ImageData object with the same width and height as the texture\n     */\n    setFullImageData(imageData: ImageData): void\n    {\n        this.gl.activeTexture(this.gl.TEXTURE0 + this.id);\n        this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture);\n        this.gl.texSubImage2D(this.gl.TEXTURE_2D, 0, 0, 0, imageData.width, imageData.height, this.gl.RGBA, this.gl.UNSIGNED_BYTE, imageData.data);\n        this.gl.generateMipmap(this.gl.TEXTURE_2D);\n    }\n\n    /**\n     * Copies the pixel data from an ImageData source into a portion of the texture, placing it as a sub-image within the texture\n     * \n     * @param imageData An ImageData object with width and height that are the same size or smaller than the texture\n     * @param xOffset An offset in the x-direction within the texture where the top-left corner of imageData should be placed\n     * @param yOffset An offset in the y-direction within the texture where the top-left corner of imageData should be placed\n     */\n    setSubImageData(imageData: ImageData, xOffset: number, yOffset: number): void\n    {\n        this.gl.activeTexture(this.gl.TEXTURE0 + this.id);\n        this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture);\n        this.gl.texSubImage2D(this.gl.TEXTURE_2D, 0, xOffset, yOffset, imageData.width, imageData.height, this.gl.RGBA, this.gl.UNSIGNED_BYTE, imageData.data);\n        this.gl.generateMipmap(this.gl.TEXTURE_2D);\n    }\n\n    /**\n     * Callback function for when the requested image cannot be found (load error)\n     * \n     * @param url Original URL the image was loaded from (used as an internal identifier for the errored image asset)\n     */\n    imageNotFound(url: string): void\n    {\n        GfxApp.getInstance().assetManager.errorAssets.push(url);\n    }\n\n    /**\n     * Control the minification filter (sampling if a texture is shown at less than its original size)\n     * \n     * @param linear Use linear filtering\n     * @param mipmap Use mipmapping\n     */\n    setMinFilter(linear: boolean, mipmap: boolean)\n    {\n        this.gl.activeTexture(this.gl.TEXTURE0 + this.id);\n\n        if(linear)\n        {\n            if(mipmap)\n                this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.NEAREST_MIPMAP_LINEAR);\n            else\n                this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);\n        }\n        else\n        {\n            if(mipmap)\n                this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.NEAREST_MIPMAP_NEAREST);\n            else\n                this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.NEAREST);\n        }\n    }\n\n    /**\n     * Control the magnification filter (sampling if a texture is shown at greater than its original size)\n     * \n     * @param linear Use linear filtering\n     */\n    setMagFilter(linear: boolean)\n    {\n        this.gl.activeTexture(this.gl.TEXTURE0 + this.id);\n\n        if(linear)\n            this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);\n        else\n            this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.NEAREST);\n    }\n\n    /**\n     * Set the wrapping mode for the texture.\n     * \n     * @param repeat Repeat the texture beyond its bounds or just show it once\n     */\n    setWrapping(repeat: boolean)\n    {\n        this.gl.activeTexture(this.gl.TEXTURE0 + this.id);\n        \n        if(repeat)\n        {\n            this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.REPEAT);\n            this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.REPEAT);\n        }\n        else\n        {\n            this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);\n            this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);\n        }\n    }\n}", "import { Texture } from './Texture'\nimport { Color } from '../math/Color'\n\nexport class Text extends Texture\n{\n    public text: string;\n    public font: string;\n    public fillStyleString: string;\n    public strokeStyleString: string;\n    public backgroundStyleString: string;\n    public align: CanvasTextAlign;\n    public baseline: CanvasTextBaseline;\n\n    public width: number;\n    public height: number;\n    public strokeWidth: number;\n\n    private textCanvas: CanvasRenderingContext2D | null;\n\n/**\n * Constructor for Text class. The text is rendered using the browser's canvas element and\n * then copyied into a texture, so the parameters are based on what is understood by\n * [CanvasRenderingContext2D](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D).\n * Shortcuts are provided for fillStyle, backgroundStyle, and strokeStyle to use the gfx.Color\n * types if that is more convenient for your application.\n * \n * @param text - The text to be rendered\n * @param width - The width of the text canvas\n * @param height - The height of the text canvas\n * @param font - The font style of the text. Can be a gfx.Color or see additional options for\n * [canvas.font](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/font).\n * @param fillStyle - The fill style of the text. Can be a gfx.Color or see additional options for\n * [canvas.fillStyle](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/fillStyle).\n * @param backgroundStyle - The fill style of the background. Can be a gfx.Color or see additional options for\n * [canvas.fillStyle](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/fillStyle).\n * @param strokeStyle - The stroke style of the text. Can be a gfx.Color or see additional options for\n * [canvas.strokeStyle](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/strokeStyle).\n * @param strokeWidth - The stroke width of the text. \n * @param align - The alignment of the text.  See possible values in \n * [canvas.textAlign](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/textAlign)\n * @param baseline - The baseline of the text.  See possible values in\n * [canvas.textBaseline](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/textBaseline).\n */\n    constructor(text: string, width: number, height: number, font = '24px monospace', \n                fillStyle: string | Color = 'black', backgroundStyle: string | Color = '', strokeStyle: string | Color = '', strokeWidth = 1,\n                align: CanvasTextAlign = 'center', baseline: CanvasTextBaseline = 'middle')\n    {\n        super();\n\n        this.text = text;\n        this.width = width;\n        this.height = height;\n        this.font = font;\n        if (fillStyle instanceof Color) {\n            this.fillStyleString = \"rgb(\" + fillStyle.r * 255 + \" \" + fillStyle.g * 255 + \" \" + fillStyle.b * 255 + \" / \" + fillStyle.a * 255 + \")\";\n        } else {\n            this.fillStyleString = fillStyle;\n        }\n        if (backgroundStyle instanceof Color) {\n            this.backgroundStyleString = \"rgb(\" + backgroundStyle.r * 255 + \" \" + backgroundStyle.g * 255 + \" \" + backgroundStyle.b * 255 + \" / \" + backgroundStyle.a * 255 + \")\";\n        } else {\n            this.backgroundStyleString = backgroundStyle;\n        }\n        if (strokeStyle instanceof Color) {\n            this.strokeStyleString = \"rgb(\" + strokeStyle.r * 255 + \" \" + strokeStyle.g * 255 + \" \" + strokeStyle.b * 255 + \" / \" + strokeStyle.a * 255 + \")\";\n        } else {\n            this.strokeStyleString = strokeStyle;\n        }\n        this.strokeWidth = strokeWidth;\n        this.align = align;\n        this.baseline = baseline;\n        \n        this.textCanvas = document.createElement('canvas').getContext('2d');\n        this.updateTextureImage();\n    }\n\n/**\n * Updates the texture image of the Text class\n * \n * Sets the width and height of the canvas, font, text alignment, and baseline.\n * Fills the canvas with the background style if specified.\n * Fills the text with the fill style if specified.\n * Strokes the text with the stroke style and stroke width if specified.\n * Binds the texture and generated mipmap.\n */\n    public updateTextureImage(): void\n    {\n        if(this.textCanvas)\n        {   \n            this.textCanvas.canvas.width = this.width;\n            this.textCanvas.canvas.height = this.height;\n            this.textCanvas.font = this.font;\n            this.textCanvas.textAlign = this.align;\n            this.textCanvas.textBaseline = this.baseline;\n\n            this.textCanvas.clearRect(0, 0, this.width, this.height);\n\n            if(this.backgroundStyleString != '')\n            {\n                this.textCanvas.fillStyle = this.backgroundStyleString;\n                this.textCanvas.fillRect(0, 0, this.width, this.height);\n            }\n\n            if(this.fillStyleString != '')\n            {\n                this.textCanvas.fillStyle = this.fillStyleString;\n                this.textCanvas.fillText(this.text, this.width / 2, this.height / 2);\n            }\n\n            if(this.strokeStyleString != '' && this.strokeWidth > 0)\n            {\n                this.textCanvas.strokeStyle = this.strokeStyleString;\n                this.textCanvas.lineWidth = this.strokeWidth;\n                this.textCanvas.strokeText(this.text, this.width / 2, this.height / 2);\n            }\n\n            this.gl.activeTexture(this.gl.TEXTURE0 + this.id);\n            this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture);\n            this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, this.textCanvas.canvas);\n            this.gl.generateMipmap(this.gl.TEXTURE_2D);\n        }\n    }\n}", "import { MathUtils } from './MathUtils';\nimport { Vector3 } from './Vector3'\n\nexport class LinearPath3\n{\n    public controlPoints: Vector3[];\n\n/**\n * Constructs a new LinearPath3 object\n */\n    constructor()\n    {\n        this.controlPoints = [];\n    }\n\n/**\n * Calculates a point along the linear path\n * \n * @param segment - The segment index of the linear path\n * @param t - A float value in the range [0, 1]\n * @returns The calculated point, or null if the segment index is out of bounds\n */\n    getPoint(segment: number, t: number): Vector3 | null\n    {\n        if(segment < this.controlPoints.length - 1)\n        {\n            return Vector3.lerp(this.controlPoints[segment], this.controlPoints[segment+1], MathUtils.clamp(t, 0, 1));\n        }\n        else\n        {\n            return null;\n        }\n    }\n}", "import { MathUtils } from './MathUtils';\nimport { Vector3 } from './Vector3'\n\n// Smooth path generated using a Catmull-Rom spline\n// https://qroph.github.io/2018/07/30/smooth-paths-using-catmull-rom-splines.html\n// https://en.wikipedia.org/wiki/Centripetal_Catmull%E2%80%93Rom_spline\n\nexport class CurvePath3\n{\n    public controlPoints: Vector3[];\n    public alpha: number;\n    public tension: number;\n\n/**\n * Constructs a CurvePath3 object with the given alpha and tension values\n * \n * @param alpha - The alpha value for the curve\n * @param tension - The tension value for the curve\n */\n    constructor(alpha = 0.5, tension = 0)\n    {\n        this.controlPoints = [];\n        this.alpha = alpha;\n        this.tension = tension;\n    }\n\n/**\n * Computes a point on the curve from the given segment and parameter values\n * \n * @param segment - The segment to calculate the point from\n * @param t - The parameter value from 0-1 to calculate the point from\n * @returns The point on the curve at the given segment and parameter value, or null if the segment is out of range\n */    \n    getPoint(segment: number, t: number): Vector3 | null\n    {\n        if(segment == 0)\n        {\n            const v = Vector3.subtract(this.controlPoints[segment+1], this.controlPoints[segment]);\n            const firstPoint = Vector3.subtract(this.controlPoints[segment], v);\n            \n            return this.computePoint(\n                firstPoint,\n                this.controlPoints[segment],\n                this.controlPoints[segment+1],\n                this.controlPoints[segment+2],\n                MathUtils.clamp(t, 0, 1)\n            );\n        }\n        if(segment < this.controlPoints.length - 2)\n        {\n            return this.computePoint(\n                this.controlPoints[segment-1],\n                this.controlPoints[segment],\n                this.controlPoints[segment+1],\n                this.controlPoints[segment+2],\n                MathUtils.clamp(t, 0, 1)\n            );\n        }\n        else if(segment == this.controlPoints.length - 2)\n        {\n            const v = Vector3.subtract(this.controlPoints[segment+1], this.controlPoints[segment]);\n            const lastPoint = Vector3.add(this.controlPoints[segment+1], v);\n\n            return this.computePoint(\n                this.controlPoints[segment-1],\n                this.controlPoints[segment],\n                this.controlPoints[segment+1],\n                lastPoint,\n                MathUtils.clamp(t, 0, 1)\n            );\n        }\n        else if(segment == this.controlPoints.length - 1)\n        {\n            const v = Vector3.subtract(this.controlPoints[segment], this.controlPoints[segment-1]);\n            const secondToLastPoint = Vector3.add(this.controlPoints[segment], v);\n            const lastPoint = Vector3.add(secondToLastPoint, v);\n\n            return this.computePoint(\n                this.controlPoints[segment-1],\n                this.controlPoints[segment],\n                secondToLastPoint,\n                lastPoint,\n                MathUtils.clamp(t, 0, 1)\n            );\n        }\n        else\n        {\n            return null;\n        }\n    }\n\n\n/**\n * Computes a point on the curve from the given control points and parameter values\n * \n * @param p0 - The first control point\n * @param p1 - The second control point\n * @param p2 - The third control point\n * @param p3 - The fourth control point\n * @param t - The parameter value from 0-1 to calculate the point from\n * @returns The point on the curve at the given control points and parameter value\n */\n    private computePoint(p0: Vector3, p1: Vector3, p2: Vector3, p3: Vector3, t: number): Vector3\n    {\n        const t01 = Math.pow(p0.distanceTo(p1), this.alpha);\n        const t12 = Math.pow(p1.distanceTo(p2), this.alpha);\n        const t23 = Math.pow(p2.distanceTo(p3), this.alpha);\n\n        const p1p0 = Vector3.subtract(p1, p0);\n        const p1p2 = Vector3.subtract(p1, p2);\n        const p2p0 = Vector3.subtract(p2, p0);\n        const p2p1 = Vector3.subtract(p2, p1);\n        const p3p1 = Vector3.subtract(p3, p1);\n        const p3p2 = Vector3.subtract(p3, p2);\n\n        const m1 = Vector3.multiplyScalar(p1p0, 1 / t01);\n        m1.subtract(Vector3.multiplyScalar(p2p0, 1 / (t01 + t12)));\n        m1.multiplyScalar(t12);\n        m1.add(p2p1);\n        m1.multiplyScalar(1 - this.tension);\n\n        const m2 = Vector3.multiplyScalar(p3p2, 1 / t23);\n        m2.subtract(Vector3.multiplyScalar(p3p1, 1 / (t12 +  t23)));\n        m2.multiplyScalar(t12);\n        m2.add(p2p1);\n        m2.multiplyScalar(1 - this.tension);\n\n        const a = Vector3.multiplyScalar(p1p2, 2);\n        a.add(m1);\n        a.add(m2);\n\n        const b = Vector3.multiplyScalar(p1p2, -3);\n        b.subtract(m1);\n        b.subtract(m1);\n        b.subtract(m2);\n\n        const c = m1;\n        const d = p1;\n\n        const result = Vector3.multiplyScalar(a, t * t * t);\n        result.add(Vector3.multiplyScalar(b, t * t));\n        result.add(Vector3.multiplyScalar(c, t));\n        result.add(d);\n\n        return result;\n    }\n}", "import { MathUtils } from './MathUtils';\nimport { Vector2 } from './Vector2'\n\nexport class LinearPath2\n{\n    /**\n     * An array of Vector2 objects representing the control points of the path\n     */\n    public controlPoints: Vector2[];\n\n    /**\n     * Constructor for the LinearPath2 class\n     */\n    constructor()\n    {\n        this.controlPoints = [];\n    }\n\n    /**\n     * Gets the point at a given distance along the path\n     * \n     * @param segment - The segment index\n     * @param t - The value (between 0 and 1) along the segment to get the point\n     * @returns The point at the given distance on the path, or null if the segment index is out of bounds\n     */\n    getPoint(segment: number, t: number): Vector2 | null\n    {\n        if(segment < this.controlPoints.length - 1)\n        {\n            return Vector2.lerp(this.controlPoints[segment], this.controlPoints[segment+1], MathUtils.clamp(t, 0, 1));\n        }\n        else\n        {\n            return null;\n        }\n    }\n}", "import { MathUtils } from './MathUtils';\nimport { Vector2 } from './Vector2'\n\n// Smooth path generated using a Catmull-Rom spline\n// https://qroph.github.io/2018/07/30/smooth-paths-using-catmull-rom-splines.html\n// https://en.wikipedia.org/wiki/Centripetal_Catmull%E2%80%93Rom_spline\n\nexport class CurvePath2\n{\n    public controlPoints: Vector2[];\n    public alpha: number;\n    public tension: number;\n\n    /** \n     * Constructor for the CurvePath2 class.\n     * \n     * @param alpha - The alpha parameter for the curve calculation (default 0.5)\n     * @param tension - The tension parameter for the curve calculation (default 0) \n     */\n    constructor(alpha = 0.5, tension = 0)\n    {\n        this.controlPoints = [];\n        this.alpha = alpha;\n        this.tension = tension;\n    }\n\n    /**\n     * Computes a point on the curve at a given segment and t value.\n     * \n     * @param segment - The index of the control point of the segment\n     * @param t - The parameter t in the range [0,1]\n     * @returns The point on the curve at the specified segment and t value\n     */\n    getPoint(segment: number, t: number): Vector2 | null\n    {\n        if(segment == 0)\n        {\n            const v = Vector2.subtract(this.controlPoints[segment+1], this.controlPoints[segment]);\n            const firstPoint = Vector2.subtract(this.controlPoints[segment], v);\n            \n            return this.computePoint(\n                firstPoint,\n                this.controlPoints[segment],\n                this.controlPoints[segment+1],\n                this.controlPoints[segment+2],\n                MathUtils.clamp(t, 0, 1)\n            );\n        }\n        if(segment < this.controlPoints.length - 2)\n        {\n            return this.computePoint(\n                this.controlPoints[segment-1],\n                this.controlPoints[segment],\n                this.controlPoints[segment+1],\n                this.controlPoints[segment+2],\n                MathUtils.clamp(t, 0, 1)\n            );\n        }\n        else if(segment == this.controlPoints.length - 2)\n        {\n            const v = Vector2.subtract(this.controlPoints[segment+1], this.controlPoints[segment]);\n            const lastPoint = Vector2.add(this.controlPoints[segment+1], v);\n\n            return this.computePoint(\n                this.controlPoints[segment-1],\n                this.controlPoints[segment],\n                this.controlPoints[segment+1],\n                lastPoint,\n                MathUtils.clamp(t, 0, 1)\n            );\n        }\n        else if(segment == this.controlPoints.length - 1)\n        {\n            const v = Vector2.subtract(this.controlPoints[segment], this.controlPoints[segment-1]);\n            const secondToLastPoint = Vector2.add(this.controlPoints[segment], v);\n            const lastPoint = Vector2.add(secondToLastPoint, v);\n\n            return this.computePoint(\n                this.controlPoints[segment-1],\n                this.controlPoints[segment],\n                secondToLastPoint,\n                lastPoint,\n                MathUtils.clamp(t, 0, 1)\n            );\n        }\n        else\n        {\n            return null;\n        }\n    }\n\n\n    /**\n     * Computes a point on a CurvePath2 based on the given parameters\n     * \n     * @param p0 - The first Vector2 object\n     * @param p1 - The second Vector2 object\n     * @param p2 - The third Vector2 object\n     * @param p3 - The fourth Vector2 object\n     * @param t - The t value used to calculate the point\n     * @returns The Vector2 that represents the point on the CurvePath2\n     */\n    private computePoint(p0: Vector2, p1: Vector2, p2: Vector2, p3: Vector2, t: number): Vector2\n    {\n        const t01 = Math.pow(p0.distanceTo(p1), this.alpha);\n        const t12 = Math.pow(p1.distanceTo(p2), this.alpha);\n        const t23 = Math.pow(p2.distanceTo(p3), this.alpha);\n\n        const p1p0 = Vector2.subtract(p1, p0);\n        const p1p2 = Vector2.subtract(p1, p2);\n        const p2p0 = Vector2.subtract(p2, p0);\n        const p2p1 = Vector2.subtract(p2, p1);\n        const p3p1 = Vector2.subtract(p3, p1);\n        const p3p2 = Vector2.subtract(p3, p2);\n\n        const m1 = Vector2.multiplyScalar(p1p0, 1 / t01);\n        m1.subtract(Vector2.multiplyScalar(p2p0, 1 / (t01 + t12)));\n        m1.multiplyScalar(t12);\n        m1.add(p2p1);\n        m1.multiplyScalar(1 - this.tension);\n\n        const m2 = Vector2.multiplyScalar(p3p2, 1 / t23);\n        m2.subtract(Vector2.multiplyScalar(p3p1, 1 / (t12 +  t23)));\n        m2.multiplyScalar(t12);\n        m2.add(p2p1);\n        m2.multiplyScalar(1 - this.tension);\n\n        const a = Vector2.multiplyScalar(p1p2, 2);\n        a.add(m1);\n        a.add(m2);\n\n        const b = Vector2.multiplyScalar(p1p2, -3);\n        b.subtract(m1);\n        b.subtract(m1);\n        b.subtract(m2);\n\n        const c = m1;\n        const d = p1;\n\n        const result = Vector2.multiplyScalar(a, t * t * t);\n        result.add(Vector2.multiplyScalar(b, t * t));\n        result.add(Vector2.multiplyScalar(c, t));\n        result.add(d);\n\n        return result;\n    }\n}"],
  "mappings": "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",
  "names": ["g", "c", "m", "w", "y", "y", "Viewport", "q", "u", "m", "w", "y", "z", "q", "y", "z", "m", "u", "w", "m", "y", "z", "p", "w", "c", "d", "f", "m", "p", "m", "IntersectionMode3", "CoordinateSpace3", "m", "w", "c", "d", "m", "m", "IntersectionMode2", "CoordinateSpace2", "material2_default", "LineMode2", "Side", "gouraud_default", "j", "k", "unlit_default", "LineMode3", "u", "j", "k", "morph_default", "particles2_default", "l", "h", "f", "u", "q", "LightType", "j", "document", "EventDispatcher", "_listeners", "addEventListener", "type", "listener", "listeners", "undefined", "indexOf", "push", "removeEventListener", "listenerArray", "index", "splice", "dispatchEvent", "event", "array", "slice", "i", "l", "length", "call", "dispose", "key", "GraphEdge", "constructor", "_name", "_parent", "_child", "_attributes", "_disposed", "isOnGraph", "Error", "getName", "getParent", "getChild", "setChild", "child", "getAttributes", "target", "isDisposed", "Graph", "_emptySet", "Set", "_edges", "_parentEdges", "Map", "_childEdges", "listEdges", "Array", "from", "listParentEdges", "node", "get", "listParents", "map", "edge", "listChildEdges", "listChildren", "disconnectParents", "filter", "edges", "forEach", "createEdge", "name", "a", "b", "attributes", "_registerEdge", "add", "parent", "has", "set", "_removeEdge", "delete", "isRef", "value", "isRefList", "isArray", "isRefMap", "isPlainObject", "getFirstValue", "Boolean", "Object", "getPrototypeOf", "prototype", "$attributes", "Symbol", "$immutableKeys", "GraphNode", "graph", "_createAttributes", "getDefaults", "defaultAttributes", "ref", "other", "detach", "swap", "old", "replacement", "attribute", "setRef", "refs", "find", "refAttributes", "removeRef", "addRef", "refMap", "setRefMap", "getRef", "prevRef", "listRefs", "pruned", "listRefMapKeys", "keys", "listRefMapValues", "values", "getRefMap", "metadata", "assign", "VERSION", "GLB_BUFFER", "PropertyType", "VertexLayout", "BufferViewUsage", "TextureChannel", "Format", "ComponentTypeToTypedArray", "Int8Array", "Uint8Array", "Int16Array", "Uint16Array", "Uint32Array", "Float32Array", "out", "ARRAY_TYPE", "Array", "length", "a", "Math", "hypot", "Math", "hypot", "y", "i", "arguments", "length", "sqrt", "out", "glMatrix.ARRAY_TYPE", "Float32Array", "BufferUtils", "dataURI", "Buffer", "byteString", "atob", "split", "ia", "Uint8Array", "length", "i", "charCodeAt", "data", "isBase64", "indexOf", "from", "text", "TextEncoder", "encode", "array", "TextDecoder", "decode", "toString", "arrays", "totalByteLength", "byteLength", "result", "byteOffset", "set", "srcArray", "paddingByte", "paddedLength", "this", "padNumber", "dstArray", "v", "Math", "ceil", "a", "b", "Infinity", "buffer", "min", "view", "ArrayBuffer", "isView", "Error", "ColorUtils", "hex", "target", "floor", "_target", "convertSRGBToLinear", "factor", "r", "g", "convertLinearToSRGB", "source", "_source", "pow", "PNGImageUtils", "match", "getSize", "DataView", "decodeText", "slice", "PNG_FRIED_CHUNK_NAME", "getUint32", "getChannels", "_buffer", "ImageUtils", "mimeType", "impl", "impls", "getVRAMByteLength", "uncompressedBytes", "resolution", "max", "pop", "extension", "validateJPEGBuffer", "TypeError", "getUint8", "next", "getUint16", "FileUtils", "uri", "fileName", "substring", "lastIndexOf", "startsWith", "mimeTypeToExtension", "isObject", "o", "Object", "prototype", "call", "isPlainObject", "ctor", "constructor", "prot", "hasOwnProperty", "Verbosity", "Logger", "verbosity", "debug", "DEBUG", "console", "info", "INFO", "warn", "WARN", "error", "ERROR", "multiply", "out", "a00", "a01", "a02", "a03", "a10", "a11", "a12", "a13", "a20", "a21", "a22", "a23", "a30", "a31", "a32", "a33", "b0", "b1", "b2", "b3", "DEFAULT_INSTANCE", "MathUtils", "tolerance", "abs", "c", "componentType", "decodeNormalizedInt", "f", "round", "encodeNormalizedInt", "srcMat", "dstTranslation", "dstRotation", "dstScale", "sx", "sy", "sz", "_m1", "invSX", "invSY", "invSZ", "mat", "scaling", "glMatrix.ARRAY_TYPE", "m21", "m22", "m23", "m31", "m32", "m33", "hypot", "is1", "is2", "is3", "sm11", "sm12", "sm13", "sm21", "sm22", "sm23", "sm31", "sm32", "sm33", "trace", "S", "sqrt", "srcTranslation", "srcRotation", "srcScale", "dstMat", "te", "x", "y", "z", "w", "x2", "y2", "z2", "xx", "xy", "xz", "yy", "yz", "zz", "wx", "wy", "wz", "equalsRef", "refA", "refB", "getChild", "equals", "equalsRefList", "refListA", "refListB", "equalsRefMap", "refMapA", "refMapB", "keysA", "keys", "keysB", "key", "equalsArray", "equalsObject", "_a", "_b", "numKeysA", "numKeysB", "valueA", "valueB", "isArray", "value", "Array", "previousIDs", "Set", "generateOne", "rtn", "charAt", "ALPHABET", "random", "uuid", "retries", "id", "has", "add", "NULL_DOMAIN", "HTTPUtils", "path", "index", "basename", "URL", "pathname", "base", "isRelativePath", "stack", "parts", "push", "join", "PROTOCOL_REGEXP", "test", "DEFAULT_INIT", "COPY_IDENTITY", "t", "EMPTY_SET", "Property", "GraphNode", "graph", "name", "super", "$attributes", "init", "dispatchEvent", "type", "getGraph", "getDefaults", "assign", "extras", "attribute", "getName", "get", "setName", "getExtras", "setExtras", "clone", "PropertyClass", "copy", "other", "resolve", "GraphEdge", "$immutableKeys", "dispose", "isRefList", "ref", "isRefMap", "subkey", "thisValue", "otherValue", "setRef", "getAttributes", "addRef", "setRefMap", "JSON", "parse", "stringify", "skip", "propertyType", "isRef", "detach", "disconnectParents", "n", "listParents", "ExtensibleProperty", "extensions", "getExtension", "getRefMap", "setExtension", "extensionProperty", "_validateParent", "listExtensions", "listRefMapValues", "Accessor", "args", "_in", "identity", "_out", "PropertyType", "ACCESSOR", "Type", "SCALAR", "ComponentType", "FLOAT", "normalized", "sparse", "VEC2", "VEC3", "VEC4", "MAT2", "MAT3", "MAT4", "BYTE", "UNSIGNED_BYTE", "SHORT", "UNSIGNED_SHORT", "UNSIGNED_INT", "getMinNormalized", "elementSize", "getElementSize", "getMin", "j", "count", "getCount", "Number", "isFinite", "getMaxNormalized", "getMax", "getType", "setType", "getComponentSize", "BYTES_PER_ELEMENT", "getComponentType", "getNormalized", "setNormalized", "getScalar", "setScalar", "getElement", "setElement", "getSparse", "setSparse", "getBuffer", "getRef", "setBuffer", "getArray", "setArray", "Float32Array", "Uint32Array", "Uint16Array", "Int16Array", "Int8Array", "getByteLength", "Animation", "ANIMATION", "channels", "samplers", "addChannel", "channel", "removeChannel", "removeRef", "listChannels", "listRefs", "addSampler", "sampler", "removeSampler", "listSamplers", "AnimationChannel", "ANIMATION_CHANNEL", "targetPath", "targetNode", "getTargetPath", "setTargetPath", "getTargetNode", "setTargetNode", "getSampler", "setSampler", "TargetPath", "TRANSLATION", "ROTATION", "SCALE", "WEIGHTS", "AnimationSampler", "ANIMATION_SAMPLER", "getDefaultAttributes", "interpolation", "Interpolation", "LINEAR", "input", "output", "getInterpolation", "setInterpolation", "getInput", "setInput", "usage", "BufferViewUsage", "OTHER", "getOutput", "setOutput", "STEP", "CUBICSPLINE", "BUFFER", "getURI", "setURI", "Camera", "CAMERA", "PERSPECTIVE", "znear", "zfar", "aspectRatio", "yfov", "PI", "xmag", "ymag", "getZNear", "setZNear", "getZFar", "setZFar", "getAspectRatio", "setAspectRatio", "getYFov", "setYFov", "getXMag", "setXMag", "getYMag", "setYMag", "ORTHOGRAPHIC", "ExtensionProperty", "parent", "parentTypes", "includes", "EXTENSION_NAME", "TextureInfo", "TEXTURE_INFO", "texCoord", "magFilter", "minFilter", "wrapS", "WrapMode", "REPEAT", "wrapT", "getTexCoord", "setTexCoord", "getMagFilter", "setMagFilter", "getMinFilter", "setMinFilter", "getWrapS", "setWrapS", "getWrapT", "setWrapT", "CLAMP_TO_EDGE", "MIRRORED_REPEAT", "MagFilter", "NEAREST", "MinFilter", "NEAREST_MIPMAP_NEAREST", "LINEAR_MIPMAP_NEAREST", "NEAREST_MIPMAP_LINEAR", "LINEAR_MIPMAP_LINEAR", "R", "G", "B", "A", "TextureChannel", "Material", "MATERIAL", "alphaMode", "AlphaMode", "OPAQUE", "alphaCutoff", "doubleSided", "baseColorFactor", "baseColorTexture", "baseColorTextureInfo", "emissiveFactor", "emissiveTexture", "emissiveTextureInfo", "normalScale", "normalTexture", "normalTextureInfo", "occlusionStrength", "occlusionTexture", "occlusionTextureInfo", "roughnessFactor", "metallicFactor", "metallicRoughnessTexture", "metallicRoughnessTextureInfo", "getDoubleSided", "setDoubleSided", "getAlpha", "setAlpha", "alpha", "getAlphaMode", "setAlphaMode", "getAlphaCutoff", "setAlphaCutoff", "getBaseColorFactor", "setBaseColorFactor", "getBaseColorHex", "factorToHex", "setBaseColorHex", "hexToFactor", "getBaseColorTexture", "getBaseColorTextureInfo", "setBaseColorTexture", "texture", "isColor", "getEmissiveFactor", "setEmissiveFactor", "getEmissiveHex", "setEmissiveHex", "getEmissiveTexture", "getEmissiveTextureInfo", "setEmissiveTexture", "getNormalScale", "setNormalScale", "scale", "getNormalTexture", "getNormalTextureInfo", "setNormalTexture", "getOcclusionStrength", "setOcclusionStrength", "strength", "getOcclusionTexture", "getOcclusionTextureInfo", "setOcclusionTexture", "getRoughnessFactor", "setRoughnessFactor", "getMetallicFactor", "setMetallicFactor", "getMetallicRoughnessTexture", "getMetallicRoughnessTextureInfo", "setMetallicRoughnessTexture", "MASK", "BLEND", "Mesh", "MESH", "weights", "primitives", "addPrimitive", "primitive", "removePrimitive", "listPrimitives", "getWeights", "setWeights", "Node", "_parentNode", "_parentScenes", "NODE", "translation", "rotation", "camera", "mesh", "skin", "children", "getTranslation", "getRotation", "getScale", "setTranslation", "setRotation", "setScale", "getMatrix", "compose", "setMatrix", "matrix", "decompose", "getWorldTranslation", "getWorldMatrix", "getWorldRotation", "getWorldScale", "s", "ancestors", "node", "ancestor", "worldMatrix", "addChild", "child", "removeChild", "size", "scene", "childrenRefs", "addEventListener", "listChildren", "getParent", "find", "SCENE", "getParentNode", "getMesh", "setMesh", "getCamera", "setCamera", "getSkin", "setSkin", "traverse", "fn", "Primitive", "PRIMITIVE", "mode", "Mode", "TRIANGLES", "material", "indices", "attributes", "targets", "getIndices", "setIndices", "ELEMENT_ARRAY_BUFFER", "getAttribute", "semantic", "setAttribute", "accessor", "ARRAY_BUFFER", "listAttributes", "listSemantics", "listRefMapKeys", "getMaterial", "setMaterial", "getMode", "setMode", "listTargets", "addTarget", "removeTarget", "POINTS", "LINES", "LINE_LOOP", "LINE_STRIP", "TRIANGLE_STRIP", "TRIANGLE_FAN", "PrimitiveTarget", "PRIMITIVE_TARGET", "Scene", "delete", "Skin", "SKIN", "skeleton", "inverseBindMatrices", "joints", "getSkeleton", "setSkeleton", "getInverseBindMatrices", "setInverseBindMatrices", "INVERSE_BIND_MATRICES", "addJoint", "joint", "removeJoint", "listJoints", "Texture", "TEXTURE", "image", "getMimeType", "extensionToMimeType", "setMimeType", "getImage", "setImage", "assertView", "Root", "ROOT", "asset", "generator", "VERSION", "version", "defaultScene", "accessors", "animations", "buffers", "cameras", "materials", "meshes", "nodes", "scenes", "skins", "textures", "_extensions", "event", "_addChildOfRoot", "_extends", "setDefaultScene", "getDefaultScene", "extensionName", "otherExtension", "getAsset", "listExtensionsUsed", "listExtensionsRequired", "filter", "isRequired", "_enableExtension", "_disableExtension", "listScenes", "listNodes", "listCameras", "listSkins", "listMeshes", "listMaterials", "listTextures", "listAnimations", "listAccessors", "listBuffers", "Document", "_GRAPH_DOCUMENTS", "_graph", "Graph", "_root", "_logger", "getRoot", "getLogger", "setLogger", "logger", "merge", "thisExtension", "createExtension", "setRequired", "visited", "propertyMap", "Map", "edge", "listEdges", "otherProp", "thisProp", "p", "resolved", "transforms", "map", "transform", "ext", "createScene", "createNode", "createCamera", "createSkin", "createMesh", "createPrimitive", "createPrimitiveTarget", "createMaterial", "createTexture", "createAnimation", "createAnimationChannel", "createAnimationSampler", "createAccessor", "createBuffer", "WeakMap", "Extension", "document", "prereadTypes", "prewriteTypes", "readDependencies", "writeDependencies", "required", "properties", "_listener", "_event", "_addExtensionProperty", "_removeExtensionProperty", "removeEventListener", "property", "register", "listProperties", "install", "dependency", "preread", "_readerContext", "_propertyType", "prewrite", "_writerContext", "ReaderContext", "jsonDoc", "bufferViews", "bufferViewBuffers", "textureInfos", "setTextureInfo", "textureInfo", "textureInfoDef", "textureDef", "json", "samplerDef", "DEFAULT_OPTIONS", "dependencies", "GLTFReader", "_options", "options", "validate", "context", "assetDef", "copyright", "extensionsUsed", "extensionsRequired", "bufferDefs", "forEach", "bufferDef", "bufferViewDef", "toView", "resources", "GLB_BUFFER", "accessorDefs", "accessorDef", "bufferView", "getAccessorArray", "imageDefs", "images", "textureDefs", "imageDef", "imageData", "materialDef", "pbrDef", "pbrMetallicRoughness", "meshDefs", "meshDef", "primitiveDef", "entries", "targetNames", "targetDef", "targetIndex", "targetName", "accessorIndex", "cameraDef", "perspectiveDef", "perspective", "orthoDef", "orthographic", "nodeDefs", "nodeDef", "skinDef", "nodeIndex", "childIndex", "animationDef", "animation", "channelDef", "sceneDefs", "sceneDef", "read", "hasSparseValues", "isZeroFilled", "TypedArray", "ComponentTypeToTypedArray", "sparseDef", "indicesDef", "valuesDef", "values", "componentSize", "byteStride", "accessorByteOffset", "getFloat32", "getInt16", "getInt8", "BufferViewTarget", "WriterContext", "_doc", "accessorIndexMap", "animationIndexMap", "bufferIndexMap", "cameraIndexMap", "skinIndexMap", "materialIndexMap", "meshIndexMap", "nodeIndexMap", "imageIndexMap", "textureDefIndexMap", "textureInfoDefMap", "samplerDefIndexMap", "sceneIndexMap", "imageBufferViews", "otherBufferViews", "otherBufferViewsIndexMap", "extensionData", "bufferURIGenerator", "imageURIGenerator", "_accessorUsageMap", "accessorUsageGroupedByParent", "accessorParents", "root", "numBuffers", "numImages", "UniqueURIGenerator", "listParentEdges", "replace", "createTextureInfoDef", "samplerKey", "textureKey", "createPropertyDef", "def", "createAccessorDef", "some", "fround", "createImageData", "format", "Format", "GLB", "createURI", "getAccessorUsage", "cachedUsage", "SPARSE", "addAccessorToUsageGroup", "prevUsage", "listAccessorUsageGroups", "USAGE_TO_TARGET", "multiple", "counter", "object", "GLTFWriter", "doc", "extensionsRegistered", "concatAccessors", "bufferIndex", "bufferByteOffset", "bufferViewTarget", "accessorArray", "pad", "concat", "interleaveAccessors", "vertexCount", "vertexByteOffset", "viewByteOffset", "setFloat32", "setInt8", "setInt16", "setUint8", "setUint16", "setUint32", "concatSparseAccessors", "sparseData", "maxIndex", "el", "fill", "il", "eq", "pct", "toFixed", "ValueArray", "IndexArray", "IndexComponentType", "indicesBufferViewDef", "indicesByteOffset", "indicesBufferViewIndex", "valuesBufferViewDef", "valuesByteOffset", "valuesBufferViewIndex", "accessorRefs", "uses", "textureIndex", "groupByParent", "accessorEdges", "parentAccessors", "bufferAccessors", "bufferAccessorsSet", "bufferByteLength", "usageGroups", "vertexLayout", "VertexLayout", "INTERLEAVED", "imagePadding", "samplerIndexMap", "samplerIndex", "write", "unused", "ChunkType", "PlatformIO", "_dependencies", "_vertexLayout", "lastReadBytes", "lastWriteBytes", "registerExtensions", "registerDependencies", "setVertexLayout", "layout", "readJSON", "readAsJSON", "readURI", "isGLB", "_binaryToJSON", "_readResourcesExternal", "dirname", "_readResourcesInternal", "_copyJSON", "glb", "jsonDocument", "binaryToJSON", "GLTF", "writeJSON", "header", "jsonText", "jsonChunkData", "encodeText", "jsonChunkHeader", "jsonChunk", "binBuffer", "binChunkData", "binChunkHeader", "binChunk", "_this", "pendingResources", "async", "resource", "Promise", "all", "resolveResource", "resourceUUID", "createBufferFromDataURI", "jsonByteLength", "binByteOffset", "BIN", "WebIO", "PlatformIO", "constructor", "fetchConfig", "HTTPUtils", "DEFAULT_INIT", "super", "this", "_fetchConfig", "uri", "type", "response", "fetch", "Uint8Array", "arrayBuffer", "text", "resolve", "base", "path", "dirname", "document", "phong_default", "wireframe_default", "BoundingVolumeMode", "c", "d", "c", "d"]
}
