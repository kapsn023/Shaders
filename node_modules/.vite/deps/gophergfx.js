import "./chunk-RSJERJUL.js";

// node_modules/gophergfx/src/math/Color.ts
var _Color = class {
  static copy(color) {
    const newColor = new _Color();
    newColor.r = color.r;
    newColor.g = color.g;
    newColor.b = color.b;
    newColor.a = color.a;
    return newColor;
  }
  static createFromString(color) {
    return new _Color(
      parseInt(color.substring(1, 3), 16) / 255,
      parseInt(color.substring(3, 5), 16) / 255,
      parseInt(color.substring(5, 7), 16) / 255
    );
  }
  static lerp(c1, c2, alpha) {
    return new _Color(
      c1.r * (1 - alpha) + c2.r * alpha,
      c1.g * (1 - alpha) + c2.g * alpha,
      c1.b * (1 - alpha) + c2.b * alpha,
      c1.a * (1 - alpha) + c2.a * alpha
    );
  }
  static add(c1, c2) {
    return new _Color(c1.r + c2.r, c1.g + c2.g, c1.b + c2.b);
  }
  static subtract(c1, c2) {
    return new _Color(c1.r - c2.r, c1.g - c2.g, c1.b - c2.b);
  }
  static multiply(c1, c2) {
    return new _Color(c1.r * c2.r, c1.g * c2.g, c1.b * c2.b);
  }
  static divide(c1, c2) {
    return new _Color(c1.r / c2.r, c1.g / c2.g, c1.b / c2.b);
  }
  static multiplyScalar(v, n) {
    return new _Color(v.r * n, v.g * n, v.b * n);
  }
  static divideScalar(v, n) {
    return new _Color(v.r / n, v.g / n, v.b / n);
  }
  constructor(r = 0, g2 = 0, b = 0, a = 1) {
    this.r = r;
    this.g = g2;
    this.b = b;
    this.a = a;
  }
  set(r = 0, g2 = 0, b = 0, a = 1) {
    this.r = r;
    this.g = g2;
    this.b = b;
    this.a = a;
  }
  setFromString(color) {
    this.r = parseInt(color.substring(1, 3), 16) / 255;
    this.g = parseInt(color.substring(3, 5), 16) / 255;
    this.b = parseInt(color.substring(5, 7), 16) / 255;
  }
  copy(color) {
    this.r = color.r;
    this.g = color.g;
    this.b = color.b;
    this.a = color.a;
  }
  clone() {
    return new _Color(this.r, this.g, this.b, this.a);
  }
  lerp(c1, c2, alpha) {
    this.r = c1.r * (1 - alpha) + c2.r * alpha;
    this.g = c1.g * (1 - alpha) + c2.g * alpha;
    this.b = c1.b * (1 - alpha) + c2.b * alpha;
    this.a = c1.b * (1 - alpha) + c2.a * alpha;
  }
  add(c2) {
    this.r += c2.r;
    this.g += c2.g;
    this.b += c2.b;
  }
  subtract(c2) {
    this.r -= c2.r;
    this.g -= c2.g;
    this.b -= c2.b;
  }
  multiply(c2) {
    this.r *= c2.r;
    this.g *= c2.g;
    this.b *= c2.b;
  }
  divide(c2) {
    this.r /= c2.r;
    this.g /= c2.g;
    this.b /= c2.b;
  }
  multiplyScalar(n) {
    this.r *= n;
    this.g *= n;
    this.b *= n;
  }
  divideScalar(n) {
    this.r /= n;
    this.g /= n;
    this.b /= n;
  }
};
var Color = _Color;
Color.WHITE = new _Color(1, 1, 1);
Color.BLACK = new _Color(0, 0, 0);
Color.RED = new _Color(1, 0, 0);
Color.GREEN = new _Color(0, 1, 0);
Color.BLUE = new _Color(0, 0, 1);
Color.YELLOW = new _Color(1, 1, 0);
Color.PURPLE = new _Color(1, 0, 1);
Color.CYAN = new _Color(0, 1, 1);

// node_modules/gophergfx/src/math/Vector2.ts
var _Vector2 = class {
  static copy(v) {
    return new _Vector2(v.x, v.y);
  }
  static inverse(v) {
    return new _Vector2(-v.x, -v.y);
  }
  static add(v1, v2) {
    return new _Vector2(v1.x + v2.x, v1.y + v2.y);
  }
  static subtract(v1, v2) {
    return new _Vector2(v1.x - v2.x, v1.y - v2.y);
  }
  static multiply(v1, v2) {
    return new _Vector2(v1.x * v2.x, v1.y * v2.y);
  }
  static divide(v1, v2) {
    return new _Vector2(v1.x / v2.x, v1.y / v2.y);
  }
  static multiplyScalar(v, n) {
    return new _Vector2(v.x * n, v.y * n);
  }
  static divideScalar(v, n) {
    return new _Vector2(v.x / n, v.y / n);
  }
  static distanceBetween(v1, v2) {
    return v1.distanceTo(v2);
  }
  static angleBetween(v1, v2) {
    return v1.angleBetween(v2);
  }
  static angleBetweenSigned(v1, v2) {
    return v1.angleBetweenSigned(v2);
  }
  static dot(v1, v2) {
    return v1.x * v2.x + v1.y * v2.y;
  }
  static normalize(v) {
    const sizeSquared = v.x * v.x + v.y * v.y;
    if (sizeSquared < 1e-8)
      return new _Vector2();
    const scaleFactor = 1 / Math.sqrt(sizeSquared);
    return new _Vector2(v.x * scaleFactor, v.y * scaleFactor);
  }
  static rotate(v, angle) {
    return new _Vector2(Math.cos(angle) * v.x - Math.sin(angle) * v.y, Math.sin(angle) * v.x + Math.cos(angle) * v.y);
  }
  static transformPoint(v, m2) {
    const result = new _Vector2();
    const w2 = 1 / (m2.mat[2] * v.x + m2.mat[5] * v.y + m2.mat[8]);
    result.x = w2 * (m2.mat[0] * v.x + m2.mat[3] * v.y + m2.mat[6]);
    result.y = w2 * (m2.mat[1] * v.x + m2.mat[4] * v.y + m2.mat[7]);
    return result;
  }
  static transformVector(v, m2) {
    const result = new _Vector2();
    const w2 = 1 / (m2.mat[2] * v.x + m2.mat[5] * v.y + m2.mat[8]);
    result.x = w2 * (m2.mat[0] * v.x + m2.mat[3] * v.y);
    result.y = w2 * (m2.mat[1] * v.x + m2.mat[4] * v.y);
    return result;
  }
  static lerp(v1, v2, alpha) {
    return new _Vector2(
      v1.x * (1 - alpha) + v2.x * alpha,
      v1.y * (1 - alpha) + v2.y * alpha
    );
  }
  constructor(x = 0, y2 = 0) {
    this.x = x;
    this.y = y2;
  }
  set(x, y2) {
    this.x = x;
    this.y = y2;
  }
  copy(v) {
    this.x = v.x;
    this.y = v.y;
  }
  clone() {
    return new _Vector2(this.x, this.y);
  }
  equals(v) {
    return this.x == v.x && this.y == v.y;
  }
  add(v) {
    this.x += v.x;
    this.y += v.y;
  }
  subtract(v) {
    this.x -= v.x;
    this.y -= v.y;
  }
  multiply(v) {
    this.x *= v.x;
    this.y *= v.y;
  }
  divide(v) {
    this.x /= v.x;
    this.y /= v.y;
  }
  multiplyScalar(n) {
    this.x *= n;
    this.y *= n;
  }
  divideScalar(n) {
    this.x /= n;
    this.y /= n;
  }
  distanceTo(v) {
    return Math.sqrt(
      (this.x - v.x) * (this.x - v.x) + (this.y - v.y) * (this.y - v.y)
    );
  }
  setPositionFromMatrix(m2) {
    this.x = m2.mat[6];
    this.y = m2.mat[7];
  }
  setScaleFromMatrix(m2) {
    this.x = Math.sqrt(m2.mat[0] * m2.mat[0] + m2.mat[1] * m2.mat[1]);
    this.y = Math.sqrt(m2.mat[3] * m2.mat[3] + m2.mat[4] * m2.mat[4]);
  }
  transformPoint(m2) {
    const v = this.clone();
    const w2 = 1 / (m2.mat[2] * v.x + m2.mat[5] * v.y + m2.mat[8]);
    this.x = w2 * (m2.mat[0] * v.x + m2.mat[3] * v.y + m2.mat[6]);
    this.y = w2 * (m2.mat[1] * v.x + m2.mat[4] * v.y + m2.mat[7]);
  }
  transformVector(m2) {
    const v = this.clone();
    const w2 = 1 / (m2.mat[2] * v.x + m2.mat[5] * v.y + m2.mat[8]);
    this.x = w2 * (m2.mat[0] * v.x + m2.mat[3] * v.y);
    this.y = w2 * (m2.mat[1] * v.x + m2.mat[4] * v.y);
  }
  dot(v) {
    return this.x * v.x + this.y * v.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  normalize() {
    const sizeSquared = this.x * this.x + this.y * this.y;
    if (sizeSquared < 1e-8)
      return;
    const scaleFactor = 1 / Math.sqrt(sizeSquared);
    this.x *= scaleFactor;
    this.y *= scaleFactor;
  }
  invert() {
    this.x = -this.x;
    this.y = -this.y;
  }
  angleBetween(v) {
    const v1Norm = _Vector2.normalize(this);
    const v2Norm = _Vector2.normalize(v);
    return Math.acos(v1Norm.dot(v2Norm));
  }
  angleBetweenSigned(v) {
    const v1Norm = _Vector2.normalize(this);
    const v2Norm = _Vector2.normalize(v);
    return Math.atan2(v2Norm.y, v2Norm.x) - Math.atan2(v1Norm.y, v1Norm.x);
  }
  rotate(angle) {
    const x = this.x;
    const y2 = this.y;
    this.x = Math.cos(angle) * x - Math.sin(angle) * y2;
    this.y = Math.sin(angle) * x + Math.cos(angle) * y2;
  }
  lerp(v1, v2, alpha) {
    this.x = v1.x * (1 - alpha) + v2.x * alpha;
    this.y = v1.y * (1 - alpha) + v2.y * alpha;
  }
};
var Vector2 = _Vector2;
Vector2.ZERO = new _Vector2(0, 0);
Vector2.ONE = new _Vector2(1, 1);
Vector2.UP = new _Vector2(0, 1);
Vector2.DOWN = new _Vector2(0, -1);
Vector2.LEFT = new _Vector2(-1, 0);
Vector2.RIGHT = new _Vector2(1, 0);
Vector2.X_AXIS = _Vector2.RIGHT;
Vector2.Y_AXIS = _Vector2.UP;

// node_modules/gophergfx/src/math/MathUtils.ts
var MathUtils = class {
  static degreesToRadians(degrees) {
    return degrees * Math.PI / 180;
  }
  static radiansToDegrees(radians) {
    return radians * 180 / Math.PI;
  }
  static rescale(value, min, max, scaledMin, scaledMax) {
    return scaledMin + (scaledMax - scaledMin) * (value - min) / (max - min);
  }
  static clamp(value, min, max) {
    return Math.max(min, Math.min(max, value));
  }
  static lerp(x, y2, alpha) {
    return x * (1 - alpha) + y2 * alpha;
  }
};
MathUtils.EPSILON = 1e-7;

// node_modules/gophergfx/src/core/Renderer.ts
var Viewport = /* @__PURE__ */ ((Viewport2) => {
  Viewport2[Viewport2["FIT"] = 0] = "FIT";
  Viewport2[Viewport2["CROP"] = 1] = "CROP";
  Viewport2[Viewport2["STRETCH"] = 2] = "STRETCH";
  return Viewport2;
})(Viewport || {});
var Renderer = class {
  constructor(enableStencilBuffer = false) {
    this.gfxCanvas = document.getElementById("gfxCanvas");
    if (!this.gfxCanvas) {
      alert("Unable to find gfxCanvas.");
    }
    this.gfxCanvas.width = window.innerWidth;
    this.gfxCanvas.height = window.innerHeight;
    const gl = this.gfxCanvas.getContext("webgl2", { alpha: false, stencil: enableStencilBuffer });
    if (!gl) {
      alert("Unable to initialize WebGL. Your browser or machine may not support it.");
    }
    this.gl = gl;
    gl.enable(gl.DEPTH_TEST);
    gl.depthFunc(gl.LEQUAL);
    gl.enable(gl.CULL_FACE);
    gl.cullFace(gl.BACK);
    gl.enable(this.gl.BLEND);
    gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
    this.background = new Color();
    this.viewport = 0 /* FIT */;
  }
  resize(width, height, aspectRatio) {
    this.gfxCanvas.width = width;
    this.gfxCanvas.height = height;
    if (this.viewport == 0 /* FIT */) {
      if (aspectRatio > window.innerWidth / window.innerHeight) {
        this.gl.viewport(
          0,
          (window.innerHeight - window.innerWidth / aspectRatio) / 2,
          window.innerWidth,
          window.innerWidth / aspectRatio
        );
      } else {
        this.gl.viewport(
          (window.innerWidth - window.innerHeight * aspectRatio) / 2,
          0,
          window.innerHeight * aspectRatio,
          window.innerHeight
        );
      }
    } else if (this.viewport == 1 /* CROP */) {
      if (aspectRatio > window.innerWidth / window.innerHeight) {
        this.gl.viewport(
          (window.innerWidth - window.innerHeight * aspectRatio) / 2,
          0,
          window.innerHeight * aspectRatio,
          window.innerHeight
        );
      } else {
        this.gl.viewport(
          0,
          (window.innerHeight - window.innerWidth / aspectRatio) / 2,
          window.innerWidth,
          window.innerWidth / aspectRatio
        );
      }
    } else {
      this.gl.viewport(
        0,
        0,
        window.innerWidth,
        window.innerHeight
      );
    }
  }
  render(scene, camera) {
    if (camera.projectionMatrixDirty) {
      this.resize(this.gfxCanvas.width, this.gfxCanvas.height, camera.getAspectRatio());
      camera.projectionMatrixDirty = false;
    }
    this.gl.clearColor(this.background.r, this.background.g, this.background.b, this.background.a);
    this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);
    scene.draw(camera);
  }
  getNormalizedDeviceCoordinates(mouseX, mouseY) {
    const viewport = this.gl.getParameter(this.gl.VIEWPORT);
    return new Vector2(
      MathUtils.clamp((mouseX - viewport[0]) / viewport[2] * 2 - 1, -1, 1),
      MathUtils.clamp((mouseY - viewport[1]) / viewport[3] * -2 + 1, -1, 1)
    );
  }
};

// node_modules/gophergfx/src/math/Vector3.ts
var _Vector3 = class {
  static copy(v) {
    return new _Vector3(v.x, v.y, v.z);
  }
  static inverse(v) {
    return new _Vector3(-v.x, -v.y, -v.z);
  }
  static add(v1, v2) {
    return new _Vector3(v1.x + v2.x, v1.y + v2.y, v1.z + v2.z);
  }
  static subtract(v1, v2) {
    return new _Vector3(v1.x - v2.x, v1.y - v2.y, v1.z - v2.z);
  }
  static multiply(v1, v2) {
    return new _Vector3(v1.x * v2.x, v1.y * v2.y, v1.z * v2.z);
  }
  static divide(v1, v2) {
    return new _Vector3(v1.x / v2.x, v1.y / v2.y, v1.z / v2.z);
  }
  static dot(v1, v2) {
    return v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;
  }
  static cross(v1, v2) {
    return new _Vector3(
      v1.y * v2.z - v1.z * v2.y,
      v1.z * v2.x - v1.x * v2.z,
      v1.x * v2.y - v1.y * v2.x
    );
  }
  static multiplyScalar(v, n) {
    return new _Vector3(v.x * n, v.y * n, v.z * n);
  }
  static divideScalar(v, n) {
    return new _Vector3(v.x / n, v.y / n, v.z / n);
  }
  static normalize(v) {
    const sizeSquared = v.x * v.x + v.y * v.y + v.z * v.z;
    if (sizeSquared < 1e-8)
      return new _Vector3();
    const scaleFactor = 1 / Math.sqrt(sizeSquared);
    return new _Vector3(v.x * scaleFactor, v.y * scaleFactor, v.z * scaleFactor);
  }
  static angleBetween(v1, v2) {
    return v1.angleBetween(v2);
  }
  static distanceBetween(v1, v2) {
    return v1.distanceTo(v2);
  }
  static rotate(v, q2) {
    const u2 = new _Vector3(q2.x, q2.y, q2.z);
    const result = _Vector3.multiplyScalar(u2, 2 * u2.dot(v));
    result.add(_Vector3.multiplyScalar(v, q2.w * q2.w - u2.dot(u2)));
    const crossUV = _Vector3.cross(u2, v);
    crossUV.multiplyScalar(2 * q2.w);
    result.add(crossUV);
    return result;
  }
  static lerp(v1, v2, alpha) {
    return new _Vector3(
      v1.x * (1 - alpha) + v2.x * alpha,
      v1.y * (1 - alpha) + v2.y * alpha,
      v1.z * (1 - alpha) + v2.z * alpha
    );
  }
  static transformPoint(v, m2) {
    const result = new _Vector3();
    const w2 = 1 / (m2.mat[3] * v.x + m2.mat[7] * v.y + m2.mat[11] * v.z + m2.mat[15]);
    result.x = w2 * (m2.mat[0] * v.x + m2.mat[4] * v.y + m2.mat[8] * v.z + m2.mat[12]);
    result.y = w2 * (m2.mat[1] * v.x + m2.mat[5] * v.y + m2.mat[9] * v.z + m2.mat[13]);
    result.z = w2 * (m2.mat[2] * v.x + m2.mat[6] * v.y + m2.mat[10] * v.z + m2.mat[14]);
    return result;
  }
  static transformVector(v, m2) {
    const result = new _Vector3();
    const w2 = 1 / (m2.mat[3] * v.x + m2.mat[7] * v.y + m2.mat[11] * v.z + m2.mat[15]);
    result.x = w2 * (m2.mat[0] * v.x + m2.mat[4] * v.y + m2.mat[8] * v.z);
    result.y = w2 * (m2.mat[1] * v.x + m2.mat[5] * v.y + m2.mat[9] * v.z);
    result.z = w2 * (m2.mat[2] * v.x + m2.mat[6] * v.y + m2.mat[10] * v.z);
    return result;
  }
  static reflect(v, n) {
    const result = n.clone();
    result.multiplyScalar(v.dot(n) * -2);
    result.add(v);
    return result;
  }
  static equals(v1, v2) {
    return v1.x == v2.x && v1.y == v2.y && v1.z == v2.z;
  }
  static fuzzyEquals(v1, v2, epsilon = MathUtils.EPSILON) {
    return Math.abs(v1.x - v2.x) < epsilon && Math.abs(v1.y - v2.y) < epsilon && Math.abs(v1.z - v2.z) < epsilon;
  }
  constructor(x = 0, y2 = 0, z2 = 0) {
    this.x = x;
    this.y = y2;
    this.z = z2;
  }
  set(x, y2, z2) {
    this.x = x;
    this.y = y2;
    this.z = z2;
  }
  copy(v) {
    this.x = v.x;
    this.y = v.y;
    this.z = v.z;
  }
  clone() {
    return new _Vector3(this.x, this.y, this.z);
  }
  equals(v) {
    return this.x == v.x && this.y == v.y && this.z == v.z;
  }
  fuzzyEquals(v, epsilon = MathUtils.EPSILON) {
    return Math.abs(this.x - v.x) < epsilon && Math.abs(this.y - v.y) < epsilon && Math.abs(this.z - v.z) < epsilon;
  }
  add(v) {
    this.x += v.x;
    this.y += v.y;
    this.z += v.z;
  }
  subtract(v) {
    this.x -= v.x;
    this.y -= v.y;
    this.z -= v.z;
  }
  multiply(v) {
    this.x *= v.x;
    this.y *= v.y;
    this.z *= v.z;
  }
  divide(v) {
    this.x /= v.x;
    this.y /= v.y;
    this.z /= v.z;
  }
  dot(v) {
    return this.x * v.x + this.y * v.y + this.z * v.z;
  }
  cross(v) {
    const crossProduct = new _Vector3(
      this.y * v.z - this.z * v.y,
      this.z * v.x - this.x * v.z,
      this.x * v.y - this.y * v.x
    );
    this.copy(crossProduct);
  }
  multiplyScalar(n) {
    this.x *= n;
    this.y *= n;
    this.z *= n;
  }
  divideScalar(n) {
    this.x /= n;
    this.y /= n;
    this.z /= n;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  normalize() {
    const sizeSquared = this.x * this.x + this.y * this.y + this.z * this.z;
    if (sizeSquared < 1e-8)
      return;
    const scaleFactor = 1 / Math.sqrt(sizeSquared);
    this.x *= scaleFactor;
    this.y *= scaleFactor;
    this.z *= scaleFactor;
  }
  invert() {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
  }
  inverse() {
    return new _Vector3(-this.x, -this.y, -this.z);
  }
  transformPoint(m2) {
    const v = this.clone();
    const w2 = 1 / (m2.mat[3] * v.x + m2.mat[7] * v.y + m2.mat[11] * v.z + m2.mat[15]);
    this.x = w2 * (m2.mat[0] * v.x + m2.mat[4] * v.y + m2.mat[8] * v.z + m2.mat[12]);
    this.y = w2 * (m2.mat[1] * v.x + m2.mat[5] * v.y + m2.mat[9] * v.z + m2.mat[13]);
    this.z = w2 * (m2.mat[2] * v.x + m2.mat[6] * v.y + m2.mat[10] * v.z + m2.mat[14]);
  }
  transformVector(m2) {
    const v = this.clone();
    const w2 = 1 / (m2.mat[3] * v.x + m2.mat[7] * v.y + m2.mat[11] * v.z + m2.mat[15]);
    this.x = w2 * (m2.mat[0] * v.x + m2.mat[4] * v.y + m2.mat[8] * v.z);
    this.y = w2 * (m2.mat[1] * v.x + m2.mat[5] * v.y + m2.mat[9] * v.z);
    this.z = w2 * (m2.mat[2] * v.x + m2.mat[6] * v.y + m2.mat[10] * v.z);
  }
  rotate(q2) {
    const u2 = new _Vector3(q2.x, q2.y, q2.z);
    const result = _Vector3.multiplyScalar(u2, 2 * u2.dot(this));
    result.add(_Vector3.multiplyScalar(this, q2.w * q2.w - u2.dot(u2)));
    const crossUV = _Vector3.cross(u2, this);
    crossUV.multiplyScalar(2 * q2.w);
    result.add(crossUV);
    this.copy(result);
  }
  angleBetween(v) {
    const v1Norm = _Vector3.normalize(this);
    const v2Norm = _Vector3.normalize(v);
    return Math.acos(v1Norm.dot(v2Norm));
  }
  distanceTo(v) {
    return Math.sqrt(
      (this.x - v.x) * (this.x - v.x) + (this.y - v.y) * (this.y - v.y) + (this.z - v.z) * (this.z - v.z)
    );
  }
  setPositionFromMatrix(m2) {
    this.x = m2.mat[12];
    this.y = m2.mat[13];
    this.z = m2.mat[14];
  }
  setScaleFromMatrix(m2) {
    this.x = Math.sqrt(m2.mat[0] * m2.mat[0] + m2.mat[1] * m2.mat[1] + m2.mat[2] * m2.mat[2]);
    this.y = Math.sqrt(m2.mat[4] * m2.mat[4] + m2.mat[5] * m2.mat[5] + m2.mat[6] * m2.mat[6]);
    this.z = Math.sqrt(m2.mat[8] * m2.mat[8] + m2.mat[9] * m2.mat[9] + m2.mat[10] * m2.mat[10]);
  }
  lerp(v1, v2, alpha) {
    this.x = v1.x * (1 - alpha) + v2.x * alpha;
    this.y = v1.y * (1 - alpha) + v2.y * alpha;
    this.z = v1.z * (1 - alpha) + v2.z * alpha;
  }
  reflect(normal) {
    const reflection = normal.clone();
    reflection.multiplyScalar(this.dot(normal) * -2);
    reflection.add(this);
    this.copy(reflection);
  }
};
var Vector3 = _Vector3;
Vector3.ZERO = new _Vector3(0, 0, 0);
Vector3.ONE = new _Vector3(1, 1, 1);
Vector3.UP = new _Vector3(0, 1, 0);
Vector3.DOWN = new _Vector3(0, -1, 0);
Vector3.LEFT = new _Vector3(-1, 0, 0);
Vector3.RIGHT = new _Vector3(1, 0, 0);
Vector3.FORWARD = new _Vector3(0, 0, -1);
Vector3.BACK = new _Vector3(0, 0, 1);
Vector3.X_AXIS = _Vector3.RIGHT;
Vector3.Y_AXIS = _Vector3.UP;
Vector3.Z_AXIS = _Vector3.FORWARD;

// node_modules/gophergfx/src/math/Quaternion.ts
var _Quaternion = class {
  static copy(q2) {
    return new _Quaternion(q2.x, q2.y, q2.z, q2.w);
  }
  static multiply(q1, q2) {
    const dest = new _Quaternion();
    dest.w = q1.w * q2.w - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z;
    dest.x = q1.w * q2.x + q1.x * q2.w + q1.y * q2.z - q1.z * q2.y;
    dest.y = q1.w * q2.y + q1.y * q2.w + q1.z * q2.x - q1.x * q2.z;
    dest.z = q1.w * q2.z + q1.z * q2.w + q1.x * q2.y - q1.y * q2.x;
    return dest;
  }
  static premultiply(q1, q2) {
    const dest = new _Quaternion();
    dest.w = q2.w * q1.w - q2.x * q1.x - q2.y * q1.y - q2.z * q1.z;
    dest.x = q2.w * q1.x + q2.x * q1.w + q2.y * q1.z - q2.z * q1.y;
    dest.y = q2.w * q1.y + q2.y * q1.w + q2.z * q1.x - q2.x * q1.z;
    dest.z = q2.w * q1.z + q2.z * q1.w + q2.x * q1.y - q2.y * q1.x;
    return dest;
  }
  static normalize(q2) {
    const dest = q2.clone();
    dest.normalize();
    return dest;
  }
  static inverse(q2) {
    const dest = q2.clone();
    dest.invert();
    return dest;
  }
  makeIdentity() {
    return new _Quaternion(0, 0, 0, 1);
  }
  static makeRotationX(angle) {
    const dest = new _Quaternion();
    dest.setRotationX(angle);
    return dest;
  }
  static makeRotationY(angle) {
    const dest = new _Quaternion();
    dest.setRotationY(angle);
    return dest;
  }
  static makeRotationZ(angle) {
    const dest = new _Quaternion();
    dest.setRotationZ(angle);
    return dest;
  }
  static makeAxisAngle(axis, angle) {
    const dest = new _Quaternion();
    dest.setAxisAngle(axis, angle);
    return dest;
  }
  static makeEulerAngles(x, y2, z2, order = "YZX") {
    const dest = new _Quaternion();
    dest.setEulerAngles(x, y2, z2, order);
    return dest;
  }
  static lookAt(eyePoint, targetPoint, upVector = Vector3.UP) {
    const z2 = Vector3.subtract(eyePoint, targetPoint);
    z2.normalize();
    const x = Vector3.cross(upVector, z2);
    x.normalize();
    const y2 = Vector3.cross(z2, x);
    y2.normalize();
    const m2 = new Matrix4();
    m2.setRowMajor(
      x.x,
      y2.x,
      z2.x,
      0,
      x.y,
      y2.y,
      z2.y,
      0,
      x.z,
      y2.z,
      z2.z,
      0,
      0,
      0,
      0,
      1
    );
    return _Quaternion.makeMatrix(m2);
  }
  static makeMatrix(matrix) {
    const dest = new _Quaternion();
    dest.setMatrix(matrix);
    return dest;
  }
  static slerp(q1, q2, alpha) {
    const q3 = new _Quaternion();
    q3.slerp(q1, q2, alpha);
    return q3;
  }
  static rotate(v, q2) {
    const u2 = new Vector3(q2.x, q2.y, q2.z);
    const result = Vector3.multiplyScalar(u2, 2 * u2.dot(v));
    result.add(Vector3.multiplyScalar(v, q2.w * q2.w - u2.dot(u2)));
    const crossUV = Vector3.cross(u2, v);
    crossUV.multiplyScalar(2 * q2.w);
    result.add(crossUV);
    return result;
  }
  constructor(x = 0, y2 = 0, z2 = 0, w2 = 1) {
    this.x = x;
    this.y = y2;
    this.z = z2;
    this.w = w2;
  }
  set(x, y2, z2, w2) {
    this.x = x;
    this.y = y2;
    this.z = z2;
    this.w = w2;
  }
  setIdentity() {
    this.x = 0;
    this.y = 0;
    this.z = 0;
    this.w = 1;
  }
  setRotationX(angle) {
    this.w = Math.cos(angle / 2);
    this.x = Math.sin(angle / 2);
    this.y = 0;
    this.z = 0;
  }
  setRotationY(angle) {
    this.w = Math.cos(angle / 2);
    this.x = 0;
    this.y = Math.sin(angle / 2);
    this.z = 0;
  }
  setRotationZ(angle) {
    this.w = Math.cos(angle / 2);
    this.x = 0;
    this.y = 0;
    this.z = Math.sin(angle / 2);
  }
  setAxisAngle(axis, angle) {
    const sinAngle = Math.sin(angle / 2);
    this.w = Math.cos(angle / 2);
    this.x = sinAngle * axis.x;
    this.y = sinAngle * axis.y;
    this.z = sinAngle * axis.z;
  }
  setEulerAngles(x, y2, z2, order = "YZX") {
    const cos = Math.cos;
    const sin = Math.sin;
    const c1 = cos(x / 2);
    const c2 = cos(y2 / 2);
    const c3 = cos(z2 / 2);
    const s1 = sin(x / 2);
    const s2 = sin(y2 / 2);
    const s3 = sin(z2 / 2);
    switch (order) {
      case "XYZ":
        this.x = s1 * c2 * c3 + c1 * s2 * s3;
        this.y = c1 * s2 * c3 - s1 * c2 * s3;
        this.z = c1 * c2 * s3 + s1 * s2 * c3;
        this.w = c1 * c2 * c3 - s1 * s2 * s3;
        break;
      case "YXZ":
        this.x = s1 * c2 * c3 + c1 * s2 * s3;
        this.y = c1 * s2 * c3 - s1 * c2 * s3;
        this.z = c1 * c2 * s3 - s1 * s2 * c3;
        this.w = c1 * c2 * c3 + s1 * s2 * s3;
        break;
      case "ZXY":
        this.x = s1 * c2 * c3 - c1 * s2 * s3;
        this.y = c1 * s2 * c3 + s1 * c2 * s3;
        this.z = c1 * c2 * s3 + s1 * s2 * c3;
        this.w = c1 * c2 * c3 - s1 * s2 * s3;
        break;
      case "ZYX":
        this.x = s1 * c2 * c3 - c1 * s2 * s3;
        this.y = c1 * s2 * c3 + s1 * c2 * s3;
        this.z = c1 * c2 * s3 - s1 * s2 * c3;
        this.w = c1 * c2 * c3 + s1 * s2 * s3;
        break;
      case "YZX":
        this.x = s1 * c2 * c3 + c1 * s2 * s3;
        this.y = c1 * s2 * c3 + s1 * c2 * s3;
        this.z = c1 * c2 * s3 - s1 * s2 * c3;
        this.w = c1 * c2 * c3 - s1 * s2 * s3;
        break;
      case "XZY":
        this.x = s1 * c2 * c3 - c1 * s2 * s3;
        this.y = c1 * s2 * c3 - s1 * c2 * s3;
        this.z = c1 * c2 * s3 + s1 * s2 * c3;
        this.w = c1 * c2 * c3 + s1 * s2 * s3;
        break;
    }
  }
  setMatrix(matrix) {
    const trace = matrix.mat[0] + matrix.mat[5] + matrix.mat[10];
    if (trace > 0) {
      const s = Math.sqrt(trace + 1) * 2;
      this.w = 0.25 * s;
      this.x = (matrix.mat[6] - matrix.mat[9]) / s;
      this.y = (matrix.mat[8] - matrix.mat[2]) / s;
      this.z = (matrix.mat[1] - matrix.mat[4]) / s;
    } else if (matrix.mat[0] > matrix.mat[5] && matrix.mat[0] > matrix.mat[10]) {
      const s = Math.sqrt(1 + matrix.mat[0] - matrix.mat[5] - matrix.mat[10]) * 2;
      this.w = (matrix.mat[6] - matrix.mat[9]) / s;
      this.x = 0.25 * s;
      this.y = (matrix.mat[4] + matrix.mat[1]) / s;
      this.z = (matrix.mat[8] + matrix.mat[2]) / s;
    } else if (matrix.mat[5] > matrix.mat[10]) {
      const s = Math.sqrt(1 + matrix.mat[5] - matrix.mat[0] - matrix.mat[10]) * 2;
      this.w = (matrix.mat[8] - matrix.mat[2]) / s;
      this.x = (matrix.mat[4] + matrix.mat[1]) / s;
      this.y = 0.25 * s;
      this.z = (matrix.mat[9] + matrix.mat[6]) / s;
    } else {
      const s = Math.sqrt(1 + matrix.mat[10] - matrix.mat[0] - matrix.mat[5]) * 2;
      this.w = (matrix.mat[1] - matrix.mat[4]) / s;
      this.x = (matrix.mat[8] + matrix.mat[2]) / s;
      this.y = (matrix.mat[9] + matrix.mat[6]) / s;
      this.z = 0.25 * s;
    }
  }
  copy(q2) {
    this.x = q2.x;
    this.y = q2.y;
    this.z = q2.z;
    this.w = q2.w;
  }
  clone() {
    return new _Quaternion(this.x, this.y, this.z, this.w);
  }
  multiply(q2) {
    this.copy(_Quaternion.multiply(this, q2));
  }
  premultiply(q2) {
    this.copy(_Quaternion.multiply(q2, this));
  }
  normalize() {
    const normalizeFactor = 1 / Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
    this.x *= normalizeFactor;
    this.y *= normalizeFactor;
    this.z *= normalizeFactor;
    this.w *= normalizeFactor;
  }
  invert() {
    const normalizeFactor = 1 / Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
    this.x *= -normalizeFactor;
    this.y *= -normalizeFactor;
    this.z *= -normalizeFactor;
    this.w *= normalizeFactor;
  }
  inverse() {
    return _Quaternion.inverse(this);
  }
  getMatrix() {
    const sqw = this.w * this.w;
    const sqx = this.x * this.x;
    const sqy = this.y * this.y;
    const sqz = this.z * this.z;
    const invs = 1 / (sqx + sqy + sqz + sqw);
    const tmp1 = this.x * this.y;
    const tmp2 = this.z * this.w;
    const tmp3 = this.x * this.z;
    const tmp4 = this.y * this.w;
    const tmp5 = this.y * this.z;
    const tmp6 = this.x * this.w;
    return Matrix4.fromRowMajor(
      (sqx - sqy - sqz + sqw) * invs,
      2 * (tmp1 - tmp2) * invs,
      2 * (tmp3 + tmp4) * invs,
      0,
      2 * (tmp1 + tmp2) * invs,
      (-sqx + sqy - sqz + sqw) * invs,
      2 * (tmp5 - tmp6) * invs,
      0,
      2 * (tmp3 - tmp4) * invs,
      2 * (tmp5 + tmp6) * invs,
      -sqx - sqy + sqz + sqw,
      0,
      0,
      0,
      0,
      1
    );
  }
  lookAt(eyePoint, targetPoint, upVector = Vector3.UP) {
    const z2 = Vector3.subtract(eyePoint, targetPoint);
    z2.normalize();
    const x = Vector3.cross(upVector, z2);
    x.normalize();
    const y2 = Vector3.cross(z2, x);
    y2.normalize();
    const m2 = new Matrix4();
    m2.setRowMajor(
      x.x,
      y2.x,
      z2.x,
      0,
      x.y,
      y2.y,
      z2.y,
      0,
      x.z,
      y2.z,
      z2.z,
      0,
      0,
      0,
      0,
      1
    );
    this.setMatrix(m2);
  }
  slerp(q1, q2, alpha) {
    const temp = q1.clone();
    let cosOmega = q1.x * q2.x + q1.y * q2.y + q1.z * q2.z + q1.w * q2.w;
    let omega, sinOmega, startScale, endScale;
    if (cosOmega < 0) {
      cosOmega *= -1;
      temp.x *= -1;
      temp.y *= -1;
      temp.z *= -1;
      temp.w *= -1;
    }
    if (1 + cosOmega > 1e-5) {
      if (1 - cosOmega > 1e-5) {
        omega = Math.acos(cosOmega);
        sinOmega = Math.sin(omega);
        startScale = Math.sin((1 - alpha) * omega) / sinOmega;
        endScale = Math.sin(alpha * omega) / sinOmega;
      } else {
        startScale = 1 - alpha;
        endScale = alpha;
      }
      this.x = startScale * temp.x + endScale * q2.x;
      this.y = startScale * temp.y + endScale * q2.y;
      this.z = startScale * temp.z + endScale * q2.z;
      this.w = startScale * temp.w + endScale * q2.w;
    } else {
      this.x = -temp.y;
      this.y = temp.x;
      this.z = -temp.w;
      this.w = temp.z;
      startScale = Math.sin((0.5 - alpha) * Math.PI);
      endScale = Math.sin(alpha * Math.PI);
      this.x = startScale * temp.x + endScale * this.x;
      this.y = startScale * temp.y + endScale * this.y;
      this.z = startScale * temp.y + endScale * this.z;
    }
  }
  rotate(v) {
    const u2 = new Vector3(this.x, this.y, this.z);
    const result = Vector3.multiplyScalar(u2, 2 * u2.dot(v));
    result.add(Vector3.multiplyScalar(v, this.w * this.w - u2.dot(u2)));
    const crossUV = Vector3.cross(u2, v);
    crossUV.multiplyScalar(2 * this.w);
    result.add(crossUV);
    return result;
  }
};
var Quaternion = _Quaternion;
Quaternion.IDENTITY = new _Quaternion();

// node_modules/gophergfx/src/math/Matrix4.ts
var _Matrix4 = class {
  static multiply(lhs, rhs) {
    const m2 = new _Matrix4();
    m2.mat[0] = rhs.mat[0] * lhs.mat[0] + rhs.mat[1] * lhs.mat[4] + rhs.mat[2] * lhs.mat[8] + rhs.mat[3] * lhs.mat[12];
    m2.mat[1] = rhs.mat[0] * lhs.mat[1] + rhs.mat[1] * lhs.mat[5] + rhs.mat[2] * lhs.mat[9] + rhs.mat[3] * lhs.mat[13];
    m2.mat[2] = rhs.mat[0] * lhs.mat[2] + rhs.mat[1] * lhs.mat[6] + rhs.mat[2] * lhs.mat[10] + rhs.mat[3] * lhs.mat[14];
    m2.mat[3] = rhs.mat[0] * lhs.mat[3] + rhs.mat[1] * lhs.mat[7] + rhs.mat[2] * lhs.mat[11] + rhs.mat[3] * lhs.mat[15];
    m2.mat[4] = rhs.mat[4] * lhs.mat[0] + rhs.mat[5] * lhs.mat[4] + rhs.mat[6] * lhs.mat[8] + rhs.mat[7] * lhs.mat[12];
    m2.mat[5] = rhs.mat[4] * lhs.mat[1] + rhs.mat[5] * lhs.mat[5] + rhs.mat[6] * lhs.mat[9] + rhs.mat[7] * lhs.mat[13];
    m2.mat[6] = rhs.mat[4] * lhs.mat[2] + rhs.mat[5] * lhs.mat[6] + rhs.mat[6] * lhs.mat[10] + rhs.mat[7] * lhs.mat[14];
    m2.mat[7] = rhs.mat[4] * lhs.mat[3] + rhs.mat[5] * lhs.mat[7] + rhs.mat[6] * lhs.mat[11] + rhs.mat[7] * lhs.mat[15];
    m2.mat[8] = rhs.mat[8] * lhs.mat[0] + rhs.mat[9] * lhs.mat[4] + rhs.mat[10] * lhs.mat[8] + rhs.mat[11] * lhs.mat[12];
    m2.mat[9] = rhs.mat[8] * lhs.mat[1] + rhs.mat[9] * lhs.mat[5] + rhs.mat[10] * lhs.mat[9] + rhs.mat[11] * lhs.mat[13];
    m2.mat[10] = rhs.mat[8] * lhs.mat[2] + rhs.mat[9] * lhs.mat[6] + rhs.mat[10] * lhs.mat[10] + rhs.mat[11] * lhs.mat[14];
    m2.mat[11] = rhs.mat[8] * lhs.mat[3] + rhs.mat[9] * lhs.mat[7] + rhs.mat[10] * lhs.mat[11] + rhs.mat[11] * lhs.mat[15];
    m2.mat[12] = rhs.mat[12] * lhs.mat[0] + rhs.mat[13] * lhs.mat[4] + rhs.mat[14] * lhs.mat[8] + rhs.mat[15] * lhs.mat[12];
    m2.mat[13] = rhs.mat[12] * lhs.mat[1] + rhs.mat[13] * lhs.mat[5] + rhs.mat[14] * lhs.mat[9] + rhs.mat[15] * lhs.mat[13];
    m2.mat[14] = rhs.mat[12] * lhs.mat[2] + rhs.mat[13] * lhs.mat[6] + rhs.mat[14] * lhs.mat[10] + rhs.mat[15] * lhs.mat[14];
    m2.mat[15] = rhs.mat[12] * lhs.mat[3] + rhs.mat[13] * lhs.mat[7] + rhs.mat[14] * lhs.mat[11] + rhs.mat[15] * lhs.mat[15];
    return m2;
  }
  static multiplyAll(m1, m2, ...mAdditional) {
    const result = m1.clone();
    result.multiply(m2);
    for (let i = 0; i < mAdditional.length; i++) {
      result.multiply(mAdditional[i]);
    }
    return result;
  }
  static copy(m2) {
    const mat = new _Matrix4();
    mat.copy(m2);
    return mat;
  }
  static fromRowMajor(n1, n2, n3, n4, n5, n6, n7, n8, n9, n10, n11, n12, n13, n14, n15, n16) {
    const matrix = new _Matrix4();
    matrix.setRowMajor(n1, n2, n3, n4, n5, n6, n7, n8, n9, n10, n11, n12, n13, n14, n15, n16);
    return matrix;
  }
  static fromColumnMajor(n1, n2, n3, n4, n5, n6, n7, n8, n9, n10, n11, n12, n13, n14, n15, n16) {
    const matrix = new _Matrix4();
    matrix.setColumnMajor(n1, n2, n3, n4, n5, n6, n7, n8, n9, n10, n11, n12, n13, n14, n15, n16);
    return matrix;
  }
  static makeIdentity() {
    return _Matrix4.fromRowMajor(
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    );
  }
  static makeTranslation(v) {
    return _Matrix4.fromRowMajor(
      1,
      0,
      0,
      v.x,
      0,
      1,
      0,
      v.y,
      0,
      0,
      1,
      v.z,
      0,
      0,
      0,
      1
    );
  }
  static makeRotation(rotation) {
    const matrix = new _Matrix4();
    matrix.setRotation(rotation);
    return matrix;
  }
  static makeRotationX(angle) {
    const matrix = new _Matrix4();
    matrix.setRotationX(angle);
    return matrix;
  }
  static makeRotationY(angle) {
    const matrix = new _Matrix4();
    matrix.setRotationY(angle);
    return matrix;
  }
  static makeRotationZ(angle) {
    const matrix = new _Matrix4();
    matrix.setRotationZ(angle);
    return matrix;
  }
  static makeAxisAngle(axis, angle) {
    const matrix = new _Matrix4();
    matrix.setAxisAngle(axis, angle);
    return matrix;
  }
  static makeEulerAngles(x, y2, z2, order = "YZX") {
    const dest = new _Matrix4();
    dest.setEulerAngles(x, y2, z2, order);
    return dest;
  }
  static makeScale(scale) {
    const matrix = new _Matrix4();
    matrix.setScale(scale);
    return matrix;
  }
  static compose(position = Vector3.ZERO, rotation = Quaternion.IDENTITY, scale = Vector3.UP) {
    const m2 = _Matrix4.makeScale(scale);
    m2.premultiply(_Matrix4.makeRotation(rotation));
    m2.mat[12] = position.x;
    m2.mat[13] = position.y;
    m2.mat[14] = position.z;
    return m2;
  }
  static lookAt(eyePoint, targetPoint, upVector) {
    const z2 = Vector3.subtract(eyePoint, targetPoint);
    z2.normalize();
    const x = Vector3.cross(upVector, z2);
    x.normalize();
    const y2 = Vector3.cross(z2, x);
    y2.normalize();
    const rotation = _Matrix4.fromColumnMajor(
      x.x,
      x.y,
      x.z,
      0,
      y2.x,
      y2.y,
      y2.z,
      0,
      z2.x,
      z2.y,
      z2.z,
      0,
      0,
      0,
      0,
      1
    );
    const translation = _Matrix4.fromColumnMajor(
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      eyePoint.x,
      eyePoint.y,
      eyePoint.z,
      1
    );
    return _Matrix4.multiply(translation, rotation);
  }
  static makeOrthographic(left, right, bottom, top, near, far) {
    const matrix = new _Matrix4();
    matrix.setOrthographic(left, right, bottom, top, near, far);
    return matrix;
  }
  static makePerspective(fov, aspectRatio, near, far) {
    const matrix = new _Matrix4();
    matrix.setPerspective(fov, aspectRatio, near, far);
    return matrix;
  }
  static makeFrustum(left, right, bottom, top, near, far) {
    const matrix = new _Matrix4();
    matrix.setFrustum(left, right, bottom, top, near, far);
    return matrix;
  }
  static transformPoint(m2, p2) {
    const result = new Vector3();
    const w2 = 1 / (m2.mat[3] * p2.x + m2.mat[7] * p2.y + m2.mat[11] * p2.z + m2.mat[15]);
    result.x = w2 * (m2.mat[0] * p2.x + m2.mat[4] * p2.y + m2.mat[8] * p2.z + m2.mat[12]);
    result.y = w2 * (m2.mat[1] * p2.x + m2.mat[5] * p2.y + m2.mat[9] * p2.z + m2.mat[13]);
    result.z = w2 * (m2.mat[2] * p2.x + m2.mat[6] * p2.y + m2.mat[10] * p2.z + m2.mat[14]);
    return result;
  }
  static transformVector(m2, v) {
    const result = new Vector3();
    const w2 = 1 / (m2.mat[3] * v.x + m2.mat[7] * v.y + m2.mat[11] * v.z + m2.mat[15]);
    result.x = w2 * (m2.mat[0] * v.x + m2.mat[4] * v.y + m2.mat[8] * v.z);
    result.y = w2 * (m2.mat[1] * v.x + m2.mat[5] * v.y + m2.mat[9] * v.z);
    result.z = w2 * (m2.mat[2] * v.x + m2.mat[6] * v.y + m2.mat[10] * v.z);
    return result;
  }
  static equals(m1, m2) {
    for (let i = 0; i < 16; i++) {
      if (m1.mat[i] != m2.mat[i])
        return false;
    }
    return true;
  }
  static fuzzyEquals(m1, m2, epsilon = MathUtils.EPSILON) {
    for (let i = 0; i < 16; i++) {
      if (Math.abs(m1.mat[i] - m2.mat[i]) < epsilon)
        return false;
    }
    return true;
  }
  constructor() {
    this.mat = [
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ];
  }
  setColumnMajor(n1, n2, n3, n4, n5, n6, n7, n8, n9, n10, n11, n12, n13, n14, n15, n16) {
    this.mat[0] = n1;
    this.mat[1] = n2;
    this.mat[2] = n3;
    this.mat[3] = n4;
    this.mat[4] = n5;
    this.mat[5] = n6;
    this.mat[6] = n7;
    this.mat[7] = n8;
    this.mat[8] = n9;
    this.mat[9] = n10;
    this.mat[10] = n11;
    this.mat[11] = n12;
    this.mat[12] = n13;
    this.mat[13] = n14;
    this.mat[14] = n15;
    this.mat[15] = n16;
  }
  setRowMajor(n1, n2, n3, n4, n5, n6, n7, n8, n9, n10, n11, n12, n13, n14, n15, n16) {
    this.mat[0] = n1;
    this.mat[1] = n5;
    this.mat[2] = n9;
    this.mat[3] = n13;
    this.mat[4] = n2;
    this.mat[5] = n6;
    this.mat[6] = n10;
    this.mat[7] = n14;
    this.mat[8] = n3;
    this.mat[9] = n7;
    this.mat[10] = n11;
    this.mat[11] = n15;
    this.mat[12] = n4;
    this.mat[13] = n8;
    this.mat[14] = n12;
    this.mat[15] = n16;
  }
  copy(m2) {
    for (let i = 0; i < 16; i++)
      this.mat[i] = m2.mat[i];
  }
  clone() {
    const matrix = new _Matrix4();
    for (let i = 0; i < 16; i++)
      matrix.mat[i] = this.mat[i];
    return matrix;
  }
  element(row, col) {
    return this.mat[col * 4 + row];
  }
  set(value, row, col) {
    this.mat[col * 4 + row] = value;
  }
  multiply(rhs) {
    const lhs = this.clone();
    this.mat[0] = rhs.mat[0] * lhs.mat[0] + rhs.mat[1] * lhs.mat[4] + rhs.mat[2] * lhs.mat[8] + rhs.mat[3] * lhs.mat[12];
    this.mat[1] = rhs.mat[0] * lhs.mat[1] + rhs.mat[1] * lhs.mat[5] + rhs.mat[2] * lhs.mat[9] + rhs.mat[3] * lhs.mat[13];
    this.mat[2] = rhs.mat[0] * lhs.mat[2] + rhs.mat[1] * lhs.mat[6] + rhs.mat[2] * lhs.mat[10] + rhs.mat[3] * lhs.mat[14];
    this.mat[3] = rhs.mat[0] * lhs.mat[3] + rhs.mat[1] * lhs.mat[7] + rhs.mat[2] * lhs.mat[11] + rhs.mat[3] * lhs.mat[15];
    this.mat[4] = rhs.mat[4] * lhs.mat[0] + rhs.mat[5] * lhs.mat[4] + rhs.mat[6] * lhs.mat[8] + rhs.mat[7] * lhs.mat[12];
    this.mat[5] = rhs.mat[4] * lhs.mat[1] + rhs.mat[5] * lhs.mat[5] + rhs.mat[6] * lhs.mat[9] + rhs.mat[7] * lhs.mat[13];
    this.mat[6] = rhs.mat[4] * lhs.mat[2] + rhs.mat[5] * lhs.mat[6] + rhs.mat[6] * lhs.mat[10] + rhs.mat[7] * lhs.mat[14];
    this.mat[7] = rhs.mat[4] * lhs.mat[3] + rhs.mat[5] * lhs.mat[7] + rhs.mat[6] * lhs.mat[11] + rhs.mat[7] * lhs.mat[15];
    this.mat[8] = rhs.mat[8] * lhs.mat[0] + rhs.mat[9] * lhs.mat[4] + rhs.mat[10] * lhs.mat[8] + rhs.mat[11] * lhs.mat[12];
    this.mat[9] = rhs.mat[8] * lhs.mat[1] + rhs.mat[9] * lhs.mat[5] + rhs.mat[10] * lhs.mat[9] + rhs.mat[11] * lhs.mat[13];
    this.mat[10] = rhs.mat[8] * lhs.mat[2] + rhs.mat[9] * lhs.mat[6] + rhs.mat[10] * lhs.mat[10] + rhs.mat[11] * lhs.mat[14];
    this.mat[11] = rhs.mat[8] * lhs.mat[3] + rhs.mat[9] * lhs.mat[7] + rhs.mat[10] * lhs.mat[11] + rhs.mat[11] * lhs.mat[15];
    this.mat[12] = rhs.mat[12] * lhs.mat[0] + rhs.mat[13] * lhs.mat[4] + rhs.mat[14] * lhs.mat[8] + rhs.mat[15] * lhs.mat[12];
    this.mat[13] = rhs.mat[12] * lhs.mat[1] + rhs.mat[13] * lhs.mat[5] + rhs.mat[14] * lhs.mat[9] + rhs.mat[15] * lhs.mat[13];
    this.mat[14] = rhs.mat[12] * lhs.mat[2] + rhs.mat[13] * lhs.mat[6] + rhs.mat[14] * lhs.mat[10] + rhs.mat[15] * lhs.mat[14];
    this.mat[15] = rhs.mat[12] * lhs.mat[3] + rhs.mat[13] * lhs.mat[7] + rhs.mat[14] * lhs.mat[11] + rhs.mat[15] * lhs.mat[15];
  }
  multiplyAll(m1, ...mAdditional) {
    this.multiply(m1);
    for (let i = 0; i < mAdditional.length; i++) {
      this.multiply(mAdditional[i]);
    }
  }
  premultiply(lhs) {
    const rhs = this.clone();
    this.mat[0] = rhs.mat[0] * lhs.mat[0] + rhs.mat[1] * lhs.mat[4] + rhs.mat[2] * lhs.mat[8] + rhs.mat[3] * lhs.mat[12];
    this.mat[1] = rhs.mat[0] * lhs.mat[1] + rhs.mat[1] * lhs.mat[5] + rhs.mat[2] * lhs.mat[9] + rhs.mat[3] * lhs.mat[13];
    this.mat[2] = rhs.mat[0] * lhs.mat[2] + rhs.mat[1] * lhs.mat[6] + rhs.mat[2] * lhs.mat[10] + rhs.mat[3] * lhs.mat[14];
    this.mat[3] = rhs.mat[0] * lhs.mat[3] + rhs.mat[1] * lhs.mat[7] + rhs.mat[2] * lhs.mat[11] + rhs.mat[3] * lhs.mat[15];
    this.mat[4] = rhs.mat[4] * lhs.mat[0] + rhs.mat[5] * lhs.mat[4] + rhs.mat[6] * lhs.mat[8] + rhs.mat[7] * lhs.mat[12];
    this.mat[5] = rhs.mat[4] * lhs.mat[1] + rhs.mat[5] * lhs.mat[5] + rhs.mat[6] * lhs.mat[9] + rhs.mat[7] * lhs.mat[13];
    this.mat[6] = rhs.mat[4] * lhs.mat[2] + rhs.mat[5] * lhs.mat[6] + rhs.mat[6] * lhs.mat[10] + rhs.mat[7] * lhs.mat[14];
    this.mat[7] = rhs.mat[4] * lhs.mat[3] + rhs.mat[5] * lhs.mat[7] + rhs.mat[6] * lhs.mat[11] + rhs.mat[7] * lhs.mat[15];
    this.mat[8] = rhs.mat[8] * lhs.mat[0] + rhs.mat[9] * lhs.mat[4] + rhs.mat[10] * lhs.mat[8] + rhs.mat[11] * lhs.mat[12];
    this.mat[9] = rhs.mat[8] * lhs.mat[1] + rhs.mat[9] * lhs.mat[5] + rhs.mat[10] * lhs.mat[9] + rhs.mat[11] * lhs.mat[13];
    this.mat[10] = rhs.mat[8] * lhs.mat[2] + rhs.mat[9] * lhs.mat[6] + rhs.mat[10] * lhs.mat[10] + rhs.mat[11] * lhs.mat[14];
    this.mat[11] = rhs.mat[8] * lhs.mat[3] + rhs.mat[9] * lhs.mat[7] + rhs.mat[10] * lhs.mat[11] + rhs.mat[11] * lhs.mat[15];
    this.mat[12] = rhs.mat[12] * lhs.mat[0] + rhs.mat[13] * lhs.mat[4] + rhs.mat[14] * lhs.mat[8] + rhs.mat[15] * lhs.mat[12];
    this.mat[13] = rhs.mat[12] * lhs.mat[1] + rhs.mat[13] * lhs.mat[5] + rhs.mat[14] * lhs.mat[9] + rhs.mat[15] * lhs.mat[13];
    this.mat[14] = rhs.mat[12] * lhs.mat[2] + rhs.mat[13] * lhs.mat[6] + rhs.mat[14] * lhs.mat[10] + rhs.mat[15] * lhs.mat[14];
    this.mat[15] = rhs.mat[12] * lhs.mat[3] + rhs.mat[13] * lhs.mat[7] + rhs.mat[14] * lhs.mat[11] + rhs.mat[15] * lhs.mat[15];
  }
  setIdentity() {
    this.setRowMajor(
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    );
  }
  setTranslation(v) {
    this.setRowMajor(
      1,
      0,
      0,
      v.x,
      0,
      1,
      0,
      v.y,
      0,
      0,
      1,
      v.z,
      0,
      0,
      0,
      1
    );
  }
  setRotation(rotation) {
    const sqw = rotation.w * rotation.w;
    const sqx = rotation.x * rotation.x;
    const sqy = rotation.y * rotation.y;
    const sqz = rotation.z * rotation.z;
    const invs = 1 / (sqx + sqy + sqz + sqw);
    const tmp1 = rotation.x * rotation.y;
    const tmp2 = rotation.z * rotation.w;
    const tmp3 = rotation.x * rotation.z;
    const tmp4 = rotation.y * rotation.w;
    const tmp5 = rotation.y * rotation.z;
    const tmp6 = rotation.x * rotation.w;
    this.setRowMajor(
      (sqx - sqy - sqz + sqw) * invs,
      2 * (tmp1 - tmp2) * invs,
      2 * (tmp3 + tmp4) * invs,
      0,
      2 * (tmp1 + tmp2) * invs,
      (-sqx + sqy - sqz + sqw) * invs,
      2 * (tmp5 - tmp6) * invs,
      0,
      2 * (tmp3 - tmp4) * invs,
      2 * (tmp5 + tmp6) * invs,
      -sqx - sqy + sqz + sqw,
      0,
      0,
      0,
      0,
      1
    );
  }
  setRotationX(angle) {
    const cosTheta = Math.cos(angle);
    const sinTheta = Math.sin(angle);
    this.setRowMajor(
      1,
      0,
      0,
      0,
      0,
      cosTheta,
      -sinTheta,
      0,
      0,
      sinTheta,
      cosTheta,
      0,
      0,
      0,
      0,
      1
    );
  }
  setRotationY(angle) {
    const cosTheta = Math.cos(angle);
    const sinTheta = Math.sin(angle);
    this.setRowMajor(
      cosTheta,
      0,
      sinTheta,
      0,
      0,
      1,
      0,
      0,
      -sinTheta,
      0,
      cosTheta,
      0,
      0,
      0,
      0,
      1
    );
  }
  setRotationZ(angle) {
    const cosTheta = Math.cos(angle);
    const sinTheta = Math.sin(angle);
    this.setRowMajor(
      cosTheta,
      -sinTheta,
      0,
      0,
      sinTheta,
      cosTheta,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    );
  }
  setAxisAngle(axis, angle) {
    const c2 = Math.cos(angle);
    const s = Math.sin(angle);
    const t = 1 - c2;
    const x = axis.x, y2 = axis.y, z2 = axis.z;
    const tx = t * x, ty = t * y2;
    this.setRowMajor(
      tx * x + c2,
      tx * y2 - s * z2,
      tx * z2 + s * y2,
      0,
      tx * y2 + s * z2,
      ty * y2 + c2,
      ty * z2 - s * x,
      0,
      tx * z2 - s * y2,
      ty * z2 + s * x,
      t * z2 * z2 + c2,
      0,
      0,
      0,
      0,
      1
    );
  }
  setScale(scale) {
    this.setRowMajor(
      scale.x,
      0,
      0,
      0,
      0,
      scale.y,
      0,
      0,
      0,
      0,
      scale.z,
      0,
      0,
      0,
      0,
      1
    );
  }
  getTranslation() {
    return new Vector3(this.mat[12], this.mat[13], this.mat[14]);
  }
  getRotation() {
    return Quaternion.makeMatrix(this);
  }
  getScale() {
    return new Vector3(
      Math.sqrt(this.mat[0] * this.mat[0] + this.mat[1] * this.mat[1] + this.mat[2] * this.mat[2]),
      Math.sqrt(this.mat[4] * this.mat[4] + this.mat[5] * this.mat[5] + this.mat[6] * this.mat[6]),
      Math.sqrt(this.mat[8] * this.mat[8] + this.mat[9] * this.mat[9] + this.mat[10] * this.mat[10])
    );
  }
  setOrthographic(left, right, bottom, top, near, far) {
    this.setRowMajor(
      2 / (right - left),
      0,
      0,
      -(right + left) / (right - left),
      0,
      2 / (top - bottom),
      0,
      -(top + bottom) / (top - bottom),
      0,
      0,
      -2 / (far - near),
      -(far + near) / (far - near),
      0,
      0,
      0,
      1
    );
  }
  setPerspective(fov, aspectRatio, near, far) {
    const yMax = near * Math.tan(fov * Math.PI / 360);
    const xMax = yMax * aspectRatio;
    this.setFrustum(-xMax, xMax, -yMax, yMax, near, far);
  }
  setFrustum(left, right, bottom, top, near, far) {
    this.setRowMajor(
      2 * near / (right - left),
      0,
      (right + left) / (right - left),
      0,
      0,
      2 * near / (top - bottom),
      (top + bottom) / (top - bottom),
      0,
      0,
      0,
      -(far + near) / (far - near),
      -2 * far * near / (far - near),
      0,
      0,
      -1,
      0
    );
  }
  lookAt(eye, target, up = Vector3.UP) {
    const z2 = Vector3.subtract(eye, target);
    z2.normalize();
    const x = Vector3.cross(up, z2);
    x.normalize();
    const y2 = Vector3.cross(z2, x);
    y2.normalize();
    this.setColumnMajor(
      x.x,
      x.y,
      x.z,
      0,
      y2.x,
      y2.y,
      y2.z,
      0,
      z2.x,
      z2.y,
      z2.z,
      0,
      0,
      0,
      0,
      1
    );
    const translation = _Matrix4.fromColumnMajor(
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      eye.x,
      eye.y,
      eye.z,
      1
    );
    this.premultiply(translation);
  }
  multiplyScalar(x) {
    for (let i = 0; i < 16; i++)
      this.mat[i] *= x;
  }
  determinant() {
    const determinant = this.mat[3] * this.mat[6] * this.mat[9] * this.mat[12] - this.mat[2] * this.mat[7] * this.mat[9] * this.mat[12] - this.mat[3] * this.mat[5] * this.mat[10] * this.mat[12] + this.mat[1] * this.mat[7] * this.mat[10] * this.mat[12] + this.mat[2] * this.mat[5] * this.mat[11] * this.mat[12] - this.mat[1] * this.mat[6] * this.mat[11] * this.mat[12] - this.mat[3] * this.mat[6] * this.mat[8] * this.mat[13] + this.mat[2] * this.mat[7] * this.mat[8] * this.mat[13] + this.mat[3] * this.mat[4] * this.mat[10] * this.mat[13] - this.mat[0] * this.mat[7] * this.mat[10] * this.mat[13] - this.mat[2] * this.mat[4] * this.mat[11] * this.mat[13] + this.mat[0] * this.mat[6] * this.mat[11] * this.mat[13] + this.mat[3] * this.mat[5] * this.mat[8] * this.mat[14] - this.mat[1] * this.mat[7] * this.mat[8] * this.mat[14] - this.mat[3] * this.mat[4] * this.mat[9] * this.mat[14] + this.mat[0] * this.mat[7] * this.mat[9] * this.mat[14] + this.mat[1] * this.mat[4] * this.mat[11] * this.mat[14] - this.mat[0] * this.mat[5] * this.mat[11] * this.mat[14] - this.mat[2] * this.mat[5] * this.mat[8] * this.mat[15] + this.mat[1] * this.mat[6] * this.mat[8] * this.mat[15] + this.mat[2] * this.mat[4] * this.mat[9] * this.mat[15] - this.mat[0] * this.mat[6] * this.mat[9] * this.mat[15] - this.mat[1] * this.mat[4] * this.mat[10] * this.mat[15] + this.mat[0] * this.mat[5] * this.mat[10] * this.mat[15];
    return determinant;
  }
  inverse() {
    const determinant = this.determinant();
    if (Math.abs(determinant) < 1e-8)
      return new _Matrix4();
    const inverse = new _Matrix4();
    inverse.mat[0] = (this.mat[6] * this.mat[11] * this.mat[13] - this.mat[7] * this.mat[10] * this.mat[13] + this.mat[7] * this.mat[9] * this.mat[14] - this.mat[5] * this.mat[11] * this.mat[14] - this.mat[6] * this.mat[9] * this.mat[15] + this.mat[5] * this.mat[10] * this.mat[15]) / determinant;
    inverse.mat[1] = (this.mat[3] * this.mat[10] * this.mat[13] - this.mat[2] * this.mat[11] * this.mat[13] - this.mat[3] * this.mat[9] * this.mat[14] + this.mat[1] * this.mat[11] * this.mat[14] + this.mat[2] * this.mat[9] * this.mat[15] - this.mat[1] * this.mat[10] * this.mat[15]) / determinant;
    inverse.mat[2] = (this.mat[2] * this.mat[7] * this.mat[13] - this.mat[3] * this.mat[6] * this.mat[13] + this.mat[3] * this.mat[5] * this.mat[14] - this.mat[1] * this.mat[7] * this.mat[14] - this.mat[2] * this.mat[5] * this.mat[15] + this.mat[1] * this.mat[6] * this.mat[15]) / determinant;
    inverse.mat[3] = (this.mat[3] * this.mat[6] * this.mat[9] - this.mat[2] * this.mat[7] * this.mat[9] - this.mat[3] * this.mat[5] * this.mat[10] + this.mat[1] * this.mat[7] * this.mat[10] + this.mat[2] * this.mat[5] * this.mat[11] - this.mat[1] * this.mat[6] * this.mat[11]) / determinant;
    inverse.mat[4] = (this.mat[7] * this.mat[10] * this.mat[12] - this.mat[6] * this.mat[11] * this.mat[12] - this.mat[7] * this.mat[8] * this.mat[14] + this.mat[4] * this.mat[11] * this.mat[14] + this.mat[6] * this.mat[8] * this.mat[15] - this.mat[4] * this.mat[10] * this.mat[15]) / determinant;
    inverse.mat[5] = (this.mat[2] * this.mat[11] * this.mat[12] - this.mat[3] * this.mat[10] * this.mat[12] + this.mat[3] * this.mat[8] * this.mat[14] - this.mat[0] * this.mat[11] * this.mat[14] - this.mat[2] * this.mat[8] * this.mat[15] + this.mat[0] * this.mat[10] * this.mat[15]) / determinant;
    inverse.mat[6] = (this.mat[3] * this.mat[6] * this.mat[12] - this.mat[2] * this.mat[7] * this.mat[12] - this.mat[3] * this.mat[4] * this.mat[14] + this.mat[0] * this.mat[7] * this.mat[14] + this.mat[2] * this.mat[4] * this.mat[15] - this.mat[0] * this.mat[6] * this.mat[15]) / determinant;
    inverse.mat[7] = (this.mat[2] * this.mat[7] * this.mat[8] - this.mat[3] * this.mat[6] * this.mat[8] + this.mat[3] * this.mat[4] * this.mat[10] - this.mat[0] * this.mat[7] * this.mat[10] - this.mat[2] * this.mat[4] * this.mat[11] + this.mat[0] * this.mat[6] * this.mat[11]) / determinant;
    inverse.mat[8] = (this.mat[5] * this.mat[11] * this.mat[12] - this.mat[7] * this.mat[9] * this.mat[12] + this.mat[7] * this.mat[8] * this.mat[13] - this.mat[4] * this.mat[11] * this.mat[13] - this.mat[5] * this.mat[8] * this.mat[15] + this.mat[4] * this.mat[9] * this.mat[15]) / determinant;
    inverse.mat[9] = (this.mat[3] * this.mat[9] * this.mat[12] - this.mat[1] * this.mat[11] * this.mat[12] - this.mat[3] * this.mat[8] * this.mat[13] + this.mat[0] * this.mat[11] * this.mat[13] + this.mat[1] * this.mat[8] * this.mat[15] - this.mat[0] * this.mat[9] * this.mat[15]) / determinant;
    inverse.mat[10] = (this.mat[1] * this.mat[7] * this.mat[12] - this.mat[3] * this.mat[5] * this.mat[12] + this.mat[3] * this.mat[4] * this.mat[13] - this.mat[0] * this.mat[7] * this.mat[13] - this.mat[1] * this.mat[4] * this.mat[15] + this.mat[0] * this.mat[5] * this.mat[15]) / determinant;
    inverse.mat[11] = (this.mat[3] * this.mat[5] * this.mat[8] - this.mat[1] * this.mat[7] * this.mat[8] - this.mat[3] * this.mat[4] * this.mat[9] + this.mat[0] * this.mat[7] * this.mat[9] + this.mat[1] * this.mat[4] * this.mat[11] - this.mat[0] * this.mat[5] * this.mat[11]) / determinant;
    inverse.mat[12] = (this.mat[6] * this.mat[9] * this.mat[12] - this.mat[5] * this.mat[10] * this.mat[12] - this.mat[6] * this.mat[8] * this.mat[13] + this.mat[4] * this.mat[10] * this.mat[13] + this.mat[5] * this.mat[8] * this.mat[14] - this.mat[4] * this.mat[9] * this.mat[14]) / determinant;
    inverse.mat[13] = (this.mat[1] * this.mat[10] * this.mat[12] - this.mat[2] * this.mat[9] * this.mat[12] + this.mat[2] * this.mat[8] * this.mat[13] - this.mat[0] * this.mat[10] * this.mat[13] - this.mat[1] * this.mat[8] * this.mat[14] + this.mat[0] * this.mat[9] * this.mat[14]) / determinant;
    inverse.mat[14] = (this.mat[2] * this.mat[5] * this.mat[12] - this.mat[1] * this.mat[6] * this.mat[12] - this.mat[2] * this.mat[4] * this.mat[13] + this.mat[0] * this.mat[6] * this.mat[13] + this.mat[1] * this.mat[4] * this.mat[14] - this.mat[0] * this.mat[5] * this.mat[14]) / determinant;
    inverse.mat[15] = (this.mat[1] * this.mat[6] * this.mat[8] - this.mat[2] * this.mat[5] * this.mat[8] + this.mat[2] * this.mat[4] * this.mat[9] - this.mat[0] * this.mat[6] * this.mat[9] - this.mat[1] * this.mat[4] * this.mat[10] + this.mat[0] * this.mat[5] * this.mat[10]) / determinant;
    return inverse;
  }
  invert() {
    const inverseMatrix = this.inverse();
    this.copy(inverseMatrix);
  }
  transpose() {
    return _Matrix4.fromRowMajor(
      this.mat[0],
      this.mat[1],
      this.mat[2],
      this.mat[3],
      this.mat[4],
      this.mat[5],
      this.mat[6],
      this.mat[7],
      this.mat[8],
      this.mat[9],
      this.mat[10],
      this.mat[11],
      this.mat[12],
      this.mat[13],
      this.mat[14],
      this.mat[15]
    );
  }
  setEulerAngles(x, y2, z2, order = "YZX") {
    const a = Math.cos(x);
    const b = Math.sin(x);
    const c2 = Math.cos(y2);
    const d2 = Math.sin(y2);
    const e = Math.cos(z2);
    const f2 = Math.sin(z2);
    if (order == "XYZ") {
      const ae = a * e, af = a * f2, be = b * e, bf = b * f2;
      this.mat[0] = c2 * e;
      this.mat[4] = -c2 * f2;
      this.mat[8] = d2;
      this.mat[1] = af + be * d2;
      this.mat[5] = ae - bf * d2;
      this.mat[9] = -b * c2;
      this.mat[2] = bf - ae * d2;
      this.mat[6] = be + af * d2;
      this.mat[10] = a * c2;
    } else if (order == "YXZ") {
      const ce = c2 * e, cf = c2 * f2, de = d2 * e, df = d2 * f2;
      this.mat[0] = ce + df * b;
      this.mat[4] = de * b - cf;
      this.mat[8] = a * d2;
      this.mat[1] = a * f2;
      this.mat[5] = a * e;
      this.mat[9] = -b;
      this.mat[2] = cf * b - de;
      this.mat[6] = df + ce * b;
      this.mat[10] = a * c2;
    } else if (order == "ZXY") {
      const ce = c2 * e, cf = c2 * f2, de = d2 * e, df = d2 * f2;
      this.mat[0] = ce - df * b;
      this.mat[4] = -a * f2;
      this.mat[8] = de + cf * b;
      this.mat[1] = cf + de * b;
      this.mat[5] = a * e;
      this.mat[9] = df - ce * b;
      this.mat[2] = -a * d2;
      this.mat[6] = b;
      this.mat[10] = a * c2;
    } else if (order === "ZYX") {
      const ae = a * e, af = a * f2, be = b * e, bf = b * f2;
      this.mat[0] = c2 * e;
      this.mat[4] = be * d2 - af;
      this.mat[8] = ae * d2 + bf;
      this.mat[1] = c2 * f2;
      this.mat[5] = bf * d2 + ae;
      this.mat[9] = af * d2 - be;
      this.mat[2] = -d2;
      this.mat[6] = b * c2;
      this.mat[10] = a * c2;
    } else if (order === "YZX") {
      const ac = a * c2, ad = a * d2, bc = b * c2, bd = b * d2;
      this.mat[0] = c2 * e;
      this.mat[4] = bd - ac * f2;
      this.mat[8] = bc * f2 + ad;
      this.mat[1] = f2;
      this.mat[5] = a * e;
      this.mat[9] = -b * e;
      this.mat[2] = -d2 * e;
      this.mat[6] = ad * f2 + bc;
      this.mat[10] = ac - bd * f2;
    } else if (order === "XZY") {
      const ac = a * c2, ad = a * d2, bc = b * c2, bd = b * d2;
      this.mat[0] = c2 * e;
      this.mat[4] = -f2;
      this.mat[8] = d2 * e;
      this.mat[1] = ac * f2 + bd;
      this.mat[5] = a * e;
      this.mat[9] = ad * f2 - bc;
      this.mat[2] = bc * f2 - ad;
      this.mat[6] = b * e;
      this.mat[10] = bd * f2 + ac;
    }
    this.mat[3] = 0;
    this.mat[7] = 0;
    this.mat[11] = 0;
    this.mat[12] = 0;
    this.mat[13] = 0;
    this.mat[14] = 0;
    this.mat[15] = 1;
  }
  compose(position, rotation, scale) {
    this.setScale(scale);
    this.premultiply(_Matrix4.makeRotation(rotation));
    this.mat[12] = position.x;
    this.mat[13] = position.y;
    this.mat[14] = position.z;
  }
  transformPoint(p2) {
    const result = new Vector3();
    const w2 = 1 / (this.mat[3] * p2.x + this.mat[7] * p2.y + this.mat[11] * p2.z + this.mat[15]);
    result.x = w2 * (this.mat[0] * p2.x + this.mat[4] * p2.y + this.mat[8] * p2.z + this.mat[12]);
    result.y = w2 * (this.mat[1] * p2.x + this.mat[5] * p2.y + this.mat[9] * p2.z + this.mat[13]);
    result.z = w2 * (this.mat[2] * p2.x + this.mat[6] * p2.y + this.mat[10] * p2.z + this.mat[14]);
    return result;
  }
  transformVector(v) {
    const result = new Vector3();
    const w2 = 1 / (this.mat[3] * v.x + this.mat[7] * v.y + this.mat[11] * v.z + this.mat[15]);
    result.x = w2 * (this.mat[0] * v.x + this.mat[4] * v.y + this.mat[8] * v.z);
    result.y = w2 * (this.mat[1] * v.x + this.mat[5] * v.y + this.mat[9] * v.z);
    result.z = w2 * (this.mat[2] * v.x + this.mat[6] * v.y + this.mat[10] * v.z);
    return result;
  }
  getColumn(i) {
    return new Vector3(this.mat[i], this.mat[i + 4], this.mat[i + 8]);
  }
  getRow(i) {
    return new Vector3(this.mat[i * 4], this.mat[i * 4 + 1], this.mat[i * 4 + 2]);
  }
  setColumn(col, v) {
    this.mat[col] = v.x;
    this.mat[col + 4] = v.y;
    this.mat[col + 8] = v.z;
  }
  setRow(row, v) {
    this.mat[row * 4] = v.x;
    this.mat[row * 4 + 1] = v.y;
    this.mat[row * 4 + 2] = v.z;
  }
  decompose(containsNegScale) {
    const position = new Vector3();
    const rotation = new Quaternion();
    const scale = new Vector3();
    const matrixCopy = this.clone();
    position.set(matrixCopy.mat[12], matrixCopy.mat[13], matrixCopy.mat[14]);
    matrixCopy.mat[12] = 0;
    matrixCopy.mat[13] = 0;
    matrixCopy.mat[14] = 0;
    matrixCopy.mat[3] = 0;
    matrixCopy.mat[7] = 0;
    matrixCopy.mat[11] = 0;
    matrixCopy.mat[15] = 1;
    if (containsNegScale) {
      let rotationMatrix = new _Matrix4();
      let count = 0;
      let norm;
      do {
        const currentInverseTranspose = rotationMatrix.transpose();
        currentInverseTranspose.invert();
        const nextRotationMatrix = new _Matrix4();
        for (let i = 0; i < 16; i++) {
          nextRotationMatrix.mat[i] = 0.5 * (rotationMatrix.mat[i] + currentInverseTranspose.mat[i]);
        }
        norm = 0;
        for (let i = 0; i < 3; i++) {
          const n = Math.abs(rotationMatrix.mat[i] - nextRotationMatrix.mat[i]) + Math.abs(rotationMatrix.mat[i + 4] - nextRotationMatrix.mat[i + 4]) + Math.abs(rotationMatrix.mat[i + 8] - nextRotationMatrix.mat[i + 8]);
          norm = Math.max(norm, n);
        }
        rotationMatrix = nextRotationMatrix;
        count++;
      } while (count < 100 && norm > Number.EPSILON);
      rotation.setMatrix(rotationMatrix);
      const scaleMatrix = _Matrix4.multiply(rotationMatrix.inverse(), matrixCopy);
      scale.set(scaleMatrix.mat[0], scaleMatrix.mat[5], scaleMatrix.mat[10]);
      const row0 = matrixCopy.getRow(0);
      const row1 = matrixCopy.getRow(1);
      const row2 = matrixCopy.getRow(2);
      row0.normalize();
      row1.normalize();
      row2.normalize();
      const normalizedRotationMatrix = new _Matrix4();
      normalizedRotationMatrix.setRow(0, row0);
      normalizedRotationMatrix.setRow(1, row1);
      normalizedRotationMatrix.setRow(2, row2);
      if (normalizedRotationMatrix.determinant() < 0) {
        scale.x *= -1;
      }
    } else {
      const sx = matrixCopy.getColumn(0).length();
      const sy = matrixCopy.getColumn(1).length();
      const sz = matrixCopy.getColumn(2).length();
      scale.set(sx, sy, sz);
      matrixCopy.multiply(_Matrix4.makeScale(new Vector3(1 / sx, 1 / sy, 1 / sz)));
      rotation.setMatrix(matrixCopy);
    }
    return [position, rotation, scale];
  }
  equals(other) {
    for (let i = 0; i < 16; i++) {
      if (this.mat[i] != other.mat[i])
        return false;
    }
    return true;
  }
  fuzzyEquals(other, epsilon = MathUtils.EPSILON) {
    for (let i = 0; i < 16; i++) {
      if (Math.abs(this.mat[i] - other.mat[i]) < epsilon)
        return false;
    }
    return true;
  }
};
var Matrix4 = _Matrix4;
Matrix4.IDENTITY = new _Matrix4();

// node_modules/gophergfx/src/math/BoundingBox3.ts
var BoundingBox3 = class {
  constructor() {
    this.min = new Vector3();
    this.max = new Vector3();
  }
  copy(box) {
    this.min.copy(box.min);
    this.max.copy(box.max);
  }
  transform(m2) {
    const corners = [];
    corners.push(new Vector3(this.min.x, this.min.y, this.min.z));
    corners.push(new Vector3(this.min.x, this.min.y, this.max.z));
    corners.push(new Vector3(this.min.x, this.max.y, this.min.z));
    corners.push(new Vector3(this.min.x, this.max.y, this.max.z));
    corners.push(new Vector3(this.max.x, this.min.y, this.min.z));
    corners.push(new Vector3(this.max.x, this.min.y, this.max.z));
    corners.push(new Vector3(this.max.x, this.max.y, this.min.z));
    corners.push(new Vector3(this.max.x, this.max.y, this.max.z));
    corners.forEach((p2) => {
      p2.transformPoint(m2);
    });
    this.min.copy(corners[0]);
    this.max.copy(corners[0]);
    for (let i = 1; i < corners.length; i++) {
      this.min.x = Math.min(this.min.x, corners[i].x);
      this.min.y = Math.min(this.min.y, corners[i].y);
      this.min.z = Math.min(this.min.z, corners[i].z);
      this.max.x = Math.max(this.max.x, corners[i].x);
      this.max.y = Math.max(this.max.y, corners[i].y);
      this.max.z = Math.max(this.max.z, corners[i].z);
    }
  }
  intersects(box) {
    const thisCenter = Vector3.add(this.max, this.min);
    thisCenter.multiplyScalar(0.5);
    const otherCenter = Vector3.add(box.max, box.min);
    otherCenter.multiplyScalar(0.5);
    const thisHalfWidth = Vector3.subtract(this.max, this.min);
    thisHalfWidth.multiplyScalar(0.5);
    const otherHalfWidth = Vector3.subtract(box.max, box.min);
    otherHalfWidth.multiplyScalar(0.5);
    if (Math.abs(thisCenter.x - otherCenter.x) > thisHalfWidth.x + otherHalfWidth.x)
      return false;
    else if (Math.abs(thisCenter.y - otherCenter.y) > thisHalfWidth.y + otherHalfWidth.y)
      return false;
    else if (Math.abs(thisCenter.z - otherCenter.z) > thisHalfWidth.z + otherHalfWidth.z)
      return false;
    else
      return true;
  }
  computeBounds(vertices) {
    if (typeof vertices[0] === "number") {
      const vArray = vertices;
      this.max.set(vArray[0], vArray[1], vArray[2]);
      this.min.set(vArray[0], vArray[1], vArray[2]);
      for (let i = 0; i < vArray.length; i += 3) {
        if (vArray[i] > this.max.x)
          this.max.x = vArray[i];
        if (vArray[i] < this.min.x)
          this.min.x = vArray[i];
        if (vArray[i + 1] > this.max.y)
          this.max.y = vArray[i + 1];
        if (vArray[i + 1] < this.min.y)
          this.min.y = vArray[i + 1];
        if (vArray[i + 2] > this.max.z)
          this.max.z = vArray[i + 2];
        if (vArray[i + 2] < this.min.z)
          this.min.z = vArray[i + 2];
      }
    } else {
      this.max.copy(vertices[0]);
      this.min.copy(vertices[0]);
      vertices.forEach((elem) => {
        if (elem.x > this.max.x)
          this.max.x = elem.x;
        if (elem.x < this.min.x)
          this.min.x = elem.x;
        if (elem.y > this.max.y)
          this.max.y = elem.y;
        if (elem.y < this.min.y)
          this.min.y = elem.y;
        if (elem.z > this.max.z)
          this.max.z = elem.z;
        if (elem.z < this.min.z)
          this.min.z = elem.z;
      });
    }
  }
};

// node_modules/gophergfx/src/math/BoundingSphere.ts
var BoundingSphere = class {
  constructor() {
    this.center = new Vector3();
    this.radius = 0;
  }
  copy(circle) {
    this.center.copy(circle.center);
    this.radius = circle.radius;
  }
  transform(m2) {
    this.center.add(m2.getTranslation());
    const radiusVector = new Vector3(this.radius, 0);
    radiusVector.transformVector(m2);
    this.radius = radiusVector.length();
  }
  intersects(circle) {
    const distance = this.center.distanceTo(circle.center);
    if (distance < this.radius + circle.radius)
      return true;
    else
      return false;
  }
  computeBounds(vertices, boundingBox) {
    this.center.copy(boundingBox.min);
    this.center.add(boundingBox.max);
    this.center.multiplyScalar(0.5);
    this.radius = 0;
    if (typeof vertices[0] === "number") {
      const vArray = vertices;
      for (let i = 0; i < vArray.length; i += 3) {
        const distance = Math.sqrt(
          (vArray[i] - this.center.x) * (vArray[i] - this.center.x) + (vArray[i + 1] - this.center.y) * (vArray[i + 1] - this.center.y) + (vArray[i + 2] - this.center.z) * (vArray[i + 2] - this.center.z)
        );
        if (distance > this.radius)
          this.radius = distance;
      }
    } else {
      vertices.forEach((elem) => {
        const distance = elem.distanceTo(this.center);
        if (distance > this.radius)
          this.radius = distance;
      });
    }
  }
};

// node_modules/gophergfx/src/core/Node3.ts
var IntersectionMode3 = /* @__PURE__ */ ((IntersectionMode32) => {
  IntersectionMode32[IntersectionMode32["BOUNDING_SPHERE"] = 0] = "BOUNDING_SPHERE";
  IntersectionMode32[IntersectionMode32["AXIS_ALIGNED_BOUNDING_BOX"] = 1] = "AXIS_ALIGNED_BOUNDING_BOX";
  return IntersectionMode32;
})(IntersectionMode3 || {});
var CoordinateSpace3 = /* @__PURE__ */ ((CoordinateSpace32) => {
  CoordinateSpace32[CoordinateSpace32["LOCAL_SPACE"] = 0] = "LOCAL_SPACE";
  CoordinateSpace32[CoordinateSpace32["WORLD_SPACE"] = 1] = "WORLD_SPACE";
  return CoordinateSpace32;
})(CoordinateSpace3 || {});
var Node3 = class {
  constructor() {
    this._position = new Vector3();
    this._rotation = new Quaternion();
    this._scale = new Vector3(1, 1, 1);
    this.localToParentMatrix = new Matrix4();
    this.localToWorldMatrix = new Matrix4();
    this.localMatrixDirty = false;
    this.localMatrixUpdated = false;
    this.localMatrixNegScale = false;
    this.worldMatrixDirty = false;
    this.children = [];
    this.visible = true;
    this.parent = null;
    this.boundingBox = new BoundingBox3();
    this.boundingSphere = new BoundingSphere();
    this._localBoundingBox = new BoundingBox3();
    this._localBoundingSphere = new BoundingSphere();
    this._worldBoundingBox = new BoundingBox3();
    this._worldBoundingSphere = new BoundingSphere();
    this.localBoundsDirty = false;
    this.worldBoundsDirty = false;
  }
  get position() {
    if (this.localMatrixUpdated) {
      this.decomposeLocalMatrix();
    }
    this.localMatrixDirty = true;
    return this._position;
  }
  set position(value) {
    this.localMatrixDirty = true;
    this._position = value;
  }
  get rotation() {
    if (this.localMatrixUpdated) {
      this.decomposeLocalMatrix();
    }
    this.localMatrixDirty = true;
    return this._rotation;
  }
  set rotation(value) {
    this.localMatrixDirty = true;
    this._rotation = value;
  }
  get scale() {
    if (this.localMatrixUpdated) {
      this.decomposeLocalMatrix();
    }
    this.localMatrixDirty = true;
    return this._scale;
  }
  set scale(value) {
    this.localMatrixDirty = true;
    this._scale = value;
  }
  getLocalToParentMatrix() {
    if (this.localMatrixDirty) {
      this.composeLocalMatrix();
    }
    return this.localToParentMatrix.clone();
  }
  setLocalToParentMatrix(matrix, includesNegScale) {
    this.localToParentMatrix.copy(matrix);
    this.localMatrixUpdated = true;
    this.localMatrixNegScale = includesNegScale;
    this.worldMatrixDirty = true;
    this.localBoundsDirty = true;
  }
  get localBoundingBox() {
    if (this.localBoundsDirty) {
      this.updateLocalBounds();
    }
    return this._localBoundingBox;
  }
  set localBoundingBox(value) {
    this._localBoundingBox = value;
  }
  get localBoundingSphere() {
    if (this.localBoundsDirty) {
      this.updateLocalBounds();
    }
    return this._localBoundingSphere;
  }
  set localBoundingSphere(value) {
    this._localBoundingSphere = value;
  }
  get worldBoundingBox() {
    if (this.worldBoundsDirty) {
      this.updateWorldBounds();
    }
    return this._worldBoundingBox;
  }
  set worldBoundingBox(value) {
    this._worldBoundingBox = value;
  }
  get worldBoundingSphere() {
    if (this.worldBoundsDirty) {
      this.updateWorldBounds();
    }
    return this._worldBoundingSphere;
  }
  set worldBoundingSphere(value) {
    this._worldBoundingSphere = value;
  }
  traverseSceneGraph(parentMatrixDirty = false) {
    const worldMatrixDirty = parentMatrixDirty || this.localMatrixDirty || this.worldMatrixDirty;
    if (this.localMatrixDirty) {
      this.composeLocalMatrix();
    }
    if (worldMatrixDirty) {
      this.localToWorldMatrix.copy(this.localToParentMatrix);
      if (this.parent) {
        this.localToWorldMatrix.premultiply(this.parent.localToWorldMatrix);
      }
      this.worldBoundsDirty = true;
      this.worldMatrixDirty = false;
    }
    this.children.forEach((elem) => {
      elem.traverseSceneGraph(worldMatrixDirty);
    });
  }
  updateWorldMatrix() {
    if (this.localMatrixDirty) {
      this.composeLocalMatrix();
    }
    this.localToWorldMatrix.copy(this.localToParentMatrix);
    if (this.parent) {
      this.parent.updateWorldMatrix();
      this.localToWorldMatrix.premultiply(this.parent.localToWorldMatrix);
    }
    this.worldBoundsDirty = true;
    this.worldMatrixDirty = false;
  }
  add(child) {
    this.children.push(child);
    child.parent = this;
  }
  remove() {
    if (this.parent == null)
      return false;
    else
      return this.parent.removeChild(this) != null;
  }
  removeChild(child) {
    const index = this.children.indexOf(child);
    if (index == -1) {
      return null;
    } else {
      const removedElement = this.children.splice(index, 1);
      removedElement[0].parent = null;
      return removedElement[0];
    }
  }
  draw(parent, camera, lightManager) {
    if (!this.visible)
      return;
    this.children.forEach((elem) => {
      elem.draw(this, camera, lightManager);
    });
  }
  setLights(lightManager) {
    this.children.forEach((elem) => {
      elem.setLights(lightManager);
    });
  }
  lookAt(target, up = Vector3.UP, coordinateSpace = 0 /* LOCAL_SPACE */) {
    if (coordinateSpace == 0 /* LOCAL_SPACE */) {
      this._rotation.lookAt(this.position, target, up);
      this.localMatrixDirty = true;
    } else {
      this.updateWorldMatrix();
      const worldPosition = this.localToWorldMatrix.getTranslation();
      this._rotation.lookAt(worldPosition, target, up);
      this.localMatrixDirty = true;
    }
  }
  composeLocalMatrix() {
    this.localMatrixNegScale = this._scale.x < 0 || this._scale.y < 0 || this._scale.z < 0;
    this.localMatrixDirty = false;
    this.localMatrixUpdated = false;
    this.worldMatrixDirty = true;
    this.localBoundsDirty = true;
    this.localToParentMatrix.compose(this._position, this._rotation, this._scale);
  }
  decomposeLocalMatrix() {
    this.localMatrixDirty = false;
    this.localMatrixUpdated = false;
    [this._position, this._rotation, this._scale] = this.localToParentMatrix.decompose(this.localMatrixNegScale);
  }
  updateLocalBounds() {
    this._localBoundingBox.copy(this.boundingBox);
    this._localBoundingBox.transform(this.localToParentMatrix);
    this._localBoundingSphere.copy(this.boundingSphere);
    this._localBoundingSphere.transform(this.localToParentMatrix);
    this.localBoundsDirty = false;
  }
  updateWorldBounds() {
    this._worldBoundingBox.copy(this.boundingBox);
    this._worldBoundingBox.transform(this.localToWorldMatrix);
    this._worldBoundingSphere.copy(this.boundingSphere);
    this._worldBoundingSphere.transform(this.localToWorldMatrix);
    this.worldBoundsDirty = false;
  }
  intersects(other, mode = 0 /* BOUNDING_SPHERE */, space = 0 /* LOCAL_SPACE */) {
    if (space == 0 /* LOCAL_SPACE */) {
      if (this.localMatrixDirty)
        this.composeLocalMatrix();
      if (other.localMatrixDirty)
        other.composeLocalMatrix();
      if (this.localBoundsDirty)
        this.updateLocalBounds();
      if (other.localBoundsDirty)
        other.updateLocalBounds();
      if (mode == 0 /* BOUNDING_SPHERE */)
        return this._localBoundingSphere.intersects(other._localBoundingSphere);
      else if (mode == 1 /* AXIS_ALIGNED_BOUNDING_BOX */)
        return this._localBoundingBox.intersects(other._localBoundingBox);
      else
        return false;
    } else {
      if (this.localMatrixDirty || this.worldMatrixDirty)
        this.updateWorldMatrix();
      if (this.localMatrixDirty || this.worldMatrixDirty)
        other.updateWorldMatrix();
      if (this.worldBoundsDirty)
        this.updateWorldBounds();
      if (other.worldBoundsDirty)
        other.updateWorldBounds();
      if (mode == 0 /* BOUNDING_SPHERE */)
        return this._worldBoundingSphere.intersects(other._worldBoundingSphere);
      else if (mode == 1 /* AXIS_ALIGNED_BOUNDING_BOX */)
        return this._worldBoundingBox.intersects(other._worldBoundingBox);
      else
        return false;
    }
  }
};

// node_modules/gophergfx/src/core/Camera.ts
var Camera = class extends Node3 {
  constructor() {
    super();
    this.fov = 0;
    this.aspectRatio = 0;
    this.near = 0;
    this.far = 0;
    this.left = 0;
    this.right = 0;
    this.projectionMatrixDirty = true;
    this.projectionMatrix = new Matrix4();
    this.viewMatrix = new Matrix4();
  }
  setPerspectiveCamera(fov, aspectRatio, near, far) {
    this.fov = fov;
    this.aspectRatio = aspectRatio;
    this.near = near;
    this.far = far;
    this.projectionMatrixDirty = true;
    this.projectionMatrix.setPerspective(fov, aspectRatio, near, far);
  }
  setOrthographicCamera(left, right, bottom, top, near, far) {
    this.left = left;
    this.right = right;
    this.aspectRatio = Math.abs((right - left) / (top - bottom));
    this.near = near;
    this.far = far;
    this.projectionMatrixDirty = true;
    this.projectionMatrix.setOrthographic(left, right, bottom, top, near, far);
  }
  updateWorldMatrix() {
    super.updateWorldMatrix();
    this.viewMatrix = this.localToWorldMatrix.inverse();
  }
  getAspectRatio() {
    return this.aspectRatio;
  }
  getNear() {
    return this.near;
  }
  getFar() {
    return this.far;
  }
  getLeft() {
    return this.left;
  }
  getRight() {
    return this.right;
  }
};

// node_modules/gophergfx/src/math/Matrix3.ts
var _Matrix3 = class {
  static multiply(lhs, rhs) {
    const m2 = new _Matrix3();
    m2.mat[0] = rhs.mat[0] * lhs.mat[0] + rhs.mat[1] * lhs.mat[3] + rhs.mat[2] * lhs.mat[6];
    m2.mat[1] = rhs.mat[0] * lhs.mat[1] + rhs.mat[1] * lhs.mat[4] + rhs.mat[2] * lhs.mat[7];
    m2.mat[2] = rhs.mat[0] * lhs.mat[2] + rhs.mat[1] * lhs.mat[5] + rhs.mat[2] * lhs.mat[8];
    m2.mat[3] = rhs.mat[3] * lhs.mat[0] + rhs.mat[4] * lhs.mat[3] + rhs.mat[5] * lhs.mat[6];
    m2.mat[4] = rhs.mat[3] * lhs.mat[1] + rhs.mat[4] * lhs.mat[4] + rhs.mat[5] * lhs.mat[7];
    m2.mat[5] = rhs.mat[3] * lhs.mat[2] + rhs.mat[4] * lhs.mat[5] + rhs.mat[5] * lhs.mat[8];
    m2.mat[6] = rhs.mat[6] * lhs.mat[0] + rhs.mat[7] * lhs.mat[3] + rhs.mat[8] * lhs.mat[6];
    m2.mat[7] = rhs.mat[6] * lhs.mat[1] + rhs.mat[7] * lhs.mat[4] + rhs.mat[8] * lhs.mat[7];
    m2.mat[8] = rhs.mat[6] * lhs.mat[2] + rhs.mat[7] * lhs.mat[5] + rhs.mat[8] * lhs.mat[8];
    return m2;
  }
  static copy(m2) {
    const mat = new _Matrix3();
    mat.copy(m2);
    return mat;
  }
  static fromRowMajor(n1, n2, n3, n4, n5, n6, n7, n8, n9) {
    const matrix = new _Matrix3();
    matrix.setRowMajor(n1, n2, n3, n4, n5, n6, n7, n8, n9);
    return matrix;
  }
  static fromColumnMajor(n1, n2, n3, n4, n5, n6, n7, n8, n9) {
    const matrix = new _Matrix3();
    matrix.setColumnMajor(n1, n2, n3, n4, n5, n6, n7, n8, n9);
    return matrix;
  }
  static makeTranslation(v) {
    return _Matrix3.fromRowMajor(
      1,
      0,
      v.x,
      0,
      1,
      v.y,
      0,
      0,
      1
    );
  }
  static makeRotation(angle) {
    const cosTheta = Math.cos(angle);
    const sinTheta = Math.sin(angle);
    return _Matrix3.fromRowMajor(
      cosTheta,
      -sinTheta,
      0,
      sinTheta,
      cosTheta,
      0,
      0,
      0,
      1
    );
  }
  static makeScale(scale) {
    return _Matrix3.fromRowMajor(
      scale.x,
      0,
      0,
      0,
      scale.y,
      0,
      0,
      0,
      1
    );
  }
  static makeShear(shear) {
    return _Matrix3.fromRowMajor(
      1,
      Math.tan(shear.x),
      0,
      Math.tan(shear.y),
      1,
      0,
      0,
      0,
      1
    );
  }
  static compose(position = Vector2.ZERO, rotation = 0, scale = Vector2.ONE) {
    const m2 = _Matrix3.makeScale(scale);
    m2.premultiply(_Matrix3.makeRotation(rotation));
    m2.mat[6] = position.x;
    m2.mat[7] = position.y;
    return m2;
  }
  static transformPoint(v, m2) {
    const result = new Vector2();
    const w2 = 1 / (m2.mat[2] * v.x + m2.mat[5] * v.y + m2.mat[8]);
    result.x = w2 * (m2.mat[0] * v.x + m2.mat[3] * v.y + m2.mat[6]);
    result.y = w2 * (m2.mat[1] * v.x + m2.mat[4] * v.y + m2.mat[7]);
    return result;
  }
  static transformVector(v, m2) {
    const result = new Vector2();
    const w2 = 1 / (m2.mat[2] * v.x + m2.mat[5] * v.y + m2.mat[8]);
    result.x = w2 * (m2.mat[0] * v.x + m2.mat[3] * v.y);
    result.y = w2 * (m2.mat[1] * v.x + m2.mat[4] * v.y);
    return result;
  }
  constructor() {
    this.mat = [
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ];
  }
  setColumnMajor(n1, n2, n3, n4, n5, n6, n7, n8, n9) {
    this.mat[0] = n1;
    this.mat[1] = n2;
    this.mat[2] = n3;
    this.mat[3] = n4;
    this.mat[4] = n5;
    this.mat[5] = n6;
    this.mat[6] = n7;
    this.mat[7] = n8;
    this.mat[8] = n9;
  }
  setRowMajor(n1, n2, n3, n4, n5, n6, n7, n8, n9) {
    this.mat[0] = n1;
    this.mat[1] = n4;
    this.mat[2] = n7;
    this.mat[3] = n2;
    this.mat[4] = n5;
    this.mat[5] = n8;
    this.mat[6] = n3;
    this.mat[7] = n6;
    this.mat[8] = n9;
  }
  copy(m2) {
    for (let i = 0; i < 9; i++)
      this.mat[i] = m2.mat[i];
  }
  clone() {
    const matrix = new _Matrix3();
    for (let i = 0; i < 9; i++)
      matrix.mat[i] = this.mat[i];
    return matrix;
  }
  element(row, col) {
    return this.mat[col * 3 + row];
  }
  set(value, row, col) {
    this.mat[col * 3 + row] = value;
  }
  multiply(rhs) {
    const lhs = this.clone();
    this.mat[0] = rhs.mat[0] * lhs.mat[0] + rhs.mat[1] * lhs.mat[3] + rhs.mat[2] * lhs.mat[6];
    this.mat[1] = rhs.mat[0] * lhs.mat[1] + rhs.mat[1] * lhs.mat[4] + rhs.mat[2] * lhs.mat[7];
    this.mat[2] = rhs.mat[0] * lhs.mat[2] + rhs.mat[1] * lhs.mat[5] + rhs.mat[2] * lhs.mat[8];
    this.mat[3] = rhs.mat[3] * lhs.mat[0] + rhs.mat[4] * lhs.mat[3] + rhs.mat[5] * lhs.mat[6];
    this.mat[4] = rhs.mat[3] * lhs.mat[1] + rhs.mat[4] * lhs.mat[4] + rhs.mat[5] * lhs.mat[7];
    this.mat[5] = rhs.mat[3] * lhs.mat[2] + rhs.mat[4] * lhs.mat[5] + rhs.mat[5] * lhs.mat[8];
    this.mat[6] = rhs.mat[6] * lhs.mat[0] + rhs.mat[7] * lhs.mat[3] + rhs.mat[8] * lhs.mat[6];
    this.mat[7] = rhs.mat[6] * lhs.mat[1] + rhs.mat[7] * lhs.mat[4] + rhs.mat[8] * lhs.mat[7];
    this.mat[8] = rhs.mat[6] * lhs.mat[2] + rhs.mat[7] * lhs.mat[5] + rhs.mat[8] * lhs.mat[8];
  }
  premultiply(lhs) {
    const rhs = this.clone();
    this.mat[0] = rhs.mat[0] * lhs.mat[0] + rhs.mat[1] * lhs.mat[3] + rhs.mat[2] * lhs.mat[6];
    this.mat[1] = rhs.mat[0] * lhs.mat[1] + rhs.mat[1] * lhs.mat[4] + rhs.mat[2] * lhs.mat[7];
    this.mat[2] = rhs.mat[0] * lhs.mat[2] + rhs.mat[1] * lhs.mat[5] + rhs.mat[2] * lhs.mat[8];
    this.mat[3] = rhs.mat[3] * lhs.mat[0] + rhs.mat[4] * lhs.mat[3] + rhs.mat[5] * lhs.mat[6];
    this.mat[4] = rhs.mat[3] * lhs.mat[1] + rhs.mat[4] * lhs.mat[4] + rhs.mat[5] * lhs.mat[7];
    this.mat[5] = rhs.mat[3] * lhs.mat[2] + rhs.mat[4] * lhs.mat[5] + rhs.mat[5] * lhs.mat[8];
    this.mat[6] = rhs.mat[6] * lhs.mat[0] + rhs.mat[7] * lhs.mat[3] + rhs.mat[8] * lhs.mat[6];
    this.mat[7] = rhs.mat[6] * lhs.mat[1] + rhs.mat[7] * lhs.mat[4] + rhs.mat[8] * lhs.mat[7];
    this.mat[8] = rhs.mat[6] * lhs.mat[2] + rhs.mat[7] * lhs.mat[5] + rhs.mat[8] * lhs.mat[8];
  }
  setTranslation(v) {
    this.setRowMajor(
      1,
      0,
      v.x,
      0,
      1,
      v.y,
      0,
      0,
      1
    );
  }
  setRotation(angle) {
    const cosTheta = Math.cos(angle);
    const sinTheta = Math.sin(angle);
    this.setRowMajor(
      cosTheta,
      -sinTheta,
      0,
      sinTheta,
      cosTheta,
      0,
      0,
      0,
      1
    );
  }
  setScale(scale) {
    this.setRowMajor(
      scale.x,
      0,
      0,
      0,
      scale.y,
      0,
      0,
      0,
      1
    );
  }
  setShear(shear) {
    this.setRowMajor(
      1,
      Math.tan(shear.x),
      0,
      Math.tan(shear.y),
      1,
      0,
      0,
      0,
      1
    );
  }
  getTranslation() {
    return new Vector2(this.mat[6], this.mat[7]);
  }
  getRotation() {
    return Math.atan2(this.mat[1], this.mat[0]);
  }
  getScale() {
    return new Vector2(
      Math.sqrt(this.mat[0] * this.mat[0] + this.mat[1] * this.mat[1]),
      Math.sqrt(this.mat[3] * this.mat[3] + this.mat[4] * this.mat[4])
    );
  }
  getShear() {
    return new Vector2(
      Math.atan2(this.mat[3], this.mat[4]),
      Math.atan2(this.mat[1], this.mat[0])
    );
  }
  multiplyScalar(x) {
    for (let i = 0; i < 9; i++)
      this.mat[i] *= x;
  }
  inverse() {
    const inverse = new _Matrix3();
    const det = this.mat[0] * this.mat[4] * this.mat[8] + this.mat[1] * this.mat[5] * this.mat[6] + this.mat[2] * this.mat[3] * this.mat[7] - this.mat[0] * this.mat[5] * this.mat[7] - this.mat[1] * this.mat[3] * this.mat[8] - this.mat[2] * this.mat[4] * this.mat[6];
    this.mat[0] = (this.mat[4] * this.mat[8] - this.mat[5] * this.mat[7]) / det;
    this.mat[1] = (this.mat[2] * this.mat[7] - this.mat[1] * this.mat[8]) / det;
    this.mat[2] = (this.mat[1] * this.mat[5] - this.mat[2] * this.mat[4]) / det;
    this.mat[3] = (this.mat[5] * this.mat[6] - this.mat[3] * this.mat[8]) / det;
    this.mat[4] = (this.mat[0] * this.mat[8] - this.mat[2] * this.mat[6]) / det;
    this.mat[5] = (this.mat[2] * this.mat[3] - this.mat[0] * this.mat[5]) / det;
    this.mat[6] = (this.mat[3] * this.mat[7] - this.mat[4] * this.mat[6]) / det;
    this.mat[7] = (this.mat[1] * this.mat[6] - this.mat[0] * this.mat[7]) / det;
    this.mat[8] = (this.mat[0] * this.mat[4] - this.mat[1] * this.mat[3]) / det;
    return inverse;
  }
  invert() {
    const inverseMatrix = this.inverse();
    this.copy(inverseMatrix);
  }
  transpose() {
    return _Matrix3.fromRowMajor(
      this.mat[0],
      this.mat[1],
      this.mat[2],
      this.mat[3],
      this.mat[4],
      this.mat[5],
      this.mat[6],
      this.mat[7],
      this.mat[8]
    );
  }
  compose(position, rotation, scale, shear) {
    this.setScale(scale);
    if (shear) {
      this.premultiply(_Matrix3.makeShear(shear));
    }
    this.premultiply(_Matrix3.makeRotation(rotation));
    this.mat[6] = position.x;
    this.mat[7] = position.y;
  }
  transformPoint(v) {
    const result = new Vector2();
    const w2 = 1 / (this.mat[2] * v.x + this.mat[5] * v.y + this.mat[8]);
    result.x = w2 * (this.mat[0] * v.x + this.mat[3] * v.y + this.mat[6]);
    result.y = w2 * (this.mat[1] * v.x + this.mat[4] * v.y + this.mat[7]);
    return result;
  }
  transformVector(v) {
    const result = new Vector2();
    const w2 = 1 / (this.mat[2] * v.x + this.mat[5] * v.y + this.mat[8]);
    result.x = w2 * (this.mat[0] * v.x + this.mat[3] * v.y);
    result.y = w2 * (this.mat[1] * v.x + this.mat[4] * v.y);
    return result;
  }
  getColumn(i) {
    return new Vector2(this.mat[i], this.mat[i + 3]);
  }
  getRow(i) {
    return new Vector2(this.mat[i * 3], this.mat[i * 3 + 1]);
  }
  setColumn(col, v) {
    this.mat[col] = v.x;
    this.mat[col + 3] = v.y;
  }
  setRow(row, v) {
    this.mat[row * 3] = v.x;
    this.mat[row * 3 + 1] = v.y;
  }
  decompose() {
    const position = new Vector2();
    let rotation = 0;
    const scale = new Vector2();
    position.set(this.mat[6], this.mat[7]);
    let a = this.mat[0];
    let b = this.mat[1];
    let c2 = this.mat[3];
    let d2 = this.mat[4];
    if (a * d2 == b * c2) {
      return [position, rotation, scale, null];
    }
    scale.x = Math.sqrt(a * a + b * b);
    a /= scale.x;
    b /= scale.x;
    let xyShear = a * c2 + b * d2;
    c2 -= a * xyShear;
    d2 -= b * xyShear;
    scale.y = Math.sqrt(c2 * c2 + d2 * d2);
    c2 /= scale.y;
    d2 /= scale.y;
    xyShear /= scale.y;
    if (a * d2 < b * c2) {
      a = -a;
      b = -b;
      c2 = -c2;
      d2 = -d2;
      xyShear = -xyShear;
      scale.x = -scale.x;
    }
    rotation = Math.atan2(b, a);
    if (Math.abs(xyShear) < 1e-4)
      return [position, rotation, scale, null];
    else
      return [position, rotation, scale, new Vector2(Math.atan(xyShear), 0)];
  }
};
var Matrix3 = _Matrix3;
Matrix3.IDENTITY = new _Matrix3();

// node_modules/gophergfx/src/math/BoundingBox2.ts
var BoundingBox2 = class {
  constructor() {
    this.min = new Vector2();
    this.max = new Vector2();
  }
  copy(box) {
    this.min.copy(box.min);
    this.max.copy(box.max);
  }
  transform(m2) {
    const topLeft = new Vector2(this.min.x, this.max.y);
    const topRight = new Vector2(this.max.x, this.max.y);
    const bottomLeft = new Vector2(this.min.x, this.min.y);
    const bottomRight = new Vector2(this.max.x, this.min.y);
    topLeft.transformPoint(m2);
    topRight.transformPoint(m2);
    bottomLeft.transformPoint(m2);
    bottomRight.transformPoint(m2);
    this.min.x = Math.min(topLeft.x, Math.min(topRight.x, Math.min(bottomLeft.x, bottomRight.x)));
    this.min.y = Math.min(topLeft.y, Math.min(topRight.y, Math.min(bottomLeft.y, bottomRight.y)));
    this.max.x = Math.max(topLeft.x, Math.max(topRight.x, Math.max(bottomLeft.x, bottomRight.x)));
    this.max.y = Math.max(topLeft.y, Math.max(topRight.y, Math.max(bottomLeft.y, bottomRight.y)));
  }
  intersects(box) {
    const thisCenter = Vector2.add(this.max, this.min);
    thisCenter.multiplyScalar(0.5);
    const otherCenter = Vector2.add(box.max, box.min);
    otherCenter.multiplyScalar(0.5);
    const thisHalfWidth = Vector2.subtract(this.max, this.min);
    thisHalfWidth.multiplyScalar(0.5);
    const otherHalfWidth = Vector2.subtract(box.max, box.min);
    otherHalfWidth.multiplyScalar(0.5);
    if (Math.abs(thisCenter.x - otherCenter.x) > thisHalfWidth.x + otherHalfWidth.x)
      return false;
    else if (Math.abs(thisCenter.y - otherCenter.y) > thisHalfWidth.y + otherHalfWidth.y)
      return false;
    else
      return true;
  }
  computeBounds(vertices) {
    if (typeof vertices[0] === "number") {
      const vArray = vertices;
      this.max.set(vArray[0], vArray[1]);
      this.min.set(vArray[0], vArray[1]);
      for (let i = 0; i < vArray.length; i += 3) {
        if (vArray[i] > this.max.x)
          this.max.x = vArray[i];
        if (vArray[i] < this.min.x)
          this.min.x = vArray[i];
        if (vArray[i + 1] > this.max.y)
          this.max.y = vArray[i + 1];
        if (vArray[i + 1] < this.min.y)
          this.min.y = vArray[i + 1];
      }
    } else {
      this.max.copy(vertices[0]);
      this.min.copy(vertices[0]);
      vertices.forEach((elem) => {
        if (elem.x > this.max.x)
          this.max.x = elem.x;
        if (elem.x < this.min.x)
          this.min.x = elem.x;
        if (elem.y > this.max.y)
          this.max.y = elem.y;
        if (elem.y < this.min.y)
          this.min.y = elem.y;
      });
    }
  }
};

// node_modules/gophergfx/src/math/BoundingCircle.ts
var BoundingCircle = class {
  constructor() {
    this.center = new Vector2();
    this.radius = 0;
  }
  copy(circle) {
    this.center.copy(circle.center);
    this.radius = circle.radius;
  }
  transform(m2) {
    this.center.add(m2.getTranslation());
    const radiusVector = new Vector2(this.radius, 0);
    radiusVector.transformVector(m2);
    this.radius = radiusVector.length();
  }
  intersects(circle) {
    const distance = this.center.distanceTo(circle.center);
    if (distance < this.radius + circle.radius)
      return true;
    else
      return false;
  }
  computeBounds(vertices, boundingBox) {
    this.center.copy(boundingBox.min);
    this.center.add(boundingBox.max);
    this.center.multiplyScalar(0.5);
    this.radius = 0;
    if (typeof vertices[0] === "number") {
      const vArray = vertices;
      for (let i = 0; i < vArray.length; i += 3) {
        const distance = Math.sqrt(
          (vArray[i] - this.center.x) * (vArray[i] - this.center.x) + (vArray[i + 1] - this.center.y) * (vArray[i + 1] - this.center.y)
        );
        if (distance > this.radius)
          this.radius = distance;
      }
    } else {
      vertices.forEach((elem) => {
        const distance = elem.distanceTo(this.center);
        if (distance > this.radius)
          this.radius = distance;
      });
    }
  }
};

// node_modules/gophergfx/src/core/Node2.ts
var IntersectionMode2 = /* @__PURE__ */ ((IntersectionMode22) => {
  IntersectionMode22[IntersectionMode22["BOUNDING_CIRCLE"] = 0] = "BOUNDING_CIRCLE";
  IntersectionMode22[IntersectionMode22["AXIS_ALIGNED_BOUNDING_BOX"] = 1] = "AXIS_ALIGNED_BOUNDING_BOX";
  return IntersectionMode22;
})(IntersectionMode2 || {});
var CoordinateSpace2 = /* @__PURE__ */ ((CoordinateSpace22) => {
  CoordinateSpace22[CoordinateSpace22["LOCAL_SPACE"] = 0] = "LOCAL_SPACE";
  CoordinateSpace22[CoordinateSpace22["WORLD_SPACE"] = 1] = "WORLD_SPACE";
  return CoordinateSpace22;
})(CoordinateSpace2 || {});
var Node2 = class {
  constructor() {
    this.children = [];
    this._position = new Vector2();
    this._rotation = 0;
    this._scale = new Vector2(1, 1);
    this._shear = null;
    this.localToParentMatrix = new Matrix3();
    this.localToWorldMatrix = new Matrix3();
    this.localMatrixDirty = false;
    this.localMatrixUpdated = false;
    this.worldMatrixDirty = false;
    this.layer = 0;
    this.visible = true;
    this.parent = null;
    this.boundingBox = new BoundingBox2();
    this.boundingCircle = new BoundingCircle();
    this._localBoundingBox = new BoundingBox2();
    this._localBoundingCircle = new BoundingCircle();
    this._worldBoundingBox = new BoundingBox2();
    this._worldBoundingCircle = new BoundingCircle();
    this.localBoundsDirty = false;
    this.worldBoundsDirty = false;
  }
  get position() {
    if (this.localMatrixUpdated) {
      this.decomposeLocalMatrix();
    }
    this.localMatrixDirty = true;
    return this._position;
  }
  set position(value) {
    this.localMatrixDirty = true;
    this._position = value;
  }
  get rotation() {
    if (this.localMatrixUpdated) {
      this.decomposeLocalMatrix();
    }
    this.localMatrixDirty = true;
    return this._rotation;
  }
  set rotation(value) {
    this.localMatrixDirty = true;
    this._rotation = value;
  }
  get scale() {
    if (this.localMatrixUpdated) {
      this.decomposeLocalMatrix();
    }
    this.localMatrixDirty = true;
    return this._scale;
  }
  set scale(value) {
    this.localMatrixDirty = true;
    this._scale = value;
  }
  get shear() {
    if (this.localMatrixUpdated) {
      this.decomposeLocalMatrix();
    }
    if (!this._shear) {
      this._shear = new Vector2();
    }
    this.localMatrixDirty = true;
    return this._shear;
  }
  set shear(value) {
    if (!this._shear) {
      this._shear = new Vector2();
    }
    this.localMatrixDirty = true;
    this._shear = value;
  }
  getLocalToParentMatrix() {
    if (this.localMatrixDirty) {
      this.composeLocalMatrix();
    }
    return this.localToParentMatrix.clone();
  }
  setLocalToParentMatrix(matrix) {
    this.localToParentMatrix.copy(matrix);
    this.localMatrixUpdated = true;
    this.worldMatrixDirty = true;
    this.localBoundsDirty = true;
  }
  get localBoundingBox() {
    if (this.localBoundsDirty) {
      this.updateLocalBounds();
    }
    return this._localBoundingBox;
  }
  set localBoundingBox(value) {
    this._localBoundingBox = value;
  }
  get localBoundingCircle() {
    if (this.localBoundsDirty) {
      this.updateLocalBounds();
    }
    return this._localBoundingCircle;
  }
  set localBoundingSphere(value) {
    this._localBoundingCircle = value;
  }
  get worldBoundingBox() {
    if (this.worldBoundsDirty) {
      this.updateWorldBounds();
    }
    return this._worldBoundingBox;
  }
  set worldBoundingBox(value) {
    this._worldBoundingBox = value;
  }
  get worldBoundingCircle() {
    if (this.worldBoundsDirty) {
      this.updateWorldBounds();
    }
    return this._worldBoundingCircle;
  }
  set worldBoundingSphere(value) {
    this._worldBoundingCircle = value;
  }
  draw() {
    if (!this.visible)
      return;
    this.children.forEach((elem) => {
      elem.draw();
    });
  }
  traverseSceneGraph(parentMatrixDirty = false) {
    const worldMatrixDirty = parentMatrixDirty || this.localMatrixDirty || this.worldMatrixDirty;
    if (this.localMatrixDirty) {
      this.composeLocalMatrix();
    }
    if (worldMatrixDirty) {
      this.localToWorldMatrix.copy(this.localToParentMatrix);
      if (this.parent) {
        this.localToWorldMatrix.premultiply(this.parent.localToWorldMatrix);
      }
      this.worldBoundsDirty = true;
      this.worldMatrixDirty = false;
    }
    this.children.forEach((elem) => {
      elem.traverseSceneGraph(worldMatrixDirty);
    });
  }
  updateWorldMatrix() {
    if (this.localMatrixDirty) {
      this.composeLocalMatrix();
    }
    this.localToWorldMatrix.copy(this.localToParentMatrix);
    if (this.parent) {
      this.parent.updateWorldMatrix();
      this.localToWorldMatrix.premultiply(this.parent.localToWorldMatrix);
    }
    this.worldBoundsDirty = true;
    this.worldMatrixDirty = false;
  }
  add(child) {
    this.children.push(child);
    child.parent = this;
  }
  remove() {
    if (this.parent == null)
      return false;
    else
      return this.parent.removeChild(this) != null;
  }
  removeChild(child) {
    const index = this.children.indexOf(child);
    if (index == -1) {
      return null;
    } else {
      const removedElement = this.children.splice(index, 1);
      removedElement[0].parent = null;
      return removedElement[0];
    }
  }
  lookAt(target, lookVector = Vector2.UP, coordinateSpace = 0 /* LOCAL_SPACE */) {
    if (coordinateSpace == 0 /* LOCAL_SPACE */) {
      const targetVector = Vector2.subtract(target, this.position);
      if (targetVector.length() > 0) {
        this._rotation = lookVector.angleBetweenSigned(targetVector);
        this.localMatrixDirty = true;
      }
    } else {
      this.updateWorldMatrix();
      const worldPosition = this.localToWorldMatrix.getTranslation();
      const targetVector = Vector2.subtract(target, worldPosition);
      if (targetVector.length() > 0) {
        const worldLookVector = this.localToWorldMatrix.transformVector(lookVector);
        this._rotation += worldLookVector.angleBetweenSigned(targetVector);
        this.localMatrixDirty = true;
      }
    }
  }
  composeLocalMatrix() {
    this.localMatrixDirty = false;
    this.localMatrixUpdated = false;
    this.worldMatrixDirty = true;
    this.localBoundsDirty = true;
    this.localToParentMatrix.compose(this._position, this._rotation, this._scale, this._shear);
  }
  decomposeLocalMatrix() {
    this.localMatrixDirty = false;
    this.localMatrixUpdated = false;
    [this._position, this._rotation, this._scale, this._shear] = this.localToParentMatrix.decompose();
  }
  updateLocalBounds() {
    this._localBoundingBox.copy(this.boundingBox);
    this._localBoundingBox.transform(this.localToParentMatrix);
    this._localBoundingCircle.copy(this.boundingCircle);
    this._localBoundingCircle.transform(this.localToParentMatrix);
    this.localBoundsDirty = false;
  }
  updateWorldBounds() {
    this._worldBoundingBox.copy(this.boundingBox);
    this._worldBoundingBox.transform(this.localToWorldMatrix);
    this._worldBoundingCircle.copy(this.boundingCircle);
    this._worldBoundingCircle.transform(this.localToWorldMatrix);
    this.worldBoundsDirty = false;
  }
  intersects(other, mode = 0 /* BOUNDING_CIRCLE */, space = 0 /* LOCAL_SPACE */) {
    if (space == 0 /* LOCAL_SPACE */) {
      if (this.localMatrixDirty)
        this.composeLocalMatrix();
      if (other.localMatrixDirty)
        other.composeLocalMatrix();
      if (this.localBoundsDirty)
        this.updateLocalBounds();
      if (other.localBoundsDirty)
        other.updateLocalBounds();
      if (mode == 0 /* BOUNDING_CIRCLE */)
        return this._localBoundingCircle.intersects(other._localBoundingCircle);
      else if (mode == 1 /* AXIS_ALIGNED_BOUNDING_BOX */)
        return this._localBoundingBox.intersects(other._localBoundingBox);
      else
        return false;
    } else {
      if (this.localMatrixDirty || this.worldMatrixDirty)
        this.updateWorldMatrix();
      if (this.localMatrixDirty || this.worldMatrixDirty)
        other.updateWorldMatrix();
      if (this.worldBoundsDirty)
        this.updateWorldBounds();
      if (other.worldBoundsDirty)
        other.updateWorldBounds();
      if (mode == 0 /* BOUNDING_CIRCLE */)
        return this._worldBoundingCircle.intersects(other._worldBoundingCircle);
      else if (mode == 1 /* AXIS_ALIGNED_BOUNDING_BOX */)
        return this._worldBoundingBox.intersects(other._worldBoundingBox);
      else
        return false;
    }
  }
};

// node_modules/gophergfx/src/lights/LightManager.ts
var LightManager = class {
  constructor() {
    this.lights = [];
    this.lightTypes = [];
    this.lightPositions = [];
    this.ambientIntensities = [];
    this.diffuseIntensities = [];
    this.specularIntensities = [];
  }
  clear() {
    this.lights = [];
    this.lightTypes = [];
    this.lightPositions = [];
    this.ambientIntensities = [];
    this.diffuseIntensities = [];
    this.specularIntensities = [];
  }
  addLight(light) {
    const alreadyAdded = this.lights.some((elem) => {
      return elem == light;
    });
    if (!alreadyAdded)
      this.lights.push(light);
  }
  getNumLights() {
    return this.lights.length;
  }
  updateLights() {
    this.lights.forEach((light) => {
      const worldPosition = light.localToWorldMatrix.getTranslation();
      this.lightPositions.push(worldPosition.x, worldPosition.y, worldPosition.z);
      this.lightTypes.push(light.getType());
      if (light.visible) {
        this.ambientIntensities.push(light.ambientIntensity.x, light.ambientIntensity.y, light.ambientIntensity.z);
        this.diffuseIntensities.push(light.diffuseIntensity.x, light.diffuseIntensity.y, light.diffuseIntensity.z);
        this.specularIntensities.push(light.specularIntensity.x, light.specularIntensity.y, light.specularIntensity.z);
      } else {
        this.ambientIntensities.push(0, 0, 0);
        this.diffuseIntensities.push(0, 0, 0);
        this.specularIntensities.push(0, 0, 0);
      }
    });
  }
};

// node_modules/gophergfx/src/core/Scene.ts
var Scene = class {
  constructor() {
    this.root3d = new Node3();
    this.root2d = new Node2();
    this.lightManager = new LightManager();
  }
  draw(camera) {
    camera.updateWorldMatrix();
    this.lightManager.clear();
    this.root3d.setLights(this.lightManager);
    this.lightManager.updateLights();
    this.root3d.children.forEach((elem) => {
      elem.draw(this.root3d, camera, this.lightManager);
    });
    this.root2d.children.forEach((elem) => {
      elem.draw();
    });
  }
  add(child) {
    if (child instanceof Node3) {
      this.root3d.add(child);
    } else {
      this.root2d.add(child);
    }
  }
  traverseSceneGraph() {
    this.root3d.children.forEach((elem) => {
      elem.traverseSceneGraph();
    });
    this.root2d.children.forEach((elem) => {
      elem.traverseSceneGraph();
    });
  }
};

// node_modules/gophergfx/src/loaders/AssetManager.ts
var AssetManager = class {
  constructor() {
    this.requestedAssets = [];
    this.loadedAssets = [];
    this.errorAssets = [];
  }
  allAssetsLoaded() {
    return this.requestedAssets.length == this.loadedAssets.length + this.errorAssets.length;
  }
};

// node_modules/gophergfx/src/core/GfxApp.ts
var GfxApp = class {
  static getInstance() {
    return GfxApp.instance;
  }
  constructor(enableStencilBuffer = false) {
    GfxApp.instance = this;
    this.time = Date.now();
    this.paused = false;
    this.camera = new Camera();
    this.scene = new Scene();
    this.renderer = new Renderer(enableStencilBuffer);
    this.assetManager = new AssetManager();
    this.runInBackground = false;
    this.previousTouches = [new Vector2()];
    window.addEventListener("resize", () => {
      this.resize();
    }, false);
    window.addEventListener("mousedown", (event) => {
      this.onMouseDown(event);
    });
    window.addEventListener("mouseup", (event) => {
      this.onMouseUp(event);
    });
    window.addEventListener("mousemove", (event) => {
      this.onMouseMove(event);
    });
    window.addEventListener("wheel", (event) => {
      this.onMouseWheel(event);
    });
    window.addEventListener("keydown", (event) => {
      this.onKeyDown(event);
    });
    window.addEventListener("keyup", (event) => {
      this.onKeyUp(event);
    });
    window.addEventListener("focus", (event) => {
      this.onFocusReceived(event);
    });
    window.addEventListener("blur", (event) => {
      this.onFocusLost(event);
    });
    window.addEventListener("touchstart", (event) => {
      this.onTouchStart(event);
    }, { passive: false });
    window.addEventListener("touchmove", (event) => {
      this.onTouchMove(event);
    }, { passive: false });
    window.addEventListener("touchend", (event) => {
      this.onTouchEnd(event);
    }, { passive: false });
    window.addEventListener("touchcancel", (event) => {
      this.onTouchEnd(event);
    }, { passive: false });
    window.addEventListener("contextmenu", (event) => event.preventDefault());
    this.camera.setOrthographicCamera(0, 1, 0, 1, 0.01, 1);
  }
  start() {
    this.createScene();
    this.initializationLoop();
  }
  initializationLoop() {
    if (!this.assetManager.allAssetsLoaded()) {
      window.requestAnimationFrame(() => this.initializationLoop());
    } else {
      this.onAssetsLoaded();
      this.time = Date.now();
      this.mainLoop();
    }
  }
  mainLoop() {
    if (this.runInBackground || !this.paused) {
      const deltaTime = (Date.now() - this.time) / 1e3;
      this.time = Date.now();
      this.update(deltaTime);
      this.scene.traverseSceneGraph();
      this.lateUpdate(deltaTime);
      this.renderer.render(this.scene, this.camera);
    }
    window.requestAnimationFrame(() => this.mainLoop());
  }
  resize() {
    this.renderer.resize(window.innerWidth, window.innerHeight, this.camera.getAspectRatio());
  }
  onTouchStart(event) {
    event.preventDefault();
    if (event.touches.length == 1)
      this.simulateMouseEvent("mousedown", event);
  }
  onTouchMove(event) {
    event.preventDefault();
    if (event.touches.length == 1)
      this.simulateMouseEvent("mousemove", event);
    else
      this.simulateWheelEvent(event);
  }
  onTouchEnd(event) {
    event.preventDefault();
    if (event.touches.length == 0)
      this.simulateMouseEvent("mouseup", event);
  }
  onFocusReceived(event) {
    this.resume();
  }
  onFocusLost(event) {
    this.pause();
  }
  pause() {
    this.paused = true;
  }
  resume() {
    this.time = Date.now();
    this.paused = false;
  }
  isPaused() {
    return this.paused;
  }
  getNormalizedDeviceCoordinates(mouseX, mouseY) {
    return this.renderer.getNormalizedDeviceCoordinates(mouseX, mouseY);
  }
  simulateMouseEvent(type, touchEvent) {
    if (this.previousTouches.length == 1) {
      const mouseEvent = new MouseEvent(type, {
        "button": 0,
        "buttons": 1,
        "clientX": touchEvent.changedTouches[0].clientX,
        "clientY": touchEvent.changedTouches[0].clientY,
        "screenX": touchEvent.changedTouches[0].screenX,
        "screenY": touchEvent.changedTouches[0].screenY,
        "movementX": touchEvent.changedTouches[0].clientX - this.previousTouches[0].x,
        "movementY": touchEvent.changedTouches[0].clientY - this.previousTouches[0].y,
        "view": touchEvent.view,
        cancelable: true,
        bubbles: true
      });
      touchEvent.target.dispatchEvent(mouseEvent);
    }
    this.previousTouches = [new Vector2(touchEvent.changedTouches[0].clientX, touchEvent.changedTouches[0].clientY)];
  }
  simulateWheelEvent(touchEvent) {
    if (this.previousTouches.length > 1) {
      const previousDistance = this.previousTouches[0].distanceTo(this.previousTouches[1]);
      const currentDistance = Math.sqrt(
        (touchEvent.touches[0].clientX - touchEvent.touches[1].clientX) * (touchEvent.touches[0].clientX - touchEvent.touches[1].clientX) + (touchEvent.touches[0].clientY - touchEvent.touches[1].clientY) * (touchEvent.touches[0].clientY - touchEvent.touches[1].clientY)
      );
      let scaleFactor = 0;
      if (currentDistance > previousDistance)
        scaleFactor = -currentDistance / previousDistance;
      else if (currentDistance < previousDistance)
        scaleFactor = previousDistance / currentDistance;
      const wheelEvent = new WheelEvent("wheel", {
        "clientX": (touchEvent.touches[0].clientX + touchEvent.touches[1].clientX) / 2,
        "clientY": (touchEvent.touches[0].clientY + touchEvent.touches[1].clientY) / 2,
        "screenX": (touchEvent.touches[0].screenX + touchEvent.touches[1].screenX) / 2,
        "screenY": (touchEvent.touches[0].screenY + touchEvent.touches[1].screenY) / 2,
        "movementX": (touchEvent.touches[0].clientX - this.previousTouches[0].x + (touchEvent.touches[1].clientX - this.previousTouches[1].x)) / 2,
        "movementY": (touchEvent.touches[0].clientY - this.previousTouches[0].y + (touchEvent.touches[1].clientY - this.previousTouches[1].y)) / 2,
        "deltaX": 0,
        "deltaY": 50 * scaleFactor,
        "deltaZ": 0,
        "deltaMode": WheelEvent.DOM_DELTA_PIXEL,
        "view": touchEvent.view,
        cancelable: true,
        bubbles: true
      });
      touchEvent.target.dispatchEvent(wheelEvent);
    }
    this.previousTouches = [];
    for (let i = 0; i < touchEvent.changedTouches.length; i++) {
      this.previousTouches.push(new Vector2(touchEvent.touches[i].clientX, touchEvent.touches[i].clientY));
    }
  }
  lateUpdate(deltaTime) {
  }
  onAssetsLoaded() {
  }
  onMouseDown(event) {
  }
  onMouseUp(event) {
  }
  onMouseMove(event) {
  }
  onMouseWheel(event) {
  }
  onKeyDown(event) {
  }
  onKeyUp(event) {
  }
};

// node_modules/gophergfx/src/shaders/material2.vert
var material2_default = "#version 300 es\n\nprecision mediump float;\n\nuniform mat3 modelMatrix;\nuniform float layer;\n\nin vec2 position;\nin vec4 color;\nin vec2 texCoord;\n\nout vec4 vertColor;\nout vec2 uv;\n\nvoid main() \n{\n    vertColor = color;\n    uv = texCoord.xy; \n    vec3 worldPosition = modelMatrix * vec3(position, 1);\n    gl_Position = vec4(worldPosition.x, worldPosition.y, layer, 1);\n}";

// node_modules/gophergfx/src/shaders/material2.frag
var material2_default2 = "#version 300 es\n\nprecision mediump float;\n\nuniform vec4 materialColor;\nuniform int useTexture;\nuniform sampler2D textureImage;\n\nin vec4 vertColor;\nin vec2 uv;\n\nout vec4 fragColor;\n\nvoid main() \n{\n    fragColor = materialColor * vertColor;\n\n    if(useTexture != 0)\n    {\n        fragColor *= texture(textureImage, uv);\n    }\n}";

// node_modules/gophergfx/src/materials/ShaderProgram.ts
var ShaderProgram = class {
  constructor(vertexSource, fragmentSource) {
    this.vertexSource = vertexSource;
    this.fragmentSource = fragmentSource;
    this.vertexShader = null;
    this.fragmentShader = null;
    this.shaderProgram = null;
    this.initialized = false;
  }
  initialize(gl) {
    if (this.initialized)
      return;
    this.initialized = true;
    this.vertexShader = this.createVertexShader(gl, this.vertexSource);
    this.fragmentShader = this.createFragmentShader(gl, this.fragmentSource);
    if (this.vertexShader && this.fragmentShader)
      this.shaderProgram = this.createShaderProgram(gl, this.vertexShader, this.fragmentShader);
  }
  createVertexShader(gl, source) {
    const shader = gl.createShader(gl.VERTEX_SHADER);
    if (!shader) {
      console.error("Error: unable to create vertex shader");
    } else {
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error("Error: unable to load vertex shader");
        console.error(gl.getShaderInfoLog(shader));
      }
    }
    return shader;
  }
  createFragmentShader(gl, source) {
    const shader = gl.createShader(gl.FRAGMENT_SHADER);
    if (!shader) {
      console.error("Error: unable to create fragment shader");
    } else {
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error("Error: unable to load fragment shader");
        console.error(gl.getShaderInfoLog(shader));
      }
    }
    return shader;
  }
  createShaderProgram(gl, vertexShader, fragmentShader) {
    let program = null;
    if (vertexShader && fragmentShader) {
      program = gl.createProgram();
      if (!program) {
        console.error("Error: could not create shader program");
        return null;
      }
      gl.attachShader(program, vertexShader);
      gl.attachShader(program, fragmentShader);
      gl.linkProgram(program);
      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        console.error("Error: could not link shader program");
        console.error(gl.getProgramInfoLog(program));
        return null;
      }
    }
    return program;
  }
  getProgram() {
    return this.shaderProgram;
  }
  getAttribute(gl, attribute) {
    if (this.shaderProgram)
      return gl.getAttribLocation(this.shaderProgram, attribute);
    else
      return -1;
  }
  getUniform(gl, uniform) {
    if (this.shaderProgram)
      return gl.getUniformLocation(this.shaderProgram, uniform);
    else
      return null;
  }
};

// node_modules/gophergfx/src/materials/Material2.ts
var _Material2 = class {
  constructor() {
    this.gl = GfxApp.getInstance().renderer.gl;
    this.visible = true;
    this.color = new Color(1, 1, 1);
    this.drawMode = this.gl.LINE_LOOP;
    this.texture = null;
    _Material2.shader.initialize(this.gl);
    this.colorUniform = _Material2.shader.getUniform(this.gl, "materialColor");
    this.modelUniform = _Material2.shader.getUniform(this.gl, "modelMatrix");
    this.layerUniform = _Material2.shader.getUniform(this.gl, "layer");
    this.textureUniform = _Material2.shader.getUniform(this.gl, "textureImage");
    this.useTextureUniform = _Material2.shader.getUniform(this.gl, "useTexture");
    this.positionAttribute = _Material2.shader.getAttribute(this.gl, "position");
    this.colorAttribute = _Material2.shader.getAttribute(this.gl, "color");
    this.texCoordAttribute = _Material2.shader.getAttribute(this.gl, "texCoord");
  }
  copy(mat) {
    this.visible = mat.visible;
    this.color.copy(mat.color);
    this.drawMode = mat.drawMode;
    this.texture = mat.texture;
  }
  draw(mesh) {
    if (!this.visible || mesh.vertexCount == 0)
      return;
    this.gl.useProgram(_Material2.shader.getProgram());
    this.gl.uniformMatrix3fv(this.modelUniform, false, mesh.localToWorldMatrix.mat);
    this.gl.uniform4f(this.colorUniform, this.color.r, this.color.g, this.color.b, this.color.a);
    this.gl.uniform1f(this.layerUniform, mesh.layer);
    if (mesh.hasVertexColors) {
      this.gl.enableVertexAttribArray(this.colorAttribute);
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, mesh.colorBuffer);
      this.gl.vertexAttribPointer(this.colorAttribute, 4, this.gl.FLOAT, false, 0, 0);
    } else {
      this.gl.disableVertexAttribArray(this.colorAttribute);
      this.gl.vertexAttrib4f(this.colorAttribute, 1, 1, 1, 1);
    }
    this.gl.enableVertexAttribArray(this.positionAttribute);
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, mesh.positionBuffer);
    this.gl.vertexAttribPointer(this.positionAttribute, 2, this.gl.FLOAT, false, 0, 0);
    if (this.texture) {
      this.gl.uniform1i(this.useTextureUniform, 1);
      this.gl.activeTexture(this.gl.TEXTURE0 + this.texture.id);
      this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture.texture);
      this.gl.uniform1i(this.textureUniform, this.texture.id);
      this.gl.enableVertexAttribArray(this.texCoordAttribute);
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, mesh.texCoordBuffer);
      this.gl.vertexAttribPointer(this.texCoordAttribute, 2, this.gl.FLOAT, false, 0, 0);
    } else {
      this.gl.uniform1i(this.useTextureUniform, 0);
      this.gl.disableVertexAttribArray(this.texCoordAttribute);
    }
    this.gl.drawArrays(this.drawMode, 0, mesh.vertexCount);
  }
};
var Material2 = _Material2;
Material2.shader = new ShaderProgram(material2_default, material2_default2);

// node_modules/gophergfx/src/geometry/2d/Mesh2.ts
var Mesh2 = class extends Node2 {
  constructor() {
    super();
    this.gl = GfxApp.getInstance().renderer.gl;
    this.positionBuffer = this.gl.createBuffer();
    this.colorBuffer = this.gl.createBuffer();
    this.texCoordBuffer = this.gl.createBuffer();
    this.customBuffers = [];
    this.vertexCount = 0;
    this.hasVertexColors = false;
    this.material = new Material2();
  }
  draw() {
    if (!this.visible)
      return;
    this.material.draw(this);
    this.children.forEach((elem) => {
      elem.draw();
    });
  }
  setVertices(vertices, usage = this.gl.STATIC_DRAW) {
    if (vertices.length > 0) {
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.positionBuffer);
      let vArray;
      if (typeof vertices[0] === "number") {
        vArray = vertices;
      } else {
        vArray = [];
        vertices.forEach((elem) => {
          vArray.push(elem.x, elem.y);
        });
      }
      this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(vArray), usage);
      this.vertexCount = vArray.length / 2;
      this.computeBounds(vertices);
    }
  }
  setColors(colors, usage = this.gl.STATIC_DRAW) {
    if (colors.length > 0) {
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.colorBuffer);
      if (typeof colors[0] === "number") {
        this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(colors), usage);
      } else {
        const cArray = [];
        colors.forEach((elem) => {
          cArray.push(elem.r, elem.g, elem.b, elem.a);
        });
        this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(cArray), usage);
      }
      this.hasVertexColors = true;
    } else {
      this.hasVertexColors = false;
    }
  }
  setTextureCoordinates(texCoords, usage = this.gl.STATIC_DRAW) {
    if (texCoords.length > 0) {
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.texCoordBuffer);
      if (typeof texCoords[0] === "number") {
        this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(texCoords), usage);
      } else {
        const tArray = [];
        texCoords.forEach((elem) => {
          tArray.push(elem.x, elem.y);
        });
        this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(tArray), usage);
      }
    }
  }
  setCustomBuffer(bufferIndex, values, usage = this.gl.STATIC_DRAW) {
    while (this.customBuffers.length <= bufferIndex)
      this.customBuffers.push(this.gl.createBuffer());
    if (values.length > 0) {
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.customBuffers[bufferIndex]);
      this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(values), usage);
    }
  }
  getVertices() {
    const vertexArray = new Float32Array(this.vertexCount * 2);
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.positionBuffer);
    this.gl.getBufferSubData(this.gl.ARRAY_BUFFER, 0, vertexArray);
    return [...vertexArray];
  }
  getColors() {
    const colorArray = new Float32Array(this.vertexCount * 4);
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.colorBuffer);
    this.gl.getBufferSubData(this.gl.ARRAY_BUFFER, 0, colorArray);
    return [...colorArray];
  }
  getTextureCoordinates() {
    const texCoordArray = new Float32Array(this.vertexCount * 2);
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.texCoordBuffer);
    this.gl.getBufferSubData(this.gl.ARRAY_BUFFER, 0, texCoordArray);
    return [...texCoordArray];
  }
  getCustomBuffer(bufferIndex, numValues) {
    const customBufferArray = new Float32Array(this.vertexCount * numValues);
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.customBuffers[bufferIndex]);
    this.gl.getBufferSubData(this.gl.ARRAY_BUFFER, 0, customBufferArray);
    return [...customBufferArray];
  }
  createDefaultVertexColors() {
    const colors = [];
    for (let i = 0; i < this.vertexCount; i++)
      colors.push(1, 1, 1, 1);
    this.setColors(colors);
  }
  computeBounds(vertices) {
    if (!vertices) {
      vertices = this.getVertices();
    }
    if (vertices.length == 0)
      return;
    this.boundingBox.computeBounds(vertices);
    this.boundingCircle.computeBounds(vertices, this.boundingBox);
    this.localBoundsDirty = true;
    this.worldBoundsDirty = true;
  }
  createInstance(copyTransform = true) {
    const instance = new Mesh2();
    instance.positionBuffer = this.positionBuffer;
    instance.colorBuffer = this.colorBuffer;
    instance.texCoordBuffer = this.texCoordBuffer;
    instance.customBuffers = this.customBuffers;
    instance.vertexCount = this.vertexCount;
    instance.hasVertexColors = this.hasVertexColors;
    instance.material = this.material;
    instance.visible = this.visible;
    instance.boundingBox = this.boundingBox;
    instance.boundingCircle = this.boundingCircle;
    instance.localBoundsDirty = true;
    instance.worldBoundsDirty = true;
    if (copyTransform) {
      instance._position.copy(this._position);
      instance._rotation = this._rotation;
      instance._scale.copy(this._scale);
      if (this._shear) {
        instance._shear = new Vector2();
        instance._shear.copy(this._shear);
      }
      instance.localToParentMatrix.copy(this.localToParentMatrix);
      instance.localToWorldMatrix.copy(this.localToWorldMatrix);
      instance.localMatrixDirty = this.localMatrixDirty;
      instance.worldMatrixDirty = true;
      instance.layer = this.layer;
    }
    return instance;
  }
};

// node_modules/gophergfx/src/geometry/2d/Line2.ts
var LineMode2 = /* @__PURE__ */ ((LineMode22) => {
  LineMode22[LineMode22["LINES"] = 0] = "LINES";
  LineMode22[LineMode22["LINE_STRIP"] = 1] = "LINE_STRIP";
  LineMode22[LineMode22["LINE_LOOP"] = 2] = "LINE_LOOP";
  return LineMode22;
})(LineMode2 || {});
var Line2 = class extends Node2 {
  constructor(lineMode = 1 /* LINE_STRIP */) {
    super();
    this.color = new Color(1, 1, 1);
    this.vertexCount = 0;
    this.lineMode = lineMode;
    this.gl = GfxApp.getInstance().renderer.gl;
    this.positionBuffer = this.gl.createBuffer();
    this.colorBuffer = this.gl.createBuffer();
    Material2.shader.initialize(this.gl);
    this.colorUniform = Material2.shader.getUniform(this.gl, "materialColor");
    this.modelUniform = Material2.shader.getUniform(this.gl, "modelMatrix");
    this.layerUniform = Material2.shader.getUniform(this.gl, "layer");
    this.useTextureUniform = Material2.shader.getUniform(this.gl, "useTexture");
    this.textureUniform = Material2.shader.getUniform(this.gl, "textureImage");
    this.positionAttribute = Material2.shader.getAttribute(this.gl, "position");
    this.colorAttribute = Material2.shader.getAttribute(this.gl, "color");
    this.texCoordAttribute = Material2.shader.getAttribute(this.gl, "texCoord");
    this.hasVertexColors = false;
  }
  draw() {
    if (!this.visible)
      return;
    this.gl.useProgram(Material2.shader.getProgram());
    this.gl.uniform1i(this.useTextureUniform, 0);
    this.gl.disableVertexAttribArray(this.texCoordAttribute);
    this.gl.uniformMatrix3fv(this.modelUniform, false, this.localToWorldMatrix.mat);
    this.gl.uniform4f(this.colorUniform, this.color.r, this.color.g, this.color.b, this.color.a);
    this.gl.uniform1f(this.layerUniform, this.layer);
    if (this.hasVertexColors) {
      this.gl.enableVertexAttribArray(this.colorAttribute);
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.colorBuffer);
      this.gl.vertexAttribPointer(this.colorAttribute, 4, this.gl.FLOAT, false, 0, 0);
    } else {
      this.gl.disableVertexAttribArray(this.colorAttribute);
      this.gl.vertexAttrib4f(this.colorAttribute, 1, 1, 1, 1);
    }
    this.gl.enableVertexAttribArray(this.positionAttribute);
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.positionBuffer);
    this.gl.vertexAttribPointer(this.positionAttribute, 2, this.gl.FLOAT, false, 0, 0);
    this.gl.drawArrays(this.glLineMode(), 0, this.vertexCount);
    this.children.forEach((elem) => {
      elem.draw();
    });
  }
  setVertices(vertices, usage = this.gl.STATIC_DRAW) {
    if (vertices.length > 0) {
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.positionBuffer);
      let vArray;
      if (typeof vertices[0] === "number") {
        vArray = vertices;
      } else {
        vArray = [];
        vertices.forEach((elem) => {
          vArray.push(elem.x, elem.y);
        });
      }
      this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(vArray), usage);
      this.vertexCount = vArray.length / 2;
    }
  }
  setColors(colors, usage = this.gl.STATIC_DRAW) {
    if (colors.length > 0) {
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.colorBuffer);
      if (typeof colors[0] === "number") {
        this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(colors), usage);
      } else {
        const cArray = [];
        colors.forEach((elem) => {
          cArray.push(elem.r, elem.g, elem.b, elem.a);
        });
        this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(cArray), usage);
      }
      this.hasVertexColors = true;
    } else {
      this.hasVertexColors = false;
    }
  }
  getVertices() {
    const vertexArray = new Float32Array(this.vertexCount * 2);
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.positionBuffer);
    this.gl.getBufferSubData(this.gl.ARRAY_BUFFER, 0, vertexArray);
    return [...vertexArray];
  }
  getColors() {
    const colorArray = new Float32Array(this.vertexCount * 4);
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.colorBuffer);
    this.gl.getBufferSubData(this.gl.ARRAY_BUFFER, 0, colorArray);
    return [...colorArray];
  }
  createDefaultVertexColors() {
    const colors = [];
    for (let i = 0; i < this.vertexCount; i++)
      colors.push(1, 1, 1, 1);
    this.setColors(colors);
  }
  glLineMode() {
    if (this.lineMode == 0 /* LINES */)
      return this.gl.LINES;
    else if (this.lineMode == 1 /* LINE_STRIP */)
      return this.gl.LINE_STRIP;
    else
      return this.gl.LINE_LOOP;
  }
};

// node_modules/gophergfx/src/geometry/Geometry2Factory.ts
var Geometry2Factory = class {
  static createBox(width = 1, height = 1) {
    const mesh = new Mesh2();
    mesh.material.drawMode = WebGL2RenderingContext.TRIANGLE_STRIP;
    const vertices = [];
    vertices.push(-width / 2, height / 2);
    vertices.push(-width / 2, -height / 2);
    vertices.push(width / 2, height / 2);
    vertices.push(width / 2, -height / 2);
    const uvs = [];
    uvs.push(0, 0);
    uvs.push(0, 1);
    uvs.push(1, 0);
    uvs.push(1, 1);
    mesh.setVertices(vertices);
    mesh.setTextureCoordinates(uvs);
    return mesh;
  }
  static createCircle(radius = 0.5, numSegments = 50) {
    const mesh = new Mesh2();
    mesh.material.drawMode = WebGL2RenderingContext.TRIANGLE_FAN;
    const vertices = [0, 0];
    const uvs = [0.5, 0.5];
    const angle = Math.PI * 2 / numSegments;
    for (let i = 0; i <= numSegments; i++) {
      vertices.push(Math.cos(angle * i) * radius, Math.sin(angle * i) * radius);
      uvs.push((Math.cos(angle * i) + 1) / 2, (Math.sin(angle * i) - 1) / -2);
    }
    mesh.setVertices(vertices);
    mesh.setTextureCoordinates(uvs);
    return mesh;
  }
  static createPieSlice(radius = 0.5, startAngle = 0, stopAngle = Math.PI, radiansPerSegment = Math.PI / 25) {
    const mesh = new Mesh2();
    mesh.material.drawMode = WebGL2RenderingContext.TRIANGLE_FAN;
    const vertices = [0, 0];
    const uvs = [0.5, 0.5];
    while (stopAngle < startAngle) {
      stopAngle += 2 * Math.PI;
    }
    const numSegments = Math.floor(stopAngle - startAngle) / radiansPerSegment;
    const angleInc = (stopAngle - startAngle) / numSegments;
    let angle = startAngle;
    for (let i = 0; i <= numSegments; i++) {
      vertices.push(Math.cos(angle) * radius, Math.sin(angle) * radius);
      uvs.push((Math.cos(angle) + 1) / 2, (Math.sin(angle) - 1) / -2);
      angle += angleInc;
    }
    if (angle != stopAngle) {
      angle = stopAngle;
      vertices.push(Math.cos(angle) * radius, Math.sin(angle) * radius);
      uvs.push((Math.cos(angle) + 1) / 2, (Math.sin(angle) - 1) / -2);
    }
    mesh.setVertices(vertices);
    mesh.setTextureCoordinates(uvs);
    return mesh;
  }
  static createAxes(size = 1) {
    const axes = new Line2(0 /* LINES */);
    const vertices = [];
    const colors = [];
    vertices.push(0, 0);
    vertices.push(size, 0);
    colors.push(1, 0, 0, 1);
    colors.push(1, 0, 0, 1);
    vertices.push(0, 0);
    vertices.push(0, size);
    colors.push(0, 1, 0, 1);
    colors.push(0, 1, 0, 1);
    axes.setVertices(vertices);
    axes.setColors(colors);
    return axes;
  }
  static createLine(startPoint, endPoint) {
    const line = new Line2(0 /* LINES */);
    const vertices = [];
    vertices.push(startPoint.x, startPoint.y);
    vertices.push(endPoint.x, endPoint.y);
    line.setVertices(vertices);
    return line;
  }
  static createLinesFromBox(box) {
    const line = new Line2(2 /* LINE_LOOP */);
    const vertices = [];
    vertices.push(box.min.x, box.min.y);
    vertices.push(box.max.x, box.min.y);
    vertices.push(box.max.x, box.max.y);
    vertices.push(box.min.x, box.max.y);
    line.setVertices(vertices);
    return line;
  }
};

// node_modules/gophergfx/src/shaders/gouraud.vert
var gouraud_default = "#version 300 es\n\nprecision mediump float;\n\n#define POINT_LIGHT 0\n#define DIRECTIONAL_LIGHT 1\n\nconst int MAX_LIGHTS = 8;\n\nuniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 normalMatrix;\nuniform vec3 eyePosition;\n\nuniform int numLights;\nuniform int lightTypes[MAX_LIGHTS];\nuniform vec3 lightPositions[MAX_LIGHTS];\nuniform vec3 ambientIntensities[MAX_LIGHTS];\nuniform vec3 diffuseIntensities[MAX_LIGHTS];\nuniform vec3 specularIntensities[MAX_LIGHTS];\n\nuniform vec3 kAmbient;\nuniform vec3 kDiffuse;\nuniform vec3 kSpecular;\nuniform float shininess;\n\nin vec3 position;\nin vec3 normal;\nin vec4 color;\nin vec2 texCoord;\n\nout vec4 vertColor;\nout vec2 uv;\n\nvoid main() \n{\n    // Compute the final vertex position and normal\n    vec3 worldPosition = (modelMatrix * vec4(position, 1)).xyz;\n    vec3 worldNormal = normalize((normalMatrix * vec4(normal, 0)).xyz);\n\n    vec3 illumination = vec3(0, 0, 0);\n    for(int i=0; i < numLights; i++)\n    {\n        // Ambient component\n        illumination += kAmbient * ambientIntensities[i];\n\n        // Compute the vector from the vertex position to the light\n        vec3 l;\n        if(lightTypes[i] == DIRECTIONAL_LIGHT)\n            l = normalize(lightPositions[i]);\n        else\n            l = normalize(lightPositions[i] - worldPosition);\n\n        // Diffuse component\n        float diffuseComponent = max(dot(worldNormal, l), 0.0);\n        illumination += diffuseComponent * kDiffuse * diffuseIntensities[i];\n\n        // Compute the vector from the vertex to the eye\n        vec3 e = normalize(eyePosition - worldPosition);\n\n        // Compute the light vector reflected about the normal\n        vec3 r = reflect(-l, worldNormal);\n\n        // Specular component\n        float specularComponent = pow(max(dot(e, r), 0.0), shininess);\n        illumination += specularComponent * kSpecular * specularIntensities[i];\n    }\n\n    vertColor = color;\n    vertColor.rgb *= illumination;\n\n    uv = texCoord.xy; \n\n    gl_Position = projectionMatrix * viewMatrix * vec4(worldPosition, 1);\n}";

// node_modules/gophergfx/src/shaders/gouraud.frag
var gouraud_default2 = "#version 300 es\n\nprecision mediump float;\n\nuniform int useTexture;\nuniform sampler2D textureImage;\n\nin vec4 vertColor;\nin vec2 uv;\n\nout vec4 fragColor;\n\nvoid main() \n{\n    fragColor = vertColor;\n\n    if(useTexture != 0)\n    {\n        fragColor *= texture(textureImage, uv);\n    }\n}";

// node_modules/gophergfx/src/materials/Material3.ts
var Side = /* @__PURE__ */ ((Side2) => {
  Side2[Side2["FRONT"] = 0] = "FRONT";
  Side2[Side2["BACK"] = 1] = "BACK";
  Side2[Side2["DOUBLE"] = 2] = "DOUBLE";
  return Side2;
})(Side || {});
var Material3 = class {
  constructor() {
    this.visible = true;
    this.side = 0 /* FRONT */;
    this.gl = GfxApp.getInstance().renderer.gl;
  }
  initialize() {
    if (this.side == 2 /* DOUBLE */) {
      this.gl.disable(this.gl.CULL_FACE);
      return;
    }
    this.gl.enable(this.gl.CULL_FACE);
    if (this.side == 0 /* FRONT */)
      this.gl.cullFace(this.gl.BACK);
    else
      this.gl.cullFace(this.gl.FRONT);
  }
};

// node_modules/gophergfx/src/materials/GouraudMaterial.ts
var _GouraudMaterial = class extends Material3 {
  constructor() {
    super();
    this.texture = null;
    this.ambientColor = new Color(1, 1, 1);
    this.diffuseColor = new Color(1, 1, 1);
    this.specularColor = new Color(0, 0, 0);
    this.shininess = 30;
    _GouraudMaterial.shader.initialize(this.gl);
    this.kAmbientUniform = _GouraudMaterial.shader.getUniform(this.gl, "kAmbient");
    this.kDiffuseUniform = _GouraudMaterial.shader.getUniform(this.gl, "kDiffuse");
    this.kSpecularUniform = _GouraudMaterial.shader.getUniform(this.gl, "kSpecular");
    this.shininessUniform = _GouraudMaterial.shader.getUniform(this.gl, "shininess");
    this.textureUniform = _GouraudMaterial.shader.getUniform(this.gl, "textureImage");
    this.useTextureUniform = _GouraudMaterial.shader.getUniform(this.gl, "useTexture");
    this.eyePositionUniform = _GouraudMaterial.shader.getUniform(this.gl, "eyePosition");
    this.viewUniform = _GouraudMaterial.shader.getUniform(this.gl, "viewMatrix");
    this.modelUniform = _GouraudMaterial.shader.getUniform(this.gl, "modelMatrix");
    this.projectionUniform = _GouraudMaterial.shader.getUniform(this.gl, "projectionMatrix");
    this.normalUniform = _GouraudMaterial.shader.getUniform(this.gl, "normalMatrix");
    this.numLightsUniform = _GouraudMaterial.shader.getUniform(this.gl, "numLights");
    this.lightTypesUniform = _GouraudMaterial.shader.getUniform(this.gl, "lightTypes");
    this.lightPositionsUniform = _GouraudMaterial.shader.getUniform(this.gl, "lightPositions");
    this.ambientIntensitiesUniform = _GouraudMaterial.shader.getUniform(this.gl, "ambientIntensities");
    this.diffuseIntensitiesUniform = _GouraudMaterial.shader.getUniform(this.gl, "diffuseIntensities");
    this.specularIntensitiesUniform = _GouraudMaterial.shader.getUniform(this.gl, "specularIntensities");
    this.positionAttribute = _GouraudMaterial.shader.getAttribute(this.gl, "position");
    this.normalAttribute = _GouraudMaterial.shader.getAttribute(this.gl, "normal");
    this.colorAttribute = _GouraudMaterial.shader.getAttribute(this.gl, "color");
    this.texCoordAttribute = _GouraudMaterial.shader.getAttribute(this.gl, "texCoord");
  }
  draw(mesh, camera, lightManager) {
    if (!this.visible || mesh.triangleCount == 0)
      return;
    this.initialize();
    this.gl.useProgram(_GouraudMaterial.shader.getProgram());
    const worldMatrix = mesh.localToWorldMatrix;
    const cameraPosition = new Vector3();
    cameraPosition.transformPoint(camera.localToWorldMatrix);
    this.gl.uniform3f(this.eyePositionUniform, cameraPosition.x, cameraPosition.y, cameraPosition.z);
    this.gl.uniformMatrix4fv(this.modelUniform, false, worldMatrix.mat);
    this.gl.uniformMatrix4fv(this.viewUniform, false, camera.viewMatrix.mat);
    this.gl.uniformMatrix4fv(this.projectionUniform, false, camera.projectionMatrix.mat);
    this.gl.uniformMatrix4fv(this.normalUniform, false, worldMatrix.inverse().transpose().mat);
    this.gl.uniform3f(this.kAmbientUniform, this.ambientColor.r, this.ambientColor.g, this.ambientColor.b);
    this.gl.uniform3f(this.kDiffuseUniform, this.diffuseColor.r, this.diffuseColor.g, this.diffuseColor.b);
    this.gl.uniform3f(this.kSpecularUniform, this.specularColor.r, this.specularColor.g, this.specularColor.b);
    this.gl.uniform1f(this.shininessUniform, this.shininess);
    this.gl.uniform1i(this.numLightsUniform, lightManager.getNumLights());
    this.gl.uniform1iv(this.lightTypesUniform, lightManager.lightTypes);
    this.gl.uniform3fv(this.lightPositionsUniform, lightManager.lightPositions);
    this.gl.uniform3fv(this.ambientIntensitiesUniform, lightManager.ambientIntensities);
    this.gl.uniform3fv(this.diffuseIntensitiesUniform, lightManager.diffuseIntensities);
    this.gl.uniform3fv(this.specularIntensitiesUniform, lightManager.specularIntensities);
    this.gl.enableVertexAttribArray(this.positionAttribute);
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, mesh.positionBuffer);
    this.gl.vertexAttribPointer(this.positionAttribute, 3, this.gl.FLOAT, false, 0, 0);
    this.gl.enableVertexAttribArray(this.normalAttribute);
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, mesh.normalBuffer);
    this.gl.vertexAttribPointer(this.normalAttribute, 3, this.gl.FLOAT, false, 0, 0);
    if (mesh.hasVertexColors) {
      this.gl.enableVertexAttribArray(this.colorAttribute);
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, mesh.colorBuffer);
      this.gl.vertexAttribPointer(this.colorAttribute, 4, this.gl.FLOAT, false, 0, 0);
    } else {
      this.gl.disableVertexAttribArray(this.colorAttribute);
      this.gl.vertexAttrib4f(this.colorAttribute, 1, 1, 1, 1);
    }
    if (this.texture) {
      this.gl.uniform1i(this.useTextureUniform, 1);
      this.gl.activeTexture(this.gl.TEXTURE0 + this.texture.id);
      this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture.texture);
      this.gl.uniform1i(this.textureUniform, this.texture.id);
      this.gl.enableVertexAttribArray(this.texCoordAttribute);
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, mesh.texCoordBuffer);
      this.gl.vertexAttribPointer(this.texCoordAttribute, 2, this.gl.FLOAT, false, 0, 0);
    } else {
      this.gl.uniform1i(this.useTextureUniform, 0);
      this.gl.disableVertexAttribArray(this.texCoordAttribute);
    }
    this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, mesh.indexBuffer);
    this.gl.drawElements(this.gl.TRIANGLES, mesh.triangleCount * 3, this.gl.UNSIGNED_SHORT, 0);
  }
  setColor(color) {
    this.ambientColor.copy(color);
    this.diffuseColor.copy(color);
    this.specularColor.copy(color);
  }
  getColor() {
    return this.diffuseColor;
  }
};
var GouraudMaterial = _GouraudMaterial;
GouraudMaterial.shader = new ShaderProgram(gouraud_default, gouraud_default2);

// node_modules/gophergfx/src/geometry/3d/Mesh3.ts
var Mesh3 = class extends Node3 {
  constructor() {
    super();
    this.gl = GfxApp.getInstance().renderer.gl;
    this.positionBuffer = this.gl.createBuffer();
    this.normalBuffer = this.gl.createBuffer();
    this.colorBuffer = this.gl.createBuffer();
    this.indexBuffer = this.gl.createBuffer();
    this.texCoordBuffer = this.gl.createBuffer();
    this.vertexCount = 0;
    this.triangleCount = 0;
    this.positionCache = null;
    this.normalCache = null;
    this.colorCache = null;
    this.indexCache = null;
    this.texCoordCache = null;
    this.material = new GouraudMaterial();
    this.hasVertexColors = false;
  }
  draw(parent, camera, lightManager) {
    if (!this.visible)
      return;
    this.material.draw(this, camera, lightManager);
    this.children.forEach((elem) => {
      elem.draw(this, camera, lightManager);
    });
  }
  setVertices(vertices, dynamicDraw = false) {
    this.positionCache = null;
    if (vertices.length > 0) {
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.positionBuffer);
      if (vertices instanceof Float32Array) {
        if (dynamicDraw)
          this.gl.bufferData(this.gl.ARRAY_BUFFER, vertices, this.gl.DYNAMIC_DRAW);
        else
          this.gl.bufferData(this.gl.ARRAY_BUFFER, vertices, this.gl.STATIC_DRAW);
        this.vertexCount = vertices.length / 3;
        const vArray = Array.from(vertices);
        this.boundingBox.computeBounds(vArray);
        this.boundingSphere.computeBounds(vArray, this.boundingBox);
      } else if (typeof vertices[0] === "number") {
        if (dynamicDraw)
          this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(vertices), this.gl.DYNAMIC_DRAW);
        else
          this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(vertices), this.gl.STATIC_DRAW);
        this.vertexCount = vertices.length / 3;
        this.boundingBox.computeBounds(vertices);
        this.boundingSphere.computeBounds(vertices, this.boundingBox);
      } else {
        const vArray = [];
        vertices.forEach((elem) => {
          vArray.push(elem.x, elem.y, elem.z);
        });
        if (dynamicDraw)
          this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(vArray), this.gl.DYNAMIC_DRAW);
        else
          this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(vArray), this.gl.STATIC_DRAW);
        this.vertexCount = vertices.length;
        this.boundingBox.computeBounds(vArray);
        this.boundingSphere.computeBounds(vArray, this.boundingBox);
      }
    }
  }
  setNormals(normals, dynamicDraw = false) {
    this.normalCache = null;
    if (normals.length > 0) {
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.normalBuffer);
      if (normals instanceof Float32Array) {
        if (dynamicDraw)
          this.gl.bufferData(this.gl.ARRAY_BUFFER, normals, this.gl.DYNAMIC_DRAW);
        else
          this.gl.bufferData(this.gl.ARRAY_BUFFER, normals, this.gl.STATIC_DRAW);
      } else if (typeof normals[0] === "number") {
        if (dynamicDraw)
          this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(normals), this.gl.DYNAMIC_DRAW);
        else
          this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(normals), this.gl.STATIC_DRAW);
      } else {
        const nArray = [];
        normals.forEach((elem) => {
          nArray.push(elem.x, elem.y, elem.z);
        });
        if (dynamicDraw)
          this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(nArray), this.gl.DYNAMIC_DRAW);
        else
          this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(nArray), this.gl.STATIC_DRAW);
      }
    }
  }
  setColors(colors, dynamicDraw = false) {
    this.colorCache = null;
    if (colors.length > 0) {
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.colorBuffer);
      if (colors instanceof Float32Array) {
        if (dynamicDraw)
          this.gl.bufferData(this.gl.ARRAY_BUFFER, colors, this.gl.DYNAMIC_DRAW);
        else
          this.gl.bufferData(this.gl.ARRAY_BUFFER, colors, this.gl.STATIC_DRAW);
      } else if (typeof colors[0] === "number") {
        if (dynamicDraw)
          this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(colors), this.gl.DYNAMIC_DRAW);
        else
          this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(colors), this.gl.STATIC_DRAW);
      } else {
        const cArray = [];
        colors.forEach((elem) => {
          cArray.push(elem.r, elem.g, elem.b, elem.a);
        });
        if (dynamicDraw)
          this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(cArray), this.gl.DYNAMIC_DRAW);
        else
          this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(cArray), this.gl.STATIC_DRAW);
      }
      this.hasVertexColors = true;
    } else {
      this.hasVertexColors = false;
    }
  }
  setTextureCoordinates(texCoords, dynamicDraw = false) {
    this.texCoordCache = null;
    if (texCoords.length > 0) {
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.texCoordBuffer);
      if (texCoords instanceof Float32Array) {
        if (dynamicDraw)
          this.gl.bufferData(this.gl.ARRAY_BUFFER, texCoords, this.gl.DYNAMIC_DRAW);
        else
          this.gl.bufferData(this.gl.ARRAY_BUFFER, texCoords, this.gl.STATIC_DRAW);
      } else if (typeof texCoords[0] === "number") {
        if (dynamicDraw)
          this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(texCoords), this.gl.DYNAMIC_DRAW);
        else
          this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(texCoords), this.gl.STATIC_DRAW);
      } else {
        const tArray = [];
        texCoords.forEach((elem) => {
          tArray.push(elem.x, elem.y);
        });
        if (dynamicDraw)
          this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(tArray), this.gl.DYNAMIC_DRAW);
        else
          this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(tArray), this.gl.STATIC_DRAW);
      }
    }
  }
  setIndices(indices, dynamicDraw = false) {
    this.indexCache = null;
    if (indices.length > 0) {
      this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
      if (indices instanceof Uint16Array) {
        this.triangleCount = indices.length / 3;
        if (dynamicDraw)
          this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, indices, this.gl.DYNAMIC_DRAW);
        else
          this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, indices, this.gl.STATIC_DRAW);
      } else if (typeof indices[0] === "number") {
        this.triangleCount = indices.length / 3;
        if (dynamicDraw)
          this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), this.gl.DYNAMIC_DRAW);
        else
          this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), this.gl.STATIC_DRAW);
      } else {
        this.triangleCount = indices.length;
        const iArray = [];
        indices.forEach((elem) => {
          iArray.push(elem.x, elem.y, elem.z);
        });
        if (dynamicDraw)
          this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(iArray), this.gl.DYNAMIC_DRAW);
        else
          this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(iArray), this.gl.STATIC_DRAW);
      }
    }
  }
  setArrayBuffer(values, buffer, dynamicDraw = false) {
    if (values.length > 0) {
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, buffer);
      if (typeof values[0] === "number") {
        if (dynamicDraw)
          this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(values), this.gl.DYNAMIC_DRAW);
        else
          this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(values), this.gl.STATIC_DRAW);
      } else {
        const nArray = [];
        values.forEach((elem) => {
          nArray.push(elem.x, elem.y, elem.z);
        });
        if (dynamicDraw)
          this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(nArray), this.gl.DYNAMIC_DRAW);
        else
          this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(nArray), this.gl.STATIC_DRAW);
      }
    }
  }
  getVertices() {
    if (!this.positionCache) {
      const vertexArray = new Float32Array(this.vertexCount * 3);
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.positionBuffer);
      this.gl.getBufferSubData(this.gl.ARRAY_BUFFER, 0, vertexArray);
      this.positionCache = [...vertexArray];
    }
    return this.positionCache;
  }
  getNormals() {
    if (!this.normalCache) {
      const normalArray = new Float32Array(this.vertexCount * 3);
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.normalBuffer);
      this.gl.getBufferSubData(this.gl.ARRAY_BUFFER, 0, normalArray);
      this.normalCache = [...normalArray];
    }
    return this.normalCache;
  }
  getColors() {
    if (!this.colorCache) {
      const colorArray = new Float32Array(this.vertexCount * 4);
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.colorBuffer);
      this.gl.getBufferSubData(this.gl.ARRAY_BUFFER, 0, colorArray);
      this.colorCache = [...colorArray];
    }
    return this.colorCache;
  }
  getTextureCoordinates() {
    if (!this.texCoordCache) {
      const texCoordArray = new Float32Array(this.vertexCount * 2);
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.texCoordBuffer);
      this.gl.getBufferSubData(this.gl.ARRAY_BUFFER, 0, texCoordArray);
      this.texCoordCache = [...texCoordArray];
    }
    return this.texCoordCache;
  }
  getIndices() {
    if (!this.indexCache) {
      const indexArray = new Uint16Array(this.triangleCount * 3);
      this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
      this.gl.getBufferSubData(this.gl.ELEMENT_ARRAY_BUFFER, 0, indexArray);
      this.indexCache = [...indexArray];
    }
    return this.indexCache;
  }
  getArrayBuffer(buffer) {
    const valueArray = new Float32Array(this.vertexCount * 3);
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, buffer);
    this.gl.getBufferSubData(this.gl.ARRAY_BUFFER, 0, valueArray);
    return [...valueArray];
  }
  createDefaultVertexColors() {
    const colors = [];
    for (let i = 0; i < this.vertexCount; i++)
      colors.push(1, 1, 1, 1);
    this.setColors(colors);
  }
  computeBounds(vertices) {
    if (!vertices) {
      vertices = this.getVertices();
    }
    if (vertices.length == 0)
      return;
    this.boundingBox.computeBounds(vertices);
    this.boundingSphere.computeBounds(vertices, this.boundingBox);
    this.localBoundsDirty = true;
    this.worldBoundsDirty = true;
  }
  mergeSharedVertices() {
    const vArray = this.getVertices();
    const nArray = this.getNormals();
    const cArray = this.getColors();
    const uvArray = this.getTextureCoordinates();
    const vertices = [];
    const normals = [];
    const colors = [];
    const uvs = [];
    const indices = this.getIndices();
    for (let i = 0; i < vArray.length; i += 3) {
      vertices.push(new Vector3(vArray[i], vArray[i + 1], vArray[i + 2]));
      normals.push(new Vector3(nArray[i], nArray[i + 1], nArray[i + 2]));
      colors.push(new Color(cArray[i], cArray[i + 1], cArray[i + 2]));
    }
    for (let i = 0; i < uvArray.length; i += 2) {
      uvs.push(new Vector2(uvArray[i], uvArray[i + 1]));
    }
    const newVertices = [];
    const newNormals = [];
    const newColors = [];
    const newUVs = [];
    const newIndices = indices.slice();
    const counts = [];
    for (let i = 0; i < vertices.length; i++) {
      let duplicate = false;
      for (let j2 = 0; j2 < newVertices.length; j2++) {
        if (vertices[i].equals(newVertices[j2])) {
          for (let k2 = 0; k2 < indices.length; k2++) {
            if (indices[k2] == i)
              newIndices[k2] = j2;
          }
          newNormals[j2].add(normals[i]);
          newColors[j2].add(colors[i]);
          newUVs[j2].add(uvs[i]);
          counts[j2]++;
          duplicate = true;
        }
      }
      if (!duplicate) {
        newVertices.push(vertices[i]);
        newNormals.push(normals[i]);
        newColors.push(colors[i]);
        newUVs.push(uvs[i]);
        counts.push(1);
        for (let k2 = 0; k2 < indices.length; k2++) {
          if (indices[k2] == i)
            newIndices[k2] = newVertices.length - 1;
        }
      }
    }
    for (let i = 0; i < newVertices.length; i++) {
      newNormals[i].multiplyScalar(1 / counts[i]);
      newColors[i].multiplyScalar(1 / counts[i]);
      newUVs[i].multiplyScalar(1 / counts[i]);
    }
    this.setVertices(newVertices);
    this.setNormals(newNormals);
    this.setColors(newColors);
    this.setTextureCoordinates(newUVs);
    this.setIndices(newIndices);
  }
  createInstance(copyTransform = true) {
    const instance = new Mesh3();
    instance.positionBuffer = this.positionBuffer;
    instance.normalBuffer = this.normalBuffer;
    instance.colorBuffer = this.colorBuffer;
    instance.indexBuffer = this.indexBuffer;
    instance.texCoordBuffer = this.texCoordBuffer;
    instance.vertexCount = this.vertexCount;
    instance.triangleCount = this.triangleCount;
    instance.material = this.material;
    instance.visible = this.visible;
    instance.boundingBox = this.boundingBox;
    instance.boundingSphere = this.boundingSphere;
    instance.localBoundsDirty = true;
    instance.worldBoundsDirty = true;
    if (copyTransform) {
      instance._position.copy(this._position);
      instance._rotation.copy(this._rotation);
      instance._scale.copy(this._scale);
      instance.localToParentMatrix.copy(this.localToParentMatrix);
      instance.localToWorldMatrix.copy(this.localToWorldMatrix);
      instance.localMatrixDirty = this.localMatrixDirty;
      instance.worldMatrixDirty = true;
    }
    return instance;
  }
};

// node_modules/gophergfx/src/shaders/unlit.vert
var unlit_default = "#version 300 es\n\nprecision mediump float;\n\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\n\nin vec3 position;\nin vec4 color;\nin vec2 texCoord;\n\nout vec4 vertColor;\nout vec2 uv;\n\nvoid main() \n{\n    vertColor = color;\n    uv = texCoord.xy;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1);\n}";

// node_modules/gophergfx/src/shaders/unlit.frag
var unlit_default2 = "#version 300 es\n\nprecision mediump float;\n\nuniform vec4 materialColor;\nuniform int useTexture;\nuniform sampler2D textureImage;\n\nin vec2 uv;\n\nin vec4 vertColor;\nout vec4 fragColor;\n\nvoid main() \n{\n    fragColor = materialColor * vertColor;\n\n    if(useTexture != 0)\n    {\n        fragColor *= texture(textureImage, uv);\n    }\n}";

// node_modules/gophergfx/src/materials/UnlitMaterial.ts
var _UnlitMaterial = class extends Material3 {
  constructor() {
    super();
    this.texture = null;
    this.color = new Color(1, 1, 1);
    _UnlitMaterial.shader.initialize(this.gl);
    this.colorUniform = _UnlitMaterial.shader.getUniform(this.gl, "materialColor");
    this.textureUniform = _UnlitMaterial.shader.getUniform(this.gl, "textureImage");
    this.useTextureUniform = _UnlitMaterial.shader.getUniform(this.gl, "useTexture");
    this.modelViewUniform = _UnlitMaterial.shader.getUniform(this.gl, "modelViewMatrix");
    this.projectionUniform = _UnlitMaterial.shader.getUniform(this.gl, "projectionMatrix");
    this.positionAttribute = _UnlitMaterial.shader.getAttribute(this.gl, "position");
    this.colorAttribute = _UnlitMaterial.shader.getAttribute(this.gl, "color");
    this.texCoordAttribute = _UnlitMaterial.shader.getAttribute(this.gl, "texCoord");
  }
  draw(mesh, camera, lightManager) {
    if (!this.visible || mesh.triangleCount == 0)
      return;
    this.initialize();
    this.gl.useProgram(_UnlitMaterial.shader.getProgram());
    this.gl.uniformMatrix4fv(this.modelViewUniform, false, Matrix4.multiply(camera.viewMatrix, mesh.localToWorldMatrix).mat);
    this.gl.uniformMatrix4fv(this.projectionUniform, false, camera.projectionMatrix.mat);
    this.gl.uniform4f(this.colorUniform, this.color.r, this.color.g, this.color.b, this.color.a);
    if (mesh.hasVertexColors) {
      this.gl.enableVertexAttribArray(this.colorAttribute);
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, mesh.colorBuffer);
      this.gl.vertexAttribPointer(this.colorAttribute, 4, this.gl.FLOAT, false, 0, 0);
    } else {
      this.gl.disableVertexAttribArray(this.colorAttribute);
      this.gl.vertexAttrib4f(this.colorAttribute, 1, 1, 1, 1);
    }
    this.gl.enableVertexAttribArray(this.positionAttribute);
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, mesh.positionBuffer);
    this.gl.vertexAttribPointer(this.positionAttribute, 3, this.gl.FLOAT, false, 0, 0);
    if (this.texture) {
      this.gl.uniform1i(this.useTextureUniform, 1);
      this.gl.activeTexture(this.gl.TEXTURE0 + this.texture.id);
      this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture.texture);
      this.gl.uniform1i(this.textureUniform, this.texture.id);
      this.gl.enableVertexAttribArray(this.texCoordAttribute);
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, mesh.texCoordBuffer);
      this.gl.vertexAttribPointer(this.texCoordAttribute, 2, this.gl.FLOAT, false, 0, 0);
    } else {
      this.gl.uniform1i(this.useTextureUniform, 0);
      this.gl.disableVertexAttribArray(this.texCoordAttribute);
    }
    this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, mesh.indexBuffer);
    this.gl.drawElements(this.gl.TRIANGLES, mesh.triangleCount * 3, this.gl.UNSIGNED_SHORT, 0);
  }
  setColor(color) {
    this.color.copy(color);
  }
  getColor() {
    return this.color;
  }
};
var UnlitMaterial = _UnlitMaterial;
UnlitMaterial.shader = new ShaderProgram(unlit_default, unlit_default2);

// node_modules/gophergfx/src/geometry/3d/Line3.ts
var LineMode3 = /* @__PURE__ */ ((LineMode32) => {
  LineMode32[LineMode32["LINES"] = 0] = "LINES";
  LineMode32[LineMode32["LINE_STRIP"] = 1] = "LINE_STRIP";
  LineMode32[LineMode32["LINE_LOOP"] = 2] = "LINE_LOOP";
  return LineMode32;
})(LineMode3 || {});
var Line3 = class extends Node3 {
  constructor(lineMode = 1 /* LINE_STRIP */) {
    super();
    this.color = new Color(1, 1, 1);
    this.vertexCount = 0;
    this.lineMode = lineMode;
    this.gl = GfxApp.getInstance().renderer.gl;
    this.positionBuffer = this.gl.createBuffer();
    this.colorBuffer = this.gl.createBuffer();
    UnlitMaterial.shader.initialize(this.gl);
    this.colorUniform = UnlitMaterial.shader.getUniform(this.gl, "materialColor");
    this.modelViewUniform = UnlitMaterial.shader.getUniform(this.gl, "modelViewMatrix");
    this.projectionUniform = UnlitMaterial.shader.getUniform(this.gl, "projectionMatrix");
    this.useTextureUniform = UnlitMaterial.shader.getUniform(this.gl, "useTexture");
    this.textureUniform = UnlitMaterial.shader.getUniform(this.gl, "textureImage");
    this.positionAttribute = UnlitMaterial.shader.getAttribute(this.gl, "position");
    this.colorAttribute = UnlitMaterial.shader.getAttribute(this.gl, "color");
    this.texCoordAttribute = UnlitMaterial.shader.getAttribute(this.gl, "texCoord");
    this.hasVertexColors = false;
  }
  createFromBox(box) {
    const vertices = [];
    vertices.push(box.max.x, box.min.y, box.max.z);
    vertices.push(box.max.x, box.min.y, box.min.z);
    vertices.push(box.min.x, box.min.y, box.min.z);
    vertices.push(box.min.x, box.min.y, box.max.z);
    vertices.push(box.max.x, box.min.y, box.max.z);
    vertices.push(box.min.x, box.min.y, box.max.z);
    vertices.push(box.max.x, box.min.y, box.min.z);
    vertices.push(box.min.x, box.min.y, box.min.z);
    vertices.push(box.max.x, box.max.y, box.max.z);
    vertices.push(box.max.x, box.max.y, box.min.z);
    vertices.push(box.min.x, box.max.y, box.min.z);
    vertices.push(box.min.x, box.max.y, box.max.z);
    vertices.push(box.max.x, box.max.y, box.max.z);
    vertices.push(box.min.x, box.max.y, box.max.z);
    vertices.push(box.max.x, box.max.y, box.min.z);
    vertices.push(box.min.x, box.max.y, box.min.z);
    vertices.push(box.max.x, box.min.y, box.max.z);
    vertices.push(box.max.x, box.max.y, box.max.z);
    vertices.push(box.max.x, box.min.y, box.min.z);
    vertices.push(box.max.x, box.max.y, box.min.z);
    vertices.push(box.min.x, box.min.y, box.min.z);
    vertices.push(box.min.x, box.max.y, box.min.z);
    vertices.push(box.min.x, box.min.y, box.max.z);
    vertices.push(box.min.x, box.max.y, box.max.z);
    this.setVertices(vertices);
    this.lineMode = 0 /* LINES */;
  }
  draw(parent, camera, lightManager) {
    if (!this.visible)
      return;
    this.gl.useProgram(UnlitMaterial.shader.getProgram());
    this.gl.uniform1i(this.useTextureUniform, 0);
    this.gl.disableVertexAttribArray(this.texCoordAttribute);
    this.gl.uniformMatrix4fv(this.modelViewUniform, false, Matrix4.multiply(camera.viewMatrix, this.localToWorldMatrix).mat);
    this.gl.uniformMatrix4fv(this.projectionUniform, false, camera.projectionMatrix.mat);
    this.gl.uniform4f(this.colorUniform, this.color.r, this.color.g, this.color.b, this.color.a);
    if (this.hasVertexColors) {
      this.gl.enableVertexAttribArray(this.colorAttribute);
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.colorBuffer);
      this.gl.vertexAttribPointer(this.colorAttribute, 4, this.gl.FLOAT, false, 0, 0);
    } else {
      this.gl.disableVertexAttribArray(this.colorAttribute);
      this.gl.vertexAttrib4f(this.colorAttribute, 1, 1, 1, 1);
    }
    this.gl.enableVertexAttribArray(this.positionAttribute);
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.positionBuffer);
    this.gl.vertexAttribPointer(this.positionAttribute, 3, this.gl.FLOAT, false, 0, 0);
    this.gl.drawArrays(this.glLineMode(), 0, this.vertexCount);
    this.children.forEach((elem) => {
      elem.draw(this, camera, lightManager);
    });
  }
  setVertices(vertices, usage = this.gl.STATIC_DRAW) {
    if (vertices.length > 0) {
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.positionBuffer);
      let vArray;
      if (typeof vertices[0] === "number") {
        vArray = vertices;
      } else {
        vArray = [];
        vertices.forEach((elem) => {
          vArray.push(elem.x, elem.y, elem.z);
        });
      }
      this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(vArray), usage);
      this.vertexCount = vArray.length / 3;
      this.boundingBox.computeBounds(vArray);
      this.boundingSphere.computeBounds(vArray, this.boundingBox);
    }
  }
  setColors(colors, usage = this.gl.STATIC_DRAW) {
    if (colors.length > 0) {
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.colorBuffer);
      if (typeof colors[0] === "number") {
        this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(colors), usage);
      } else {
        const cArray = [];
        colors.forEach((elem) => {
          cArray.push(elem.r, elem.g, elem.b, elem.a);
        });
        this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(cArray), usage);
      }
      this.hasVertexColors = true;
    } else {
      this.hasVertexColors = false;
    }
  }
  getVertices() {
    const vertexArray = new Float32Array(this.vertexCount * 3);
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.positionBuffer);
    this.gl.getBufferSubData(this.gl.ARRAY_BUFFER, 0, vertexArray);
    return [...vertexArray];
  }
  getColors() {
    const colorArray = new Float32Array(this.vertexCount * 4);
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.colorBuffer);
    this.gl.getBufferSubData(this.gl.ARRAY_BUFFER, 0, colorArray);
    return [...colorArray];
  }
  createDefaultVertexColors() {
    const colors = [];
    for (let i = 0; i < this.vertexCount; i++)
      colors.push(1, 1, 1, 1);
    this.setColors(colors);
  }
  glLineMode() {
    if (this.lineMode == 0 /* LINES */)
      return this.gl.LINES;
    else if (this.lineMode == 1 /* LINE_STRIP */)
      return this.gl.LINE_STRIP;
    else
      return this.gl.LINE_LOOP;
  }
};

// node_modules/gophergfx/src/geometry/Geometry3Factory.ts
var Geometry3Factory = class {
  static createBox(width = 1, height = 1, depth = 1) {
    const vertices = [];
    vertices.push(-width / 2, -height / 2, depth / 2);
    vertices.push(width / 2, -height / 2, depth / 2);
    vertices.push(width / 2, height / 2, depth / 2);
    vertices.push(-width / 2, height / 2, depth / 2);
    vertices.push(-width / 2, -height / 2, -depth / 2);
    vertices.push(width / 2, -height / 2, -depth / 2);
    vertices.push(width / 2, height / 2, -depth / 2);
    vertices.push(-width / 2, height / 2, -depth / 2);
    vertices.push(-width / 2, -height / 2, -depth / 2);
    vertices.push(-width / 2, -height / 2, depth / 2);
    vertices.push(-width / 2, height / 2, depth / 2);
    vertices.push(-width / 2, height / 2, -depth / 2);
    vertices.push(width / 2, -height / 2, -depth / 2);
    vertices.push(width / 2, -height / 2, depth / 2);
    vertices.push(width / 2, height / 2, depth / 2);
    vertices.push(width / 2, height / 2, -depth / 2);
    vertices.push(-width / 2, height / 2, depth / 2);
    vertices.push(width / 2, height / 2, depth / 2);
    vertices.push(width / 2, height / 2, -depth / 2);
    vertices.push(-width / 2, height / 2, -depth / 2);
    vertices.push(-width / 2, -height / 2, depth / 2);
    vertices.push(width / 2, -height / 2, depth / 2);
    vertices.push(width / 2, -height / 2, -depth / 2);
    vertices.push(-width / 2, -height / 2, -depth / 2);
    const normals = [];
    normals.push(0, 0, 1);
    normals.push(0, 0, 1);
    normals.push(0, 0, 1);
    normals.push(0, 0, 1);
    normals.push(0, 0, -1);
    normals.push(0, 0, -1);
    normals.push(0, 0, -1);
    normals.push(0, 0, -1);
    normals.push(-1, 0, 0);
    normals.push(-1, 0, 0);
    normals.push(-1, 0, 0);
    normals.push(-1, 0, 0);
    normals.push(1, 0, 0);
    normals.push(1, 0, 0);
    normals.push(1, 0, 0);
    normals.push(1, 0, 0);
    normals.push(0, 1, 0);
    normals.push(0, 1, 0);
    normals.push(0, 1, 0);
    normals.push(0, 1, 0);
    normals.push(0, -1, 0);
    normals.push(0, -1, 0);
    normals.push(0, -1, 0);
    normals.push(0, -1, 0);
    const indices = [];
    indices.push(0, 1, 2);
    indices.push(2, 3, 0);
    indices.push(4, 6, 5);
    indices.push(6, 4, 7);
    indices.push(8, 9, 10);
    indices.push(10, 11, 8);
    indices.push(12, 14, 13);
    indices.push(14, 12, 15);
    indices.push(16, 17, 18);
    indices.push(18, 19, 16);
    indices.push(20, 22, 21);
    indices.push(22, 20, 23);
    const uvs = [];
    uvs.push(0, 1);
    uvs.push(1, 1);
    uvs.push(1, 0);
    uvs.push(0, 0);
    uvs.push(1, 1);
    uvs.push(0, 1);
    uvs.push(0, 0);
    uvs.push(1, 0);
    uvs.push(0, 1);
    uvs.push(1, 1);
    uvs.push(1, 0);
    uvs.push(0, 0);
    uvs.push(1, 1);
    uvs.push(0, 1);
    uvs.push(0, 0);
    uvs.push(1, 0);
    uvs.push(0, 1);
    uvs.push(1, 1);
    uvs.push(1, 0);
    uvs.push(0, 0);
    uvs.push(1, 1);
    uvs.push(0, 1);
    uvs.push(0, 0);
    uvs.push(1, 0);
    const mesh = new Mesh3();
    mesh.setVertices(vertices);
    mesh.setNormals(normals);
    mesh.setIndices(indices);
    mesh.setTextureCoordinates(uvs);
    return mesh;
  }
  static createBoxLine(startPoint, endPoint, thickness) {
    const mesh = this.createBox();
    const midpoint = Vector3.add(startPoint, endPoint);
    midpoint.multiplyScalar(0.5);
    mesh.position.copy(midpoint);
    mesh.rotation.lookAt(midpoint, endPoint, Vector3.UP);
    mesh.scale.set(thickness, thickness, Vector3.distanceBetween(startPoint, endPoint));
    return mesh;
  }
  static createCone(radius = 1, height = 1, numSegments = 8) {
    const vertices = [];
    const angle = Math.PI * 2 / numSegments;
    vertices.push(0, height / 2, 0);
    for (let i = 0; i <= numSegments; i++) {
      vertices.push(Math.cos(angle * i) * radius, -height / 2, Math.sin(angle * i) * radius);
    }
    vertices.push(0, -height / 2, 0);
    for (let i = 0; i <= numSegments; i++) {
      vertices.push(Math.cos(angle * i) * radius, -height / 2, Math.sin(angle * i) * radius);
    }
    const normals = [];
    normals.push(0, 1, 0);
    for (let i = 0; i <= numSegments; i++) {
      normals.push(Math.cos(angle * i), 0, Math.sin(angle * i));
    }
    normals.push(0, -1, 0);
    for (let i = 0; i <= numSegments; i++) {
      normals.push(0, -1, 0);
    }
    const indices = [];
    for (let i = 0; i < numSegments; i++) {
      indices.push(0, i + 2, i + 1);
    }
    const startIndex = numSegments + 2;
    for (let i = 0; i < numSegments; i++) {
      indices.push(startIndex, startIndex + i + 1, startIndex + i + 2);
    }
    const uvs = [];
    uvs.push(0.5, 0);
    for (let i = 0; i <= numSegments; i++) {
      uvs.push(i / numSegments, 1);
    }
    uvs.push(0.5, 0.5);
    for (let i = 0; i <= numSegments; i++) {
      uvs.push((Math.cos(angle * i) + 1) / 2, (Math.sin(angle * i) - 1) / -2);
    }
    const mesh = new Mesh3();
    mesh.setVertices(vertices);
    mesh.setNormals(normals);
    mesh.setIndices(indices);
    mesh.setTextureCoordinates(uvs);
    return mesh;
  }
  static createCylinder(numSegments = 20, radius = 1, height = 1) {
    const vertices = [];
    const normals = [];
    const indices = [];
    const uvs = [];
    const angleIncrement = Math.PI * 2 / numSegments;
    const numVerticesX = numSegments + 1;
    for (let i = 0; i < numVerticesX; i++) {
      const angle = i * angleIncrement;
      vertices.push(Math.cos(angle) * radius, height / 2, Math.sin(angle) * radius);
      vertices.push(Math.cos(angle) * radius, -height / 2, Math.sin(angle) * radius);
      normals.push(Math.cos(angle), 0, Math.sin(angle));
      normals.push(Math.cos(angle), 0, Math.sin(angle));
      uvs.push(1 - i / numSegments, 0);
      uvs.push(1 - i / numSegments, 1);
    }
    for (let i = 0; i < numSegments; i++) {
      const angle = i * angleIncrement;
      indices.push(i * 2, i * 2 + 2, i * 2 + 1);
      indices.push(i * 2 + 1, i * 2 + 2, i * 2 + 3);
    }
    const topCenterIndex = vertices.length / 3;
    vertices.push(0, height / 2, 0);
    normals.push(0, 1, 0);
    uvs.push(0.5, 0);
    for (let i = 0; i < numVerticesX; i++) {
      const angle = i * angleIncrement;
      vertices.push(Math.cos(angle) * radius, height / 2, Math.sin(angle) * radius);
      normals.push(0, 1, 0);
      uvs.push(1 - i / numSegments, 0);
    }
    for (let i = 0; i < numSegments; i++) {
      indices.push(topCenterIndex, topCenterIndex + i + 2, topCenterIndex + i + 1);
    }
    const bottomCenterIndex = vertices.length / 3;
    vertices.push(0, -height / 2, 0);
    normals.push(0, -1, 0);
    uvs.push(0.5, 1);
    for (let i = 0; i < numVerticesX; i++) {
      const angle = i * angleIncrement;
      vertices.push(Math.cos(angle) * radius, -height / 2, Math.sin(angle) * radius);
      normals.push(0, -1, 0);
      uvs.push(1 - i / numSegments, 1);
    }
    for (let i = 0; i < numSegments; i++) {
      indices.push(bottomCenterIndex, bottomCenterIndex + i + 1, bottomCenterIndex + i + 2);
    }
    const mesh = new Mesh3();
    mesh.setVertices(vertices);
    mesh.setNormals(normals);
    mesh.setIndices(indices);
    mesh.setTextureCoordinates(uvs);
    return mesh;
  }
  static createPlane(width = 1, height = 1) {
    const vertices = [];
    vertices.push(-width / 2, -height / 2, 0);
    vertices.push(width / 2, -height / 2, 0);
    vertices.push(width / 2, height / 2, 0);
    vertices.push(-width / 2, height / 2, 0);
    const normals = [];
    normals.push(0, 0, -1);
    normals.push(0, 0, -1);
    normals.push(0, 0, -1);
    normals.push(0, 0, -1);
    const indices = [];
    indices.push(0, 2, 1);
    indices.push(2, 0, 3);
    const uvs = [];
    uvs.push(1, 1);
    uvs.push(0, 1);
    uvs.push(0, 0);
    uvs.push(1, 0);
    const mesh = new Mesh3();
    mesh.setVertices(vertices);
    mesh.setNormals(normals);
    mesh.setIndices(indices);
    mesh.setTextureCoordinates(uvs);
    return mesh;
  }
  static createSphere(radius = 1, subdivisions = 2) {
    let vertices = [];
    let indices = [];
    const normals = [];
    const texCoords = [];
    const phi = (1 + Math.sqrt(5)) * 0.5;
    const a = 1;
    const b = 1 / phi;
    vertices.push(new Vector3(0, b, -a));
    vertices.push(new Vector3(b, a, 0));
    vertices.push(new Vector3(-b, a, 0));
    vertices.push(new Vector3(0, b, a));
    vertices.push(new Vector3(0, -b, a));
    vertices.push(new Vector3(-a, 0, b));
    vertices.push(new Vector3(0, -b, -a));
    vertices.push(new Vector3(a, 0, -b));
    vertices.push(new Vector3(a, 0, b));
    vertices.push(new Vector3(-a, 0, -b));
    vertices.push(new Vector3(b, -a, 0));
    vertices.push(new Vector3(-b, -a, 0));
    for (let i = 0; i < vertices.length; i++) {
      vertices[i].normalize();
    }
    indices.push(2, 1, 0);
    indices.push(1, 2, 3);
    indices.push(5, 4, 3);
    indices.push(4, 8, 3);
    indices.push(7, 6, 0);
    indices.push(6, 9, 0);
    indices.push(11, 10, 4);
    indices.push(10, 11, 6);
    indices.push(9, 5, 2);
    indices.push(5, 9, 11);
    indices.push(8, 7, 1);
    indices.push(7, 8, 10);
    indices.push(2, 5, 3);
    indices.push(8, 1, 3);
    indices.push(9, 2, 0);
    indices.push(1, 7, 0);
    indices.push(11, 9, 6);
    indices.push(7, 10, 6);
    indices.push(5, 11, 4);
    indices.push(10, 8, 4);
    for (let div = 0; div < subdivisions; div++) {
      const newIndices = [];
      for (let i = 0; i < indices.length / 3; i++) {
        const index = i * 3;
        const centroids = this.createCentroids(vertices, indices[index], indices[index + 1], indices[index + 2]);
        vertices.push(...centroids);
        const triangles = this.subdivide(
          indices[index],
          indices[index + 1],
          indices[index + 2],
          vertices.length - 3,
          vertices.length - 2,
          vertices.length - 1
        );
        newIndices.push(...triangles);
      }
      indices = newIndices;
    }
    for (let i = 0; i < vertices.length; i++) {
      vertices[i].multiplyScalar(radius);
    }
    [vertices, indices] = this.mergeSphereVertices(vertices, indices);
    for (let i = 0; i < vertices.length; i++) {
      normals.push(Vector3.normalize(vertices[i]));
      const v = 1 - (vertices[i].y + radius) / (2 * radius);
      const direction = new Vector3(vertices[i].x, 0, vertices[i].z);
      direction.normalize();
      let angle = Math.acos(Vector3.FORWARD.dot(direction));
      if (direction.x > 0)
        angle = Math.PI * 2 - angle;
      const u2 = angle / (Math.PI * 2);
      texCoords.push(u2, v);
    }
    const indicesLength = indices.length;
    for (let i = 0; i < indicesLength; i += 3) {
      if (this.isSeamVertex(i, vertices, indices)) {
        if (this.isEndVertex(i + 1, vertices, indices) && this.isEndVertex(i + 2, vertices, indices)) {
          vertices.push(Vector3.copy(vertices[indices[i]]));
          normals.push(Vector3.normalize(vertices[indices[i]]));
          texCoords.push(1, texCoords[indices[i] * 2 + 1]);
          indices[i] = vertices.length - 1;
        } else if (this.isEndVertex(i + 1, vertices, indices)) {
          vertices.push(Vector3.copy(vertices[indices[i]]));
          normals.push(Vector3.normalize(vertices[indices[i]]));
          texCoords.push(1, texCoords[indices[i] * 2 + 1]);
          vertices.push(Vector3.copy(vertices[indices[i + 2]]));
          normals.push(Vector3.normalize(vertices[indices[i + 2]]));
          texCoords.push(1, texCoords[indices[i + 2] * 2 + 1]);
          indices[i] = vertices.length - 2;
          indices[i + 2] = vertices.length - 1;
        } else if (this.isEndVertex(i + 2, vertices, indices)) {
          vertices.push(Vector3.copy(vertices[indices[i]]));
          normals.push(Vector3.normalize(vertices[indices[i]]));
          texCoords.push(1, texCoords[indices[i] * 2 + 1]);
          vertices.push(Vector3.copy(vertices[indices[i + 1]]));
          normals.push(Vector3.normalize(vertices[indices[i + 1]]));
          texCoords.push(1, texCoords[indices[i + 1] * 2 + 1]);
          indices[i] = vertices.length - 2;
          indices[i + 1] = vertices.length - 1;
        }
      } else if (this.isSeamVertex(i + 1, vertices, indices)) {
        if (this.isEndVertex(i, vertices, indices) && this.isEndVertex(i + 2, vertices, indices)) {
          vertices.push(Vector3.copy(vertices[indices[i + 1]]));
          normals.push(Vector3.normalize(vertices[indices[i + 1]]));
          texCoords.push(1, texCoords[indices[i + 1] * 2 + 1]);
          indices[i + 1] = vertices.length - 1;
        } else if (this.isEndVertex(i, vertices, indices)) {
          vertices.push(Vector3.copy(vertices[indices[i + 1]]));
          normals.push(Vector3.normalize(vertices[indices[i + 1]]));
          texCoords.push(1, texCoords[indices[i + 1] * 2 + 1]);
          vertices.push(Vector3.copy(vertices[indices[i + 2]]));
          normals.push(Vector3.normalize(vertices[indices[i + 2]]));
          texCoords.push(1, texCoords[indices[i + 2] * 2 + 1]);
          indices[i + 1] = vertices.length - 2;
          indices[i + 2] = vertices.length - 1;
        } else if (this.isEndVertex(i + 2, vertices, indices)) {
          vertices.push(Vector3.copy(vertices[indices[i]]));
          normals.push(Vector3.normalize(vertices[indices[i]]));
          texCoords.push(1, texCoords[indices[i] * 2 + 1]);
          vertices.push(Vector3.copy(vertices[indices[i + 1]]));
          normals.push(Vector3.normalize(vertices[indices[i + 1]]));
          texCoords.push(1, texCoords[indices[i + 1] * 2 + 1]);
          indices[i] = vertices.length - 2;
          indices[i + 1] = vertices.length - 1;
        }
      } else if (this.isSeamVertex(i + 2, vertices, indices)) {
        if (this.isEndVertex(i, vertices, indices) && this.isEndVertex(i + 1, vertices, indices)) {
          vertices.push(Vector3.copy(vertices[indices[i + 2]]));
          normals.push(Vector3.normalize(vertices[indices[i + 2]]));
          texCoords.push(1, texCoords[indices[i + 2] * 2 + 1]);
          indices[i + 2] = vertices.length - 1;
        } else if (this.isEndVertex(i, vertices, indices)) {
          vertices.push(Vector3.copy(vertices[indices[i + 1]]));
          normals.push(Vector3.normalize(vertices[indices[i + 1]]));
          texCoords.push(1, texCoords[indices[i + 1] * 2 + 1]);
          vertices.push(Vector3.copy(vertices[indices[i + 2]]));
          normals.push(Vector3.normalize(vertices[indices[i + 2]]));
          texCoords.push(1, texCoords[indices[i + 2] * 2 + 1]);
          indices[i + 1] = vertices.length - 2;
          indices[i + 2] = vertices.length - 1;
        } else if (this.isEndVertex(i + 1, vertices, indices)) {
          vertices.push(Vector3.copy(vertices[indices[i]]));
          normals.push(Vector3.normalize(vertices[indices[i]]));
          texCoords.push(1, texCoords[indices[i] * 2 + 1]);
          vertices.push(Vector3.copy(vertices[indices[i + 2]]));
          normals.push(Vector3.normalize(vertices[indices[i + 2]]));
          texCoords.push(1, texCoords[indices[i + 2] * 2 + 1]);
          indices[i] = vertices.length - 2;
          indices[i + 2] = vertices.length - 1;
        }
      }
    }
    const mesh = new Mesh3();
    mesh.setVertices(vertices);
    mesh.setNormals(normals);
    mesh.setIndices(indices);
    mesh.setTextureCoordinates(texCoords);
    return mesh;
  }
  static isEndVertex(i, vertices, indices) {
    if (vertices[indices[i]].x > 0)
      return true;
    else
      return false;
  }
  static isSeamVertex(i, vertices, indices) {
    if (vertices[indices[i]].x == 0 && vertices[indices[i]].z <= 0)
      return true;
    else
      return false;
  }
  static createCentroids(vertices, v1, v2, v3) {
    const centroids = [];
    const centroid1 = Vector3.add(vertices[v1], vertices[v2]);
    centroid1.divideScalar(2);
    centroid1.normalize();
    centroids.push(centroid1);
    const centroid2 = Vector3.add(vertices[v2], vertices[v3]);
    centroid2.divideScalar(2);
    centroid2.normalize();
    centroids.push(centroid2);
    const centroid3 = Vector3.add(vertices[v3], vertices[v1]);
    centroid3.divideScalar(2);
    centroid3.normalize();
    centroids.push(centroid3);
    return centroids;
  }
  static subdivide(v1, v2, v3, c1, c2, c3) {
    const triangles = [];
    triangles.push(v1, c1, c3);
    triangles.push(v2, c2, c1);
    triangles.push(v3, c3, c2);
    triangles.push(c1, c2, c3);
    return triangles;
  }
  static mergeSphereVertices(vertices, indices) {
    const newVertices = [];
    const newIndices = [];
    indices.forEach((elem) => {
      newIndices.push(elem);
    });
    for (let i = 0; i < vertices.length; i++) {
      let duplicate = false;
      for (let j2 = 0; j2 < newVertices.length; j2++) {
        if (vertices[i].equals(newVertices[j2])) {
          for (let k2 = 0; k2 < indices.length; k2++) {
            if (indices[k2] == i)
              newIndices[k2] = j2;
          }
          duplicate = true;
        }
      }
      if (!duplicate) {
        newVertices.push(vertices[i]);
        for (let k2 = 0; k2 < indices.length; k2++) {
          if (indices[k2] == i)
            newIndices[k2] = newVertices.length - 1;
        }
      }
    }
    return [newVertices, newIndices];
  }
  static createLine(startPoint, endPoint) {
    const line = new Line3(0 /* LINES */);
    const vertices = [];
    vertices.push(startPoint.x, startPoint.y, startPoint.z);
    vertices.push(endPoint.x, endPoint.y, endPoint.z);
    line.setVertices(vertices);
    return line;
  }
  static createAxes(size = 1) {
    const axes = new Line3(0 /* LINES */);
    const vertices = [];
    const colors = [];
    vertices.push(0, 0, 0);
    vertices.push(size, 0, 0);
    colors.push(1, 0, 0, 1);
    colors.push(1, 0, 0, 1);
    vertices.push(0, 0, 0);
    vertices.push(0, size, 0);
    colors.push(0, 1, 0, 1);
    colors.push(0, 1, 0, 1);
    vertices.push(0, 0, 0);
    vertices.push(0, 0, size);
    colors.push(0, 0, 1, 1);
    colors.push(0, 0, 1, 1);
    axes.setVertices(vertices);
    axes.setColors(colors);
    return axes;
  }
};

// node_modules/gophergfx/src/shaders/morph.vert
var morph_default = "#version 300 es\n\nprecision mediump float;\n\n#define POINT_LIGHT 0\n#define DIRECTIONAL_LIGHT 1\n\nconst int MAX_LIGHTS = 8;\n\nuniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 normalMatrix;\nuniform vec3 eyePosition;\n\nuniform int numLights;\nuniform int lightTypes[MAX_LIGHTS];\nuniform vec3 lightPositions[MAX_LIGHTS];\nuniform vec3 ambientIntensities[MAX_LIGHTS];\nuniform vec3 diffuseIntensities[MAX_LIGHTS];\nuniform vec3 specularIntensities[MAX_LIGHTS];\n\nuniform vec3 kAmbient;\nuniform vec3 kDiffuse;\nuniform vec3 kSpecular;\nuniform float shininess;\n\nuniform float morphAlpha;\n\nin vec3 position;\nin vec3 normal;\nin vec4 color;\nin vec2 texCoord;\nin vec3 morphTargetPosition;\nin vec3 morphTargetNormal;\n\nout vec4 vertColor;\nout vec2 uv;\n\nvoid main() \n{\n    // Compute the final vertex position and normal\n    vec3 worldPosition, worldNormal;\n    if(morphAlpha > 0.0f)\n    {\n        worldPosition = mix(position, morphTargetPosition, morphAlpha);\n        worldPosition = (modelMatrix * vec4(worldPosition, 1)).xyz;\n        worldNormal = mix(normal, morphTargetNormal, morphAlpha);\n        worldNormal = normalize((normalMatrix * vec4(worldNormal, 0)).xyz);\n\n    }\n    else\n    {\n        worldPosition = (modelMatrix * vec4(position, 1)).xyz;\n        worldNormal = normalize((normalMatrix * vec4(normal, 0)).xyz);\n    }\n\n    vec3 illumination = vec3(0, 0, 0);\n    for(int i=0; i < numLights; i++)\n    {\n        // Ambient component\n        illumination += kAmbient * ambientIntensities[i];\n\n        // Compute the vector from the vertex position to the light\n        vec3 l;\n        if(lightTypes[i] == DIRECTIONAL_LIGHT)\n            l = normalize(lightPositions[i]);\n        else\n            l = normalize(lightPositions[i] - worldPosition);\n\n        // Diffuse component\n        float diffuseComponent = max(dot(worldNormal, l), 0.0);\n        illumination += diffuseComponent * kDiffuse * diffuseIntensities[i];\n\n        // Compute the vector from the vertex to the eye\n        vec3 e = normalize(eyePosition - worldPosition);\n\n        // Compute the light vector reflected about the normal\n        vec3 r = reflect(-l, worldNormal);\n\n        // Specular component\n        float specularComponent = pow(max(dot(e, r), 0.0), shininess);\n        illumination += specularComponent * kSpecular * specularIntensities[i];\n    }\n\n    vertColor = color;\n    vertColor.rgb *= illumination;\n\n    uv = texCoord.xy; \n\n    gl_Position = projectionMatrix * viewMatrix * vec4(worldPosition, 1);\n}";

// node_modules/gophergfx/src/shaders/morph.frag
var morph_default2 = "#version 300 es\n\nprecision mediump float;\n\nuniform int useTexture;\nuniform sampler2D textureImage;\n\nin vec4 vertColor;\nin vec2 uv;\n\nout vec4 fragColor;\n\nvoid main() \n{\n    fragColor = vertColor;\n\n    if(useTexture != 0)\n    {\n        fragColor *= texture(textureImage, uv);\n    }\n}";

// node_modules/gophergfx/src/materials/MorphMaterial.ts
var _MorphMaterial = class extends Material3 {
  constructor() {
    super();
    this.texture = null;
    this.ambientColor = new Color(1, 1, 1);
    this.diffuseColor = new Color(1, 1, 1);
    this.specularColor = new Color(0, 0, 0);
    this.shininess = 30;
    _MorphMaterial.shader.initialize(this.gl);
    this.kAmbientUniform = _MorphMaterial.shader.getUniform(this.gl, "kAmbient");
    this.kDiffuseUniform = _MorphMaterial.shader.getUniform(this.gl, "kDiffuse");
    this.kSpecularUniform = _MorphMaterial.shader.getUniform(this.gl, "kSpecular");
    this.shininessUniform = _MorphMaterial.shader.getUniform(this.gl, "shininess");
    this.textureUniform = _MorphMaterial.shader.getUniform(this.gl, "textureImage");
    this.useTextureUniform = _MorphMaterial.shader.getUniform(this.gl, "useTexture");
    this.eyePositionUniform = _MorphMaterial.shader.getUniform(this.gl, "eyePosition");
    this.viewUniform = _MorphMaterial.shader.getUniform(this.gl, "viewMatrix");
    this.modelUniform = _MorphMaterial.shader.getUniform(this.gl, "modelMatrix");
    this.projectionUniform = _MorphMaterial.shader.getUniform(this.gl, "projectionMatrix");
    this.normalUniform = _MorphMaterial.shader.getUniform(this.gl, "normalMatrix");
    this.numLightsUniform = _MorphMaterial.shader.getUniform(this.gl, "numLights");
    this.lightTypesUniform = _MorphMaterial.shader.getUniform(this.gl, "lightTypes");
    this.lightPositionsUniform = _MorphMaterial.shader.getUniform(this.gl, "lightPositions");
    this.ambientIntensitiesUniform = _MorphMaterial.shader.getUniform(this.gl, "ambientIntensities");
    this.diffuseIntensitiesUniform = _MorphMaterial.shader.getUniform(this.gl, "diffuseIntensities");
    this.specularIntensitiesUniform = _MorphMaterial.shader.getUniform(this.gl, "specularIntensities");
    this.positionAttribute = _MorphMaterial.shader.getAttribute(this.gl, "position");
    this.normalAttribute = _MorphMaterial.shader.getAttribute(this.gl, "normal");
    this.colorAttribute = _MorphMaterial.shader.getAttribute(this.gl, "color");
    this.texCoordAttribute = _MorphMaterial.shader.getAttribute(this.gl, "texCoord");
    this.morphAlphaUniform = _MorphMaterial.shader.getUniform(this.gl, "morphAlpha");
    this.morphTargetPositionAttribute = _MorphMaterial.shader.getAttribute(this.gl, "morphTargetPosition");
    this.morphTargetNormalAttribute = _MorphMaterial.shader.getAttribute(this.gl, "morphTargetNormal");
    this.wireframe = false;
  }
  draw(mesh, camera, lightManager) {
    if (!(mesh instanceof MorphMesh3) || !this.visible || mesh.triangleCount == 0)
      return;
    this.initialize();
    this.gl.useProgram(_MorphMaterial.shader.getProgram());
    const worldMatrix = mesh.localToWorldMatrix;
    const cameraPosition = new Vector3();
    cameraPosition.transformPoint(camera.localToWorldMatrix);
    this.gl.uniform3f(this.eyePositionUniform, cameraPosition.x, cameraPosition.y, cameraPosition.z);
    this.gl.uniformMatrix4fv(this.modelUniform, false, worldMatrix.mat);
    this.gl.uniformMatrix4fv(this.viewUniform, false, camera.viewMatrix.mat);
    this.gl.uniformMatrix4fv(this.projectionUniform, false, camera.projectionMatrix.mat);
    this.gl.uniformMatrix4fv(this.normalUniform, false, worldMatrix.inverse().transpose().mat);
    this.gl.uniform3f(this.kAmbientUniform, this.ambientColor.r, this.ambientColor.g, this.ambientColor.b);
    this.gl.uniform3f(this.kDiffuseUniform, this.diffuseColor.r, this.diffuseColor.g, this.diffuseColor.b);
    this.gl.uniform3f(this.kSpecularUniform, this.specularColor.r, this.specularColor.g, this.specularColor.b);
    this.gl.uniform1f(this.shininessUniform, this.shininess);
    this.gl.uniform1i(this.numLightsUniform, lightManager.getNumLights());
    this.gl.uniform1iv(this.lightTypesUniform, lightManager.lightTypes);
    this.gl.uniform3fv(this.lightPositionsUniform, lightManager.lightPositions);
    this.gl.uniform3fv(this.ambientIntensitiesUniform, lightManager.ambientIntensities);
    this.gl.uniform3fv(this.diffuseIntensitiesUniform, lightManager.diffuseIntensities);
    this.gl.uniform3fv(this.specularIntensitiesUniform, lightManager.specularIntensities);
    this.gl.enableVertexAttribArray(this.positionAttribute);
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, mesh.positionBuffer);
    this.gl.vertexAttribPointer(this.positionAttribute, 3, this.gl.FLOAT, false, 0, 0);
    this.gl.enableVertexAttribArray(this.normalAttribute);
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, mesh.normalBuffer);
    this.gl.vertexAttribPointer(this.normalAttribute, 3, this.gl.FLOAT, false, 0, 0);
    if (mesh.hasVertexColors) {
      this.gl.enableVertexAttribArray(this.colorAttribute);
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, mesh.colorBuffer);
      this.gl.vertexAttribPointer(this.colorAttribute, 4, this.gl.FLOAT, false, 0, 0);
    } else {
      this.gl.disableVertexAttribArray(this.colorAttribute);
      this.gl.vertexAttrib4f(this.colorAttribute, 1, 1, 1, 1);
    }
    this.gl.uniform1f(this.morphAlphaUniform, mesh.morphAlpha);
    if (mesh.morphAlpha > 0) {
      this.gl.enableVertexAttribArray(this.morphTargetPositionAttribute);
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, mesh.morphTargetPositionBuffer);
      this.gl.vertexAttribPointer(this.morphTargetPositionAttribute, 3, this.gl.FLOAT, false, 0, 0);
      this.gl.enableVertexAttribArray(this.morphTargetNormalAttribute);
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, mesh.morphTargetNormalBuffer);
      this.gl.vertexAttribPointer(this.morphTargetNormalAttribute, 3, this.gl.FLOAT, false, 0, 0);
    } else {
      this.gl.disableVertexAttribArray(this.morphTargetPositionAttribute);
      this.gl.disableVertexAttribArray(this.morphTargetNormalAttribute);
    }
    if (this.wireframe) {
      this.gl.uniform1i(this.useTextureUniform, 0);
      this.gl.disableVertexAttribArray(this.texCoordAttribute);
      if (!_MorphMaterial.wireframeBuffers.get(mesh)) {
        this.updateWireframeBuffer(mesh);
      }
      this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, _MorphMaterial.wireframeBuffers.get(mesh));
      this.gl.drawElements(this.gl.LINES, mesh.triangleCount * 6, this.gl.UNSIGNED_SHORT, 0);
    } else {
      if (this.texture) {
        this.gl.uniform1i(this.useTextureUniform, 1);
        this.gl.activeTexture(this.gl.TEXTURE0 + this.texture.id);
        this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture.texture);
        this.gl.uniform1i(this.textureUniform, this.texture.id);
        this.gl.enableVertexAttribArray(this.texCoordAttribute);
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, mesh.texCoordBuffer);
        this.gl.vertexAttribPointer(this.texCoordAttribute, 2, this.gl.FLOAT, false, 0, 0);
      } else {
        this.gl.uniform1i(this.useTextureUniform, 0);
        this.gl.disableVertexAttribArray(this.texCoordAttribute);
      }
      this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, mesh.indexBuffer);
      this.gl.drawElements(this.gl.TRIANGLES, mesh.triangleCount * 3, this.gl.UNSIGNED_SHORT, 0);
    }
  }
  updateWireframeBuffer(mesh) {
    let wireframeBuffer;
    wireframeBuffer = _MorphMaterial.wireframeBuffers.get(mesh);
    if (!wireframeBuffer) {
      wireframeBuffer = this.gl.createBuffer();
      if (wireframeBuffer)
        _MorphMaterial.wireframeBuffers.set(mesh, wireframeBuffer);
    }
    const indexArray = new Uint16Array(mesh.triangleCount * 3);
    this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, mesh.indexBuffer);
    this.gl.getBufferSubData(this.gl.ELEMENT_ARRAY_BUFFER, 0, indexArray);
    const indices = [...indexArray];
    const wireframeIndices = [];
    for (let i = 0; i < mesh.triangleCount; i++) {
      wireframeIndices.push(indices[i * 3]);
      wireframeIndices.push(indices[i * 3 + 1]);
      wireframeIndices.push(indices[i * 3 + 1]);
      wireframeIndices.push(indices[i * 3 + 2]);
      wireframeIndices.push(indices[i * 3 + 2]);
      wireframeIndices.push(indices[i * 3]);
    }
    this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, wireframeBuffer);
    this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(wireframeIndices), this.gl.STATIC_DRAW);
  }
  setColor(color) {
    this.ambientColor.copy(color);
    this.diffuseColor.copy(color);
    this.specularColor.copy(color);
  }
  getColor() {
    return this.diffuseColor;
  }
};
var MorphMaterial = _MorphMaterial;
MorphMaterial.shader = new ShaderProgram(morph_default, morph_default2);
MorphMaterial.wireframeBuffers = /* @__PURE__ */ new Map();

// node_modules/gophergfx/src/geometry/3d/MorphMesh3.ts
var MorphMesh3 = class extends Mesh3 {
  constructor() {
    super();
    this.morphAlpha = 0;
    this.morphTargetBoundingBox = new BoundingBox3();
    this.morphTargetBoundingSphere = new BoundingSphere();
    this.material = new MorphMaterial();
    this.morphTargetPositionBuffer = this.gl.createBuffer();
    this.morphTargetNormalBuffer = this.gl.createBuffer();
  }
  setMorphTargetVertices(vertices, dynamicDraw = false, computeBounds = true) {
    if (vertices.length > 0) {
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.morphTargetPositionBuffer);
      if (typeof vertices[0] === "number") {
        if (dynamicDraw)
          this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(vertices), this.gl.DYNAMIC_DRAW);
        else
          this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(vertices), this.gl.STATIC_DRAW);
        this.morphTargetBoundingBox.computeBounds(vertices);
        this.morphTargetBoundingSphere.computeBounds(vertices, this.morphTargetBoundingBox);
      } else {
        const vArray = [];
        vertices.forEach((elem) => {
          vArray.push(elem.x, elem.y, elem.z);
        });
        if (dynamicDraw)
          this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(vArray), this.gl.DYNAMIC_DRAW);
        else
          this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(vArray), this.gl.STATIC_DRAW);
        this.morphTargetBoundingBox.computeBounds(vArray);
        this.morphTargetBoundingSphere.computeBounds(vArray, this.morphTargetBoundingBox);
      }
    }
  }
  setMorphTargetNormals(normals, dynamicDraw = false) {
    if (normals.length > 0) {
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.morphTargetNormalBuffer);
      if (typeof normals[0] === "number") {
        if (dynamicDraw)
          this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(normals), this.gl.DYNAMIC_DRAW);
        else
          this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(normals), this.gl.STATIC_DRAW);
      } else {
        const nArray = [];
        normals.forEach((elem) => {
          nArray.push(elem.x, elem.y, elem.z);
        });
        if (dynamicDraw)
          this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(nArray), this.gl.DYNAMIC_DRAW);
        else
          this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(nArray), this.gl.STATIC_DRAW);
      }
    }
  }
};

// node_modules/gophergfx/src/shaders/particles2.vert
var particles2_default = "#version 300 es\n\nprecision mediump float;\n\nuniform mat3 modelMatrix;\nuniform float layer;\n\nin vec2 particlePosition;\nin float particleSize;\n\nin vec2 vertPosition;\nin vec4 vertColor;\nin vec2 texCoord;\n\nout vec4 color;\nout vec2 uv;\n\nvoid main() \n{\n    color = vertColor;\n    uv = texCoord.xy; \n    vec3 worldPosition = modelMatrix * vec3(particlePosition + (vertPosition * particleSize), 1);\n    gl_Position = vec4(worldPosition.x, worldPosition.y, layer, 1);\n}";

// node_modules/gophergfx/src/shaders/particles2.frag
var particles2_default2 = "#version 300 es\n\nprecision mediump float;\n\nuniform vec4 materialColor;\nuniform int useTexture;\nuniform sampler2D textureImage;\n\nin vec4 color;\nin vec2 uv;\n\nout vec4 fragColor;\n\nvoid main() \n{\n    fragColor = materialColor * color;\n\n    if(useTexture != 0)\n    {\n        fragColor *= texture(textureImage, uv);\n    }\n}";

// node_modules/gophergfx/src/geometry/2d/Particles2.ts
var _Particles2 = class extends Node2 {
  constructor(baseParticle, numParticles) {
    super();
    this.gl = GfxApp.getInstance().renderer.gl;
    this.baseParticle = baseParticle;
    this.numParticles = numParticles;
    this.particlePositions = [];
    this.particleSizes = [];
    for (let i = 0; i < this.numParticles; i++) {
      this.particlePositions.push(new Vector2());
      this.particleSizes.push(1);
    }
    this.particlePositionBuffer = this.gl.createBuffer();
    this.particleSizeBuffer = this.gl.createBuffer();
    _Particles2.shader.initialize(this.gl);
    this.colorUniform = _Particles2.shader.getUniform(this.gl, "materialColor");
    this.modelUniform = _Particles2.shader.getUniform(this.gl, "modelMatrix");
    this.layerUniform = _Particles2.shader.getUniform(this.gl, "layer");
    this.textureUniform = _Particles2.shader.getUniform(this.gl, "textureImage");
    this.useTextureUniform = _Particles2.shader.getUniform(this.gl, "useTexture");
    this.particlePositionAttribute = _Particles2.shader.getAttribute(this.gl, "particlePosition");
    this.particleSizeAttribute = _Particles2.shader.getAttribute(this.gl, "particleSize");
    this.vertPositionAttribute = _Particles2.shader.getAttribute(this.gl, "vertPosition");
    this.vertColorAttribute = _Particles2.shader.getAttribute(this.gl, "vertColor");
    this.texCoordAttribute = _Particles2.shader.getAttribute(this.gl, "texCoord");
    const particlePositionArray = [];
    for (let i = 0; i < this.particlePositions.length; i++)
      particlePositionArray.push(this.particlePositions[i].x, this.particlePositions[i].y);
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.particlePositionBuffer);
    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(particlePositionArray), this.gl.DYNAMIC_DRAW);
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.particleSizeBuffer);
    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(this.particleSizes), this.gl.DYNAMIC_DRAW);
  }
  getBaseParticle() {
    return this.baseParticle;
  }
  update(updatePositions = true, updateSizes = false) {
    if (updatePositions) {
      const particlePositionArray = [];
      for (let i = 0; i < this.particlePositions.length; i++)
        particlePositionArray.push(this.particlePositions[i].x, this.particlePositions[i].y);
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.particlePositionBuffer);
      this.gl.bufferSubData(this.gl.ARRAY_BUFFER, 0, new Float32Array(particlePositionArray));
    }
    if (updateSizes) {
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.particleSizeBuffer);
      this.gl.bufferSubData(this.gl.ARRAY_BUFFER, 0, new Float32Array(this.particleSizes));
    }
  }
  draw() {
    if (!this.visible)
      return;
    this.gl.useProgram(_Particles2.shader.getProgram());
    this.gl.uniformMatrix3fv(this.modelUniform, false, this.localToWorldMatrix.mat);
    this.gl.uniform4f(
      this.colorUniform,
      this.baseParticle.material.color.r,
      this.baseParticle.material.color.g,
      this.baseParticle.material.color.b,
      this.baseParticle.material.color.a
    );
    this.gl.uniform1f(this.layerUniform, this.layer);
    this.gl.enableVertexAttribArray(this.particlePositionAttribute);
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.particlePositionBuffer);
    this.gl.vertexAttribPointer(this.particlePositionAttribute, 2, this.gl.FLOAT, false, 0, 0);
    this.gl.vertexAttribDivisor(this.particlePositionAttribute, 1);
    this.gl.enableVertexAttribArray(this.particleSizeAttribute);
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.particleSizeBuffer);
    this.gl.vertexAttribPointer(this.particleSizeAttribute, 1, this.gl.FLOAT, false, 0, 0);
    this.gl.vertexAttribDivisor(this.particleSizeAttribute, 1);
    if (this.baseParticle.hasVertexColors) {
      this.gl.enableVertexAttribArray(this.vertColorAttribute);
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.baseParticle.colorBuffer);
      this.gl.vertexAttribPointer(this.vertColorAttribute, 4, this.gl.FLOAT, false, 0, 0);
    } else {
      this.gl.disableVertexAttribArray(this.vertColorAttribute);
      this.gl.vertexAttrib4f(this.vertColorAttribute, 1, 1, 1, 1);
    }
    this.gl.enableVertexAttribArray(this.vertPositionAttribute);
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.baseParticle.positionBuffer);
    this.gl.vertexAttribPointer(this.vertPositionAttribute, 2, this.gl.FLOAT, false, 0, 0);
    if (this.baseParticle.material.texture) {
      this.gl.uniform1i(this.useTextureUniform, 1);
      this.gl.activeTexture(this.gl.TEXTURE0 + this.baseParticle.material.texture.id);
      this.gl.bindTexture(this.gl.TEXTURE_2D, this.baseParticle.material.texture.texture);
      this.gl.uniform1i(this.textureUniform, this.baseParticle.material.texture.id);
      this.gl.enableVertexAttribArray(this.texCoordAttribute);
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.baseParticle.texCoordBuffer);
      this.gl.vertexAttribPointer(this.texCoordAttribute, 2, this.gl.FLOAT, false, 0, 0);
    } else {
      this.gl.uniform1i(this.useTextureUniform, 0);
      this.gl.disableVertexAttribArray(this.texCoordAttribute);
    }
    this.gl.drawArraysInstanced(this.baseParticle.material.drawMode, 0, this.baseParticle.vertexCount, this.numParticles);
    this.gl.vertexAttribDivisor(this.particlePositionAttribute, 0);
    this.gl.vertexAttribDivisor(this.particleSizeAttribute, 0);
    this.children.forEach((elem) => {
      elem.draw();
    });
  }
};
var Particles2 = _Particles2;
Particles2.shader = new ShaderProgram(particles2_default, particles2_default2);

// node_modules/gophergfx/src/interaction/OrbitControls.ts
var OrbitControls = class {
  constructor(camera, distance = 1, zoomable = true) {
    this.camera = camera;
    this.zoomable = zoomable;
    this.distance = distance;
    this.rotationSpeedX = Math.PI / 4;
    this.rotationSpeedY = Math.PI / 4;
    this.zoomSpeed = 0.25;
    this.mouseButton = 0;
    this.targetPoint = new Vector3();
    this.cameraOrbitX = new Quaternion();
    this.cameraOrbitY = new Quaternion();
    this.rotationDirection = new Vector3();
    this.zoomDirection = 0;
    this.mouseDrag = false;
    this.mouseMovement = new Vector2();
    window.addEventListener("mousedown", (event) => {
      this.onMouseDown(event);
    });
    window.addEventListener("mouseup", (event) => {
      this.onMouseUp(event);
    });
    window.addEventListener("mousemove", (event) => {
      this.onMouseMove(event);
    });
    window.addEventListener("wheel", (event) => {
      this.onMouseWheel(event);
    });
    this.updateCamera();
  }
  setTargetPoint(targetPoint) {
    this.targetPoint.copy(targetPoint);
    this.updateCamera();
  }
  setDistance(distance) {
    this.distance = distance;
    this.updateCamera();
  }
  setOrbit(orbitX, orbitY) {
    this.cameraOrbitX.setRotationX(orbitX);
    this.cameraOrbitY.setRotationY(orbitY);
    this.updateCamera();
  }
  onMouseDown(event) {
    if (this.mouseButton == event.button && event.target.localName == "canvas")
      this.mouseDrag = true;
  }
  onMouseUp(event) {
    if (this.mouseButton == event.button)
      this.mouseDrag = false;
  }
  onMouseMove(event) {
    if (this.mouseDrag) {
      this.mouseMovement.x = -event.movementY;
      this.mouseMovement.y = -event.movementX;
    }
  }
  onMouseWheel(event) {
    if (this.zoomable) {
      this.zoomDirection += event.deltaY;
    }
  }
  update(deltaTime) {
    this.rotationDirection.x += this.mouseMovement.x;
    this.rotationDirection.y += this.mouseMovement.y;
    this.mouseMovement.x = 0;
    this.mouseMovement.y = 0;
    this.cameraOrbitX.multiply(Quaternion.makeRotationX(this.rotationDirection.x * this.rotationSpeedX * deltaTime));
    this.cameraOrbitY.multiply(Quaternion.makeRotationY(this.rotationDirection.y * this.rotationSpeedY * deltaTime));
    this.distance += this.zoomDirection * this.zoomSpeed * deltaTime;
    this.rotationDirection.set(0, 0, 0);
    this.zoomDirection = 0;
    this.updateCamera();
  }
  updateCamera() {
    this.camera.rotation.copy(this.cameraOrbitY);
    this.camera.rotation.multiply(this.cameraOrbitX);
    this.camera.position.set(0, 0, this.distance);
    this.camera.position.rotate(this.camera.rotation);
    this.camera.position.add(this.targetPoint);
  }
  freeze() {
    this.mouseDrag = false;
    this.mouseMovement.set(0, 0);
    this.zoomDirection = 0;
  }
};

// node_modules/gophergfx/src/interaction/FirstPersonControls.ts
var FirstPersonControls = class {
  constructor(camera) {
    this.camera = camera;
    this.mouseButton = 0;
    this.translationSpeed = 2;
    this.rotationSpeed = Math.PI / 4;
    this.flyMode = true;
    this.hasMoved = false;
    this.moveDirection = new Vector3();
    this.rotationDirection = new Vector3();
    this.mouseDrag = false;
    this.mouseMovement = new Vector2();
    this.targetOrbitX = new Quaternion();
    this.targetOrbitY = new Quaternion();
    window.addEventListener("mousedown", (event) => {
      this.onMouseDown(event);
    });
    window.addEventListener("mouseup", (event) => {
      this.onMouseUp(event);
    });
    window.addEventListener("mousemove", (event) => {
      this.onMouseMove(event);
    });
    window.addEventListener("keydown", (event) => {
      this.onKeyDown(event);
    });
    window.addEventListener("keyup", (event) => {
      this.onKeyUp(event);
    });
  }
  onMouseDown(event) {
    if (this.mouseButton == event.button && event.target.localName == "canvas")
      this.mouseDrag = true;
  }
  onMouseUp(event) {
    if (this.mouseButton == event.button)
      this.mouseDrag = false;
  }
  onMouseMove(event) {
    if (this.mouseDrag) {
      this.mouseMovement.x = -event.movementY;
      this.mouseMovement.y = -event.movementX;
    }
  }
  onKeyDown(event) {
    if (event.key == "w") {
      this.moveDirection.z = -1;
    } else if (event.key == "s") {
      this.moveDirection.z = 1;
    } else if (event.key == "a") {
      this.moveDirection.x = -1;
    } else if (event.key == "d") {
      this.moveDirection.x = 1;
    }
  }
  onKeyUp(event) {
    if (event.key == "w" && this.moveDirection.z == -1) {
      this.moveDirection.z = 0;
    }
    if (event.key == "s" && this.moveDirection.z == 1) {
      this.moveDirection.z = 0;
    } else if (event.key == "a" && this.moveDirection.x == -1) {
      this.moveDirection.x = 0;
    } else if (event.key == "d" && this.moveDirection.x == 1) {
      this.moveDirection.x = 0;
    }
  }
  update(deltaTime) {
    this.rotationDirection.x += this.mouseMovement.x;
    this.rotationDirection.y += this.mouseMovement.y;
    this.mouseMovement.x = 0;
    this.mouseMovement.y = 0;
    const newTargetOrbitX = Quaternion.multiply(this.targetOrbitX, Quaternion.makeRotationX(this.rotationDirection.x * this.rotationSpeed * deltaTime));
    const testVector = new Vector3(0, 0, -1);
    testVector.rotate(newTargetOrbitX);
    if (testVector.z < 0)
      this.targetOrbitX.copy(newTargetOrbitX);
    this.targetOrbitY.multiply(Quaternion.makeRotationY(this.rotationDirection.y * this.rotationSpeed * deltaTime));
    this.rotationDirection.set(0, 0, 0);
    const target = new Vector3(0, 0, -1);
    target.rotate(this.targetOrbitX);
    target.rotate(this.targetOrbitY);
    target.add(this.camera.position);
    this.camera.lookAt(target, Vector3.UP);
    if (this.moveDirection.length() == 0) {
      this.hasMoved = false;
    } else {
      const moveDirectionNormalized = Vector3.normalize(this.moveDirection);
      if (this.flyMode) {
        moveDirectionNormalized.multiplyScalar(this.translationSpeed * deltaTime);
        const translation = Vector3.rotate(moveDirectionNormalized, this.camera.rotation);
        this.camera.position.add(translation);
      } else {
        const translation = Vector3.rotate(moveDirectionNormalized, this.camera.rotation);
        translation.y = 0;
        translation.normalize();
        translation.multiplyScalar(this.translationSpeed * deltaTime);
        this.camera.position.add(translation);
      }
      this.hasMoved = true;
    }
  }
  freeze() {
    this.mouseDrag = false;
    this.mouseMovement.x = 0;
    this.mouseMovement.y = 0;
    this.moveDirection.set(0, 0, 0);
  }
};

// node_modules/gophergfx/src/math/Plane3.ts
var Plane3 = class {
  constructor(point = new Vector3(), normal = new Vector3(0, 0, -1)) {
    this.point = point.clone();
    this.normal = Vector3.normalize(normal);
  }
  distanceTo(point) {
    return this.normal.dot(point) - this.point.dot(this.normal);
  }
  project(point) {
    const target = new Vector3(this.normal.x, this.normal.y, this.normal.z);
    target.multiplyScalar(-this.distanceTo(point));
    target.add(point);
    return target;
  }
};

// node_modules/gophergfx/src/math/Ray3.ts
var Ray3 = class {
  constructor(origin = new Vector3(), direction = new Vector3(0, 0, -1)) {
    this.origin = origin;
    this.direction = direction;
  }
  clone() {
    const ray = new Ray3();
    ray.origin.copy(this.origin);
    ray.direction.copy(this.direction);
    return ray;
  }
  set(origin, direction) {
    this.origin = origin;
    this.direction = direction;
  }
  setPickRay(deviceCoords, camera) {
    const worldMatrix = camera.localToWorldMatrix;
    this.origin.copy(worldMatrix.getTranslation());
    this.direction.set(deviceCoords.x, deviceCoords.y, -1);
    this.direction.transformPoint(camera.projectionMatrix.inverse());
    this.direction.transformVector(worldMatrix);
    this.direction.normalize();
  }
  intersectsPlane(plane) {
    const denominator = this.direction.dot(plane.normal);
    if (Math.abs(denominator) > 1e-6) {
      const rayOriginToPlanePoint = Vector3.subtract(plane.point, this.origin);
      const t = rayOriginToPlanePoint.dot(plane.normal) / denominator;
      if (t > 0) {
        const intersectionPoint = Vector3.multiplyScalar(this.direction, t);
        intersectionPoint.add(this.origin);
        return intersectionPoint;
      }
    }
    return null;
  }
  intersectsSphere(sphere) {
    const l2 = Vector3.subtract(sphere.center, this.origin);
    const tca = l2.dot(this.direction);
    const radiusSquared = sphere.radius * sphere.radius;
    const d2 = l2.dot(l2) - tca * tca;
    if (d2 > radiusSquared)
      return null;
    const thc = Math.sqrt(radiusSquared - d2);
    const t0 = tca - thc;
    const t1 = tca + thc;
    if (t0 < 0 && t1 < 0)
      return null;
    const intersection = this.direction.clone();
    if (t0 < t1)
      intersection.multiplyScalar(t0);
    else
      intersection.multiplyScalar(t1);
    intersection.add(this.origin);
    return intersection;
  }
  intersectsBox(box) {
    let tmin = (box.min.x - this.origin.x) / this.direction.x;
    let tmax = (box.max.x - this.origin.x) / this.direction.x;
    if (tmin > tmax) {
      const temp = tmin;
      tmin = tmax;
      tmax = temp;
    }
    let tymin = (box.min.y - this.origin.y) / this.direction.y;
    let tymax = (box.max.y - this.origin.y) / this.direction.y;
    if (tymin > tymax) {
      const temp = tymin;
      tymin = tymax;
      tymax = temp;
    }
    if (tmin > tymax || tymin > tmax)
      return null;
    if (tymin > tmin)
      tmin = tymin;
    if (tymax < tmax)
      tmax = tymax;
    let tzmin = (box.min.z - this.origin.z) / this.direction.z;
    let tzmax = (box.max.z - this.origin.z) / this.direction.z;
    if (tzmin > tzmax) {
      const temp = tzmin;
      tzmin = tzmax;
      tzmax = temp;
    }
    if (tmin > tzmax || tzmin > tmax)
      return null;
    if (tzmin > tmin)
      tmin = tzmin;
    if (tzmax < tmax)
      tmax = tzmax;
    const intersectionPoint = Vector3.multiplyScalar(this.direction, tmin);
    intersectionPoint.add(this.origin);
    return intersectionPoint;
  }
  intersectsAxisAlignedBoundingBox(transform) {
    return this.intersectsBox(transform.worldBoundingBox);
  }
  intersectsOrientedBoundingBox(transform) {
    const localIntersection = this.createLocalRay(transform).intersectsBox(transform.boundingBox);
    if (localIntersection) {
      localIntersection.transformPoint(transform.localToWorldMatrix);
    }
    return localIntersection;
  }
  intersectsOrientedBoundingSphere(transform) {
    return this.intersectsSphere(transform.worldBoundingSphere);
  }
  intersectsMesh3(mesh) {
    const localRay = this.createLocalRay(mesh);
    if (!localRay.intersectsBox(mesh.boundingBox))
      return null;
    const vertices = mesh.getVertices();
    const indices = mesh.getIndices();
    const result = localRay.intersectsTriangles(vertices, indices);
    if (result)
      result.transformPoint(mesh.localToWorldMatrix);
    return result;
  }
  intersectsTriangles(vertices, indices) {
    let positions;
    if (typeof vertices[0] === "number") {
      positions = [];
      const vArray = vertices;
      for (let i = 0; i < vertices.length; i += 3) {
        positions.push(new Vector3(vArray[i], vArray[i + 1], vArray[i + 2]));
      }
    } else {
      positions = vertices;
    }
    const results = [];
    for (let i = 0; i < indices.length; i += 3) {
      const intersection = this.intersectsTriangle(positions[indices[i]], positions[indices[i + 1]], positions[indices[i + 2]]);
      if (intersection)
        results.push(intersection);
    }
    if (results.length == 0) {
      return null;
    } else if (results.length == 1) {
      return results[0];
    } else {
      let closestPoint = 0;
      let closestDistance = this.origin.distanceTo(results[0]);
      for (let i = 1; i < results.length; i++) {
        const distance = this.origin.distanceTo(results[i]);
        if (distance < closestDistance) {
          closestPoint = i;
          closestDistance = distance;
        }
      }
      return results[closestPoint];
    }
  }
  intersectsTriangle(vertex0, vertex1, vertex2) {
    const EPSILON = 1e-7;
    const edge1 = Vector3.subtract(vertex1, vertex0);
    const edge2 = Vector3.subtract(vertex2, vertex0);
    const h2 = Vector3.cross(this.direction, edge2);
    const a = edge1.dot(h2);
    if (a > -EPSILON && a < EPSILON) {
      return null;
    }
    const f2 = 1 / a;
    const s = Vector3.subtract(this.origin, vertex0);
    const u2 = f2 * s.dot(h2);
    if (u2 < 0 || u2 > 1) {
      return null;
    }
    const q2 = Vector3.cross(s, edge1);
    const v = f2 * this.direction.dot(q2);
    if (v < 0 || u2 + v > 1) {
      return null;
    }
    const t = f2 * edge2.dot(q2);
    if (t > EPSILON) {
      const intersection = this.direction.clone();
      intersection.multiplyScalar(t);
      intersection.add(this.origin);
      return intersection;
    }
    return null;
  }
  createLocalRay(transform) {
    const localRay = this.clone();
    const inverseWorldMatrix = transform.localToWorldMatrix.inverse();
    localRay.origin.transformPoint(inverseWorldMatrix);
    localRay.direction.transformVector(inverseWorldMatrix);
    localRay.direction.normalize();
    return localRay;
  }
};

// node_modules/gophergfx/src/interaction/TransformWidget.ts
var TransformWidget = class extends Node3 {
  constructor(lineLength = 1, selectionWidth = 0.01, triggerDistance = 0.05) {
    super();
    this.currentAxis = -1;
    this.deviceCoords = new Vector2();
    this.selectionPlane = new Plane3();
    this.axes = Geometry3Factory.createAxes(lineLength);
    this.add(this.axes);
    this.thickAxes = [];
    this.thickAxes.push(Geometry3Factory.createBox(lineLength, selectionWidth, selectionWidth));
    this.thickAxes.push(Geometry3Factory.createBox(selectionWidth, lineLength, selectionWidth));
    this.thickAxes.push(Geometry3Factory.createBox(selectionWidth, selectionWidth, lineLength));
    this.thickAxes[0].position.set(lineLength / 2, 0, 0);
    this.thickAxes[1].position.set(0, lineLength / 2, 0);
    this.thickAxes[2].position.set(0, 0, lineLength / 2);
    this.thickAxes[0].material = new UnlitMaterial();
    this.thickAxes[1].material = new UnlitMaterial();
    this.thickAxes[2].material = new UnlitMaterial();
    this.thickAxes[0].material.setColor(new Color(1, 0, 0));
    this.thickAxes[1].material.setColor(new Color(0, 1, 0));
    this.thickAxes[2].material.setColor(new Color(0, 0, 1));
    this.thickAxes[0].boundingBox.max.y = triggerDistance;
    this.thickAxes[0].boundingBox.max.z = triggerDistance;
    this.thickAxes[1].boundingBox.max.x = triggerDistance;
    this.thickAxes[1].boundingBox.max.z = triggerDistance;
    this.thickAxes[2].boundingBox.max.x = triggerDistance;
    this.thickAxes[2].boundingBox.max.y = triggerDistance;
    this.add(this.thickAxes[0]);
    this.add(this.thickAxes[1]);
    this.add(this.thickAxes[2]);
    window.addEventListener("mousedown", (event) => {
      this.onMouseDown(event);
    });
    window.addEventListener("mouseup", (event) => {
      this.onMouseUp(event);
    });
    window.addEventListener("mousemove", (event) => {
      this.onMouseMove(event);
    });
  }
  update(deltaTime) {
    const ray = new Ray3();
    ray.setPickRay(this.deviceCoords, GfxApp.getInstance().camera);
    if (this.currentAxis == -1) {
      this.thickAxes[0].visible = false;
      this.thickAxes[1].visible = false;
      this.thickAxes[2].visible = false;
      if (ray.intersectsOrientedBoundingBox(this.thickAxes[0])) {
        this.thickAxes[0].visible = true;
      } else if (ray.intersectsOrientedBoundingBox(this.thickAxes[1])) {
        this.thickAxes[1].visible = true;
      } else if (ray.intersectsOrientedBoundingBox(this.thickAxes[2])) {
        this.thickAxes[2].visible = true;
      }
    } else if (this.currentAxis == 0) {
      const projectedPosition = ray.intersectsPlane(this.selectionPlane);
      if (projectedPosition) {
        const translation = new Vector3(projectedPosition.x - this.selectionPlane.point.x, 0, 0);
        translation.rotate(this.rotation);
        this.position.add(translation);
        this.selectionPlane.point = projectedPosition;
      }
    } else if (this.currentAxis == 1) {
      const projectedPosition = ray.intersectsPlane(this.selectionPlane);
      if (projectedPosition) {
        const translation = new Vector3(0, projectedPosition.y - this.selectionPlane.point.y, 0);
        translation.rotate(this.rotation);
        this.position.add(translation);
        this.selectionPlane.point = projectedPosition;
      }
    } else if (this.currentAxis == 2) {
      const projectedPosition = ray.intersectsPlane(this.selectionPlane);
      if (projectedPosition) {
        const translation = new Vector3(0, 0, projectedPosition.z - this.selectionPlane.point.z);
        translation.rotate(this.rotation);
        this.position.add(translation);
        this.selectionPlane.point = projectedPosition;
      }
    }
  }
  onMouseDown(event) {
    this.deviceCoords = GfxApp.getInstance().getNormalizedDeviceCoordinates(event.x, event.y);
    const ray = new Ray3();
    ray.setPickRay(this.deviceCoords, GfxApp.getInstance().camera);
    if (this.currentAxis == -1) {
      const xAxisPosition = ray.intersectsOrientedBoundingBox(this.thickAxes[0]);
      if (xAxisPosition) {
        this.selectionPlane.point = xAxisPosition;
        this.selectionPlane.normal = this.rotation.rotate(new Vector3(0, 0, 1));
        this.currentAxis = 0;
        return;
      }
      const yAxisPosition = ray.intersectsOrientedBoundingBox(this.thickAxes[1]);
      if (yAxisPosition) {
        this.selectionPlane.point = yAxisPosition;
        this.selectionPlane.normal = this.rotation.rotate(new Vector3(0, 0, 1));
        this.currentAxis = 1;
        return;
      }
      const zAxisPosition = ray.intersectsOrientedBoundingBox(this.thickAxes[2]);
      if (zAxisPosition) {
        this.selectionPlane.point = zAxisPosition;
        this.selectionPlane.normal = this.rotation.rotate(new Vector3(1, 0, 0));
        this.currentAxis = 2;
        return;
      }
    }
  }
  onMouseUp(event) {
    this.currentAxis = -1;
  }
  onMouseMove(event) {
    this.deviceCoords = GfxApp.getInstance().getNormalizedDeviceCoordinates(event.x, event.y);
  }
  isSelected() {
    return this.currentAxis >= 0;
  }
};

// node_modules/gophergfx/src/lights/Light.ts
var LightType = /* @__PURE__ */ ((LightType2) => {
  LightType2[LightType2["POINT"] = 0] = "POINT";
  LightType2[LightType2["DIRECTIONAL"] = 1] = "DIRECTIONAL";
  return LightType2;
})(LightType || {});
var Light = class extends Node3 {
  constructor(type, ambientIntensity, diffuseIntensity, specularIntensity) {
    super();
    this.type = type;
    if (ambientIntensity instanceof Vector3)
      this.ambientIntensity = new Vector3(ambientIntensity.x, ambientIntensity.y, ambientIntensity.z);
    else
      this.ambientIntensity = new Vector3(ambientIntensity.r, ambientIntensity.g, ambientIntensity.b);
    if (diffuseIntensity instanceof Vector3)
      this.diffuseIntensity = new Vector3(diffuseIntensity.x, diffuseIntensity.y, diffuseIntensity.z);
    else
      this.diffuseIntensity = new Vector3(diffuseIntensity.r, diffuseIntensity.g, diffuseIntensity.b);
    if (specularIntensity instanceof Vector3)
      this.specularIntensity = new Vector3(specularIntensity.x, specularIntensity.y, specularIntensity.z);
    else
      this.specularIntensity = new Vector3(specularIntensity.r, specularIntensity.g, specularIntensity.b);
  }
  getType() {
    return this.type;
  }
  setLights(lightManager) {
    lightManager.addLight(this);
    super.setLights(lightManager);
  }
};

// node_modules/gophergfx/src/lights/AmbientLight.ts
var AmbientLight = class extends Light {
  constructor(intensity = new Vector3(0.5, 0.5, 0.5)) {
    super(0 /* POINT */, intensity, Vector3.ZERO, Vector3.ZERO);
  }
};

// node_modules/gophergfx/src/lights/DirectionalLight.ts
var DirectionalLight = class extends Light {
  constructor(intensity = new Vector3(0.5, 0.5, 0.5)) {
    super(1 /* DIRECTIONAL */, Vector3.ZERO, intensity, intensity);
  }
};

// node_modules/gophergfx/src/lights/PointLight.ts
var PointLight = class extends Light {
  constructor(intensity = new Vector3(0.5, 0.5, 0.5)) {
    super(0 /* POINT */, Vector3.ZERO, intensity, intensity);
  }
};

// node_modules/gophergfx/src/loaders/TextFileLoader.ts
var TextFile = class {
  constructor() {
    this.data = "";
  }
};
var TextFileLoader = class {
  static load(filename, callback = null) {
    GfxApp.getInstance().assetManager.requestedAssets.push(filename);
    const textFile = new TextFile();
    fetch(filename).then((response) => {
      if (!response.ok)
        throw new Error();
      return response.blob();
    }).then((data) => {
      data.text().then((text) => {
        textFile.data = text;
        if (callback) {
          callback(textFile);
        }
        GfxApp.getInstance().assetManager.loadedAssets.push(filename);
      });
    }).catch(() => {
      GfxApp.getInstance().assetManager.errorAssets.push(filename);
      console.error("Unable to download file: " + filename);
    });
    return textFile;
  }
};

// node_modules/gophergfx/src/loaders/StringParser.ts
var StringParser = class {
  constructor(data) {
    this.tokens = [];
    this.line = 0;
    this.token = 0;
    const lines = data.split("\n");
    for (let i = 0; i < lines.length; i++) {
      this.tokens.push(lines[i].trim().split(/\s+/));
    }
    for (let i = 0; i < this.tokens.length; i++) {
      if (this.tokens[i].length == 1 && this.tokens[i][0] == "") {
        this.tokens.splice(i, 1);
        i--;
      }
    }
  }
  peek() {
    return this.tokens[this.line][this.token];
  }
  expect(token) {
    if (this.peek() == token) {
      this.readToken();
      return true;
    } else {
      return false;
    }
  }
  consumeLine() {
    this.line++;
    this.token = 0;
  }
  done() {
    return this.line >= this.tokens.length;
  }
  readToken() {
    const nextToken = this.tokens[this.line][this.token];
    this.token++;
    if (this.token >= this.tokens[this.line].length) {
      this.line++;
      this.token = 0;
    }
    return nextToken;
  }
  readNumber() {
    return Number(this.readToken());
  }
  readLine() {
    const nextLine = [];
    for (let i = this.token; i < this.tokens[this.line].length; i++) {
      nextLine.push(this.tokens[this.line][i]);
    }
    this.line++;
    this.token = 0;
    return nextLine;
  }
};

// node_modules/gophergfx/src/loaders/FileWriter.ts
var FileWriter = class {
  static saveAscii(filename, text) {
    const element = document.createElement("a");
    element.setAttribute("href", "data:text/plain;charset=utf-8," + encodeURIComponent(text));
    element.setAttribute("download", filename);
    element.style.display = "none";
    document.body.appendChild(element);
    element.click();
    document.body.removeChild(element);
  }
  static saveBinary(filename, data) {
    const blob = new Blob([data], { type: "application/octet-stream" });
    const url = URL.createObjectURL(blob);
    const element = document.createElement("a");
    element.setAttribute("href", url);
    element.setAttribute("download", filename);
    element.style.display = "none";
    document.body.appendChild(element);
    element.click();
    document.body.removeChild(element);
    URL.revokeObjectURL(url);
  }
};

// node_modules/gophergfx/src/loaders/MeshParser.ts
var MeshParser = class {
  static parseOBJ(obj, mesh) {
    const parser = new StringParser(obj);
    const vertices = [];
    const colors = [];
    const normals = [];
    const indices = [];
    const uvs = [];
    while (!parser.done()) {
      const nextToken = parser.readToken();
      if (nextToken == "v")
        this.parseOBJVertex(parser.readLine(), vertices, colors);
      else if (nextToken == "vn")
        this.parseOBJNormal(parser.readLine(), normals);
      else if (nextToken == "vt")
        this.parseOBJTextureCoordinate(parser.readLine(), uvs);
      else if (nextToken == "f")
        this.parseOBJFace(parser.readLine(), indices);
      else
        parser.consumeLine();
    }
    mesh.setVertices(vertices);
    mesh.setNormals(normals);
    mesh.setIndices(indices);
    if (colors.length > 0)
      mesh.setColors(colors);
    if (uvs.length / 2 == vertices.length / 3)
      mesh.setTextureCoordinates(uvs);
  }
  static parseOBJVertex(line, vertices, colors) {
    vertices.push(Number(line[0]));
    vertices.push(Number(line[1]));
    vertices.push(Number(line[2]));
    if (line.length > 3) {
      colors.push(Number(line[3]));
      colors.push(Number(line[4]));
      colors.push(Number(line[5]));
      colors.push(1);
    }
  }
  static parseOBJNormal(line, normals) {
    normals.push(Number(line[0]));
    normals.push(Number(line[1]));
    normals.push(Number(line[2]));
  }
  static parseOBJTextureCoordinate(line, uvs) {
    uvs.push(Number(line[0]));
    uvs.push(Number(line[1]));
  }
  static parseOBJFace(line, indices) {
    for (let i = 0; i < 3; i++) {
      const index = line[i].split("/");
      indices.push(Number(index[0]) - 1);
    }
  }
  static parsePLY(ply, mesh) {
    const buffer = new Uint8Array(ply);
    const decoder = new TextDecoder();
    let done = false;
    let header = "";
    let currentByte = 0;
    const windowLength = 512;
    while (!done) {
      const headerBuffer = buffer.subarray(currentByte, currentByte + windowLength);
      currentByte += windowLength;
      header += decoder.decode(headerBuffer);
      const endOfHeader = header.indexOf("end_header");
      if (endOfHeader > 0) {
        header = header.substring(0, endOfHeader + 10);
        currentByte = endOfHeader + 11;
        done = true;
      }
    }
    const headerParser = new StringParser(header);
    if (headerParser.readToken() != "ply" || headerParser.readToken() != "format") {
      console.error("Unable to parse PLY");
      return;
    }
    const format = headerParser.readToken();
    headerParser.consumeLine();
    if (format == "ascii") {
      const dataBuffer = buffer.subarray(currentByte);
      const dataParser = new StringParser(decoder.decode(dataBuffer));
      this.parsePLYAscii(headerParser, dataParser, mesh);
    } else if (format == "binary_little_endian") {
      this.parsePLYBinary(headerParser, new DataView(ply, currentByte), mesh, true);
    } else if (format == "binary_big_endian") {
      this.parsePLYBinary(headerParser, new DataView(ply, currentByte), mesh, false);
    } else {
      console.error("Unable to parse PLY");
      return;
    }
  }
  static parsePLYAscii(headerParser, dataParser, mesh) {
    let numVertices = 0;
    let numFaces = 0;
    const vertices = [];
    const colors = [];
    const normals = [];
    const indices = [];
    const uvs = [];
    while (!headerParser.done()) {
      const nextToken = headerParser.readToken();
      if (nextToken == "element") {
        const line = headerParser.readLine();
        if (line[0] == "vertex") {
          numVertices = Number(line[1]);
          let xIndex = -1;
          let yIndex = -1;
          let zIndex = -1;
          let nxIndex = -1;
          let nyIndex = -1;
          let nzIndex = -1;
          let uIndex = -1;
          let vIndex = -1;
          let redIndex = -1;
          let greenIndex = -1;
          let blueIndex = -1;
          let alphaIndex = -1;
          let propertyIndex = 0;
          while (headerParser.peek() == "property") {
            const propertyLine = headerParser.readLine();
            if (propertyLine[1] == "float") {
              if (propertyLine[2] == "x")
                xIndex = propertyIndex;
              else if (propertyLine[2] == "y")
                yIndex = propertyIndex;
              else if (propertyLine[2] == "z")
                zIndex = propertyIndex;
              else if (propertyLine[2] == "nx")
                nxIndex = propertyIndex;
              else if (propertyLine[2] == "ny")
                nyIndex = propertyIndex;
              else if (propertyLine[2] == "nz")
                nzIndex = propertyIndex;
              else if (propertyLine[2] == "texture_u")
                uIndex = propertyIndex;
              else if (propertyLine[2] == "texture_v")
                vIndex = propertyIndex;
            } else if (propertyLine[1] == "uchar") {
              if (propertyLine[2] == "red")
                redIndex = propertyIndex;
              else if (propertyLine[2] == "green")
                greenIndex = propertyIndex;
              else if (propertyLine[2] == "blue")
                blueIndex = propertyIndex;
              else if (propertyLine[2] == "alpha")
                alphaIndex = propertyIndex;
            }
            propertyIndex++;
          }
          const properties = [];
          for (let i = 0; i < propertyIndex; i++) {
            properties.push(0);
          }
          for (let i = 0; i < numVertices; i++) {
            for (let j2 = 0; j2 < propertyIndex; j2++)
              properties[j2] = dataParser.readNumber();
            if (xIndex >= 0 && yIndex >= 0 && zIndex >= 0)
              vertices.push(properties[xIndex], properties[yIndex], properties[zIndex]);
            if (nxIndex >= 0 && nyIndex >= 0 && nzIndex >= 0)
              normals.push(properties[nxIndex], properties[nyIndex], properties[nzIndex]);
            if (uIndex >= 0 && vIndex >= 0)
              uvs.push(properties[uIndex], properties[vIndex]);
            if (redIndex >= 0 && greenIndex >= 0 && blueIndex >= 0) {
              if (alphaIndex >= 0)
                colors.push(properties[redIndex] / 255, properties[greenIndex] / 255, properties[blueIndex] / 255, properties[alphaIndex] / 255);
              else
                colors.push(properties[redIndex] / 255, properties[greenIndex] / 255, properties[blueIndex] / 255, 1);
            }
          }
        } else if (line[0] == "face") {
          numFaces = Number(line[1]);
          while (headerParser.peek() == "property") {
            const propertyLine = headerParser.readLine();
            if (propertyLine[1] == "list" && (propertyLine[2] == "uchar" || propertyLine[2] == "char") && (propertyLine[3] == "int" || propertyLine[3] == "uint") && (propertyLine[4] == "vertex_indices" || propertyLine[4] == "vertex_index")) {
              for (let i = 0; i < numFaces; i++) {
                const numFaceIndices = dataParser.readNumber();
                for (let j2 = 0; j2 < numFaceIndices; j2++)
                  indices.push(dataParser.readNumber());
              }
            }
          }
        } else {
          console.error("Unable to parse PLY");
          return;
        }
      } else {
        headerParser.consumeLine();
      }
    }
    mesh.setVertices(vertices);
    mesh.setColors(colors);
    mesh.setNormals(normals);
    mesh.setIndices(indices);
    if (uvs.length / 2 == vertices.length / 3)
      mesh.setTextureCoordinates(uvs);
  }
  static parsePLYBinary(headerParser, data, mesh, little_endian = true) {
    let numVertices = 0;
    let numFaces = 0;
    const vertices = [];
    const colors = [];
    const normals = [];
    const indices = [];
    const uvs = [];
    let totalBytes = 0;
    while (!headerParser.done()) {
      const nextToken = headerParser.readToken();
      if (nextToken == "element") {
        const line = headerParser.readLine();
        if (line[0] == "vertex") {
          const vertexStart = totalBytes;
          numVertices = Number(line[1]);
          let propertyBytes = 0;
          let xBytes = -1;
          let yBytes = -1;
          let zBytes = -1;
          let nxBytes = -1;
          let nyBytes = -1;
          let nzBytes = -1;
          let uBytes = -1;
          let vBytes = -1;
          let redBytes = -1;
          let greenBytes = -1;
          let blueBytes = -1;
          let alphaBytes = -1;
          while (headerParser.peek() == "property") {
            const propertyLine = headerParser.readLine();
            if (propertyLine[1] == "float") {
              if (propertyLine[2] == "x")
                xBytes = propertyBytes;
              else if (propertyLine[2] == "y")
                yBytes = propertyBytes;
              else if (propertyLine[2] == "z")
                zBytes = propertyBytes;
              else if (propertyLine[2] == "nx")
                nxBytes = propertyBytes;
              else if (propertyLine[2] == "ny")
                nyBytes = propertyBytes;
              else if (propertyLine[2] == "nz")
                nzBytes = propertyBytes;
              else if (propertyLine[2] == "texture_u")
                uBytes = propertyBytes;
              else if (propertyLine[2] == "texture_v")
                vBytes = propertyBytes;
              propertyBytes += 4;
            } else if (propertyLine[1] == "uchar" || propertyLine[1] == "char") {
              if (propertyLine[2] == "red")
                redBytes = propertyBytes;
              else if (propertyLine[2] == "green")
                greenBytes = propertyBytes;
              else if (propertyLine[2] == "blue")
                blueBytes = propertyBytes;
              else if (propertyLine[2] == "alpha")
                alphaBytes = propertyBytes;
              propertyBytes += 1;
            } else if (propertyLine[1] == "short" || propertyLine[1] == "ushort") {
              propertyBytes += 2;
            } else if (propertyLine[1] == "int" || propertyLine[1] == "uint") {
              propertyBytes += 4;
            } else if (propertyLine[1] == "double") {
              propertyBytes += 8;
            }
          }
          for (let i = 0; i < numVertices; i++) {
            if (xBytes >= 0 && yBytes >= 0 && zBytes >= 0) {
              vertices.push(data.getFloat32(vertexStart + i * propertyBytes + xBytes, little_endian));
              vertices.push(data.getFloat32(vertexStart + i * propertyBytes + yBytes, little_endian));
              vertices.push(data.getFloat32(vertexStart + i * propertyBytes + zBytes, little_endian));
            }
            if (nxBytes >= 0 && nyBytes >= 0 && nzBytes >= 0) {
              normals.push(data.getFloat32(vertexStart + i * propertyBytes + nxBytes, little_endian));
              normals.push(data.getFloat32(vertexStart + i * propertyBytes + nyBytes, little_endian));
              normals.push(data.getFloat32(vertexStart + i * propertyBytes + nzBytes, little_endian));
            }
            if (uBytes >= 0 && vBytes >= 0) {
              uvs.push(data.getFloat32(vertexStart + i * propertyBytes + uBytes, little_endian));
              uvs.push(data.getFloat32(vertexStart + i * propertyBytes + vBytes, little_endian));
            }
            if (redBytes >= 0 && greenBytes >= 0 && blueBytes >= 0) {
              if (alphaBytes >= 0)
                colors.push(
                  data.getUint8(vertexStart + i * propertyBytes + redBytes) / 255,
                  data.getUint8(vertexStart + i * propertyBytes + greenBytes) / 255,
                  data.getUint8(vertexStart + i * propertyBytes + blueBytes) / 255,
                  data.getUint8(vertexStart + i * propertyBytes + alphaBytes) / 255
                );
              else
                colors.push(
                  data.getUint8(vertexStart + i * propertyBytes + redBytes) / 255,
                  data.getUint8(vertexStart + i * propertyBytes + greenBytes) / 255,
                  data.getUint8(vertexStart + i * propertyBytes + blueBytes) / 255,
                  1
                );
            }
          }
          totalBytes += numVertices * propertyBytes;
        } else if (line[0] == "face") {
          numFaces = Number(line[1]);
          let faceBytes = totalBytes;
          while (headerParser.peek() == "property") {
            const propertyLine = headerParser.readLine();
            if (propertyLine[1] == "list" && (propertyLine[2] == "uchar" || propertyLine[2] == "char") && (propertyLine[3] == "int" || propertyLine[3] == "uint") && (propertyLine[4] == "vertex_indices" || propertyLine[4] == "vertex_index")) {
              for (let i = 0; i < numFaces; i++) {
                const numFaceIndices = data.getUint8(faceBytes);
                faceBytes += 1;
                for (let j2 = 0; j2 < numFaceIndices; j2++) {
                  indices.push(data.getUint32(faceBytes, little_endian));
                  faceBytes += 4;
                }
              }
            } else if (propertyLine[1] == "uchar" || propertyLine[1] == "char") {
              faceBytes += 1;
            } else if (propertyLine[1] == "short" || propertyLine[1] == "ushort") {
              faceBytes += 2;
            } else if (propertyLine[1] == "int" || propertyLine[1] == "uint" || propertyLine[1] == "float") {
              faceBytes += 4;
            } else if (propertyLine[1] == "double") {
              faceBytes += 8;
            }
          }
        } else {
          console.error("Unable to parse PLY");
          return;
        }
      } else {
        headerParser.consumeLine();
      }
    }
    mesh.setVertices(vertices);
    mesh.setColors(colors);
    mesh.setNormals(normals);
    mesh.setIndices(indices);
    if (uvs.length / 2 == vertices.length / 3)
      mesh.setTextureCoordinates(uvs);
  }
  static parseGLTF(document2, transform) {
    const root = document2.getRoot();
    root.listNodes().forEach((node) => {
      this.parseGLTFRecursive(node, transform);
    });
  }
  static parseGLTFRecursive(node, parentTransform) {
    let transform;
    const gltfMesh = node.getMesh();
    if (gltfMesh) {
      const primitives = gltfMesh.listPrimitives();
      if (primitives.length == 1) {
        transform = this.parseGLTFPrimitive(primitives[0]);
      } else if (primitives.length > 1) {
        transform = new Node3();
        primitives.forEach((primitive) => {
          transform.add(this.parseGLTFPrimitive(primitive));
        });
      } else {
        transform = new Node3();
      }
    } else {
      transform = new Node3();
    }
    const position = node.getTranslation();
    const rotation = node.getRotation();
    const scale = node.getScale();
    transform.position.set(position[0], position[1], position[2]);
    transform.rotation.set(rotation[0], rotation[1], rotation[2], rotation[3]);
    transform.scale.set(scale[0], scale[1], scale[2]);
    parentTransform.add(transform);
    node.listChildren().forEach((child) => {
      this.parseGLTFRecursive(child, transform);
    });
  }
  static parseGLTFPrimitive(primitive) {
    const positions = primitive.getAttribute("POSITION");
    const normals = primitive.getAttribute("NORMAL");
    const colors = primitive.getAttribute("COLOR_0");
    const uvs = primitive.getAttribute("TEXCOORD_0");
    const indices = primitive.getIndices();
    const material = primitive.getMaterial();
    const mesh = new Mesh3();
    if (positions) {
      mesh.setVertices(positions.getArray());
    }
    if (normals) {
      mesh.setNormals(normals.getArray());
    }
    if (colors) {
      mesh.setColors(colors.getArray());
    }
    if (uvs) {
      mesh.setTextureCoordinates(uvs.getArray());
    }
    if (indices) {
      mesh.setIndices(indices.getArray());
    }
    if (material) {
      const materialColor = material.getBaseColorFactor();
      mesh.material.setColor(new Color(materialColor[0], materialColor[1], materialColor[2], materialColor[3]));
    }
    return mesh;
  }
};

// node_modules/property-graph/dist/property-graph.modern.js
var EventDispatcher = class {
  constructor() {
    this._listeners = {};
  }
  addEventListener(type, listener) {
    const listeners = this._listeners;
    if (listeners[type] === void 0) {
      listeners[type] = [];
    }
    if (listeners[type].indexOf(listener) === -1) {
      listeners[type].push(listener);
    }
    return this;
  }
  removeEventListener(type, listener) {
    if (this._listeners === void 0)
      return this;
    const listeners = this._listeners;
    const listenerArray = listeners[type];
    if (listenerArray !== void 0) {
      const index = listenerArray.indexOf(listener);
      if (index !== -1) {
        listenerArray.splice(index, 1);
      }
    }
    return this;
  }
  dispatchEvent(event) {
    if (this._listeners === void 0)
      return this;
    const listeners = this._listeners;
    const listenerArray = listeners[event.type];
    if (listenerArray !== void 0) {
      const array = listenerArray.slice(0);
      for (let i = 0, l2 = array.length; i < l2; i++) {
        array[i].call(this, event);
      }
    }
    return this;
  }
  dispose() {
    for (const key in this._listeners) {
      delete this._listeners[key];
    }
  }
};
var GraphEdge = class extends EventDispatcher {
  constructor(_name, _parent, _child, _attributes = {}) {
    super();
    this._name = void 0;
    this._parent = void 0;
    this._child = void 0;
    this._attributes = void 0;
    this._disposed = false;
    this._name = _name;
    this._parent = _parent;
    this._child = _child;
    this._attributes = _attributes;
    if (!_parent.isOnGraph(_child)) {
      throw new Error("Cannot connect disconnected graphs.");
    }
  }
  getName() {
    return this._name;
  }
  getParent() {
    return this._parent;
  }
  getChild() {
    return this._child;
  }
  setChild(child) {
    this._child = child;
    return this;
  }
  getAttributes() {
    return this._attributes;
  }
  dispose() {
    if (this._disposed)
      return;
    this._disposed = true;
    this.dispatchEvent({
      type: "dispose",
      target: this
    });
    super.dispose();
  }
  isDisposed() {
    return this._disposed;
  }
};
var Graph = class extends EventDispatcher {
  constructor(...args) {
    super(...args);
    this._emptySet = /* @__PURE__ */ new Set();
    this._edges = /* @__PURE__ */ new Set();
    this._parentEdges = /* @__PURE__ */ new Map();
    this._childEdges = /* @__PURE__ */ new Map();
  }
  listEdges() {
    return Array.from(this._edges);
  }
  listParentEdges(node) {
    return Array.from(this._childEdges.get(node) || this._emptySet);
  }
  listParents(node) {
    return this.listParentEdges(node).map((edge) => edge.getParent());
  }
  listChildEdges(node) {
    return Array.from(this._parentEdges.get(node) || this._emptySet);
  }
  listChildren(node) {
    return this.listChildEdges(node).map((edge) => edge.getChild());
  }
  disconnectParents(node, filter) {
    let edges = this.listParentEdges(node);
    if (filter) {
      edges = edges.filter((edge) => filter(edge.getParent()));
    }
    edges.forEach((edge) => edge.dispose());
    return this;
  }
  createEdge(name, a, b, attributes) {
    return this._registerEdge(new GraphEdge(name, a, b, attributes));
  }
  _registerEdge(edge) {
    this._edges.add(edge);
    const parent = edge.getParent();
    if (!this._parentEdges.has(parent))
      this._parentEdges.set(parent, /* @__PURE__ */ new Set());
    this._parentEdges.get(parent).add(edge);
    const child = edge.getChild();
    if (!this._childEdges.has(child))
      this._childEdges.set(child, /* @__PURE__ */ new Set());
    this._childEdges.get(child).add(edge);
    edge.addEventListener("dispose", () => this._removeEdge(edge));
    return edge;
  }
  _removeEdge(edge) {
    this._edges.delete(edge);
    this._parentEdges.get(edge.getParent()).delete(edge);
    this._childEdges.get(edge.getChild()).delete(edge);
    return this;
  }
};
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function isRef(value) {
  return value instanceof GraphEdge;
}
function isRefList(value) {
  return Array.isArray(value) && value[0] instanceof GraphEdge;
}
function isRefMap(value) {
  return !!(isPlainObject(value) && getFirstValue(value) instanceof GraphEdge);
}
function getFirstValue(value) {
  for (const key in value) {
    return value[key];
  }
}
function isPlainObject(value) {
  return Boolean(value) && Object.getPrototypeOf(value) === Object.prototype;
}
var $attributes = Symbol("attributes");
var $immutableKeys = Symbol("immutableKeys");
var GraphNode = class extends EventDispatcher {
  constructor(graph) {
    super();
    this._disposed = false;
    this.graph = void 0;
    this[$attributes] = void 0;
    this[$immutableKeys] = void 0;
    this.graph = graph;
    this[$immutableKeys] = /* @__PURE__ */ new Set();
    this[$attributes] = this._createAttributes();
  }
  getDefaults() {
    return {};
  }
  _createAttributes() {
    const defaultAttributes = this.getDefaults();
    const attributes = {};
    for (const key in defaultAttributes) {
      const value = defaultAttributes[key];
      if (value instanceof GraphNode) {
        const ref = this.graph.createEdge(key, this, value);
        ref.addEventListener("dispose", () => value.dispose());
        this[$immutableKeys].add(key);
        attributes[key] = ref;
      } else {
        attributes[key] = value;
      }
    }
    return attributes;
  }
  isOnGraph(other) {
    return this.graph === other.graph;
  }
  isDisposed() {
    return this._disposed;
  }
  dispose() {
    if (this._disposed)
      return;
    this.graph.listChildEdges(this).forEach((edge) => edge.dispose());
    this.graph.disconnectParents(this);
    this._disposed = true;
    this.dispatchEvent({
      type: "dispose"
    });
  }
  detach() {
    this.graph.disconnectParents(this);
    return this;
  }
  swap(old, replacement) {
    for (const attribute in this[$attributes]) {
      const value = this[$attributes][attribute];
      if (isRef(value)) {
        const ref = value;
        if (ref.getChild() === old) {
          this.setRef(attribute, replacement, ref.getAttributes());
        }
      } else if (isRefList(value)) {
        const refs = value;
        const ref = refs.find((ref2) => ref2.getChild() === old);
        if (ref) {
          const refAttributes = ref.getAttributes();
          this.removeRef(attribute, old).addRef(attribute, replacement, refAttributes);
        }
      } else if (isRefMap(value)) {
        const refMap = value;
        for (const key in refMap) {
          const ref = refMap[key];
          if (ref.getChild() === old) {
            this.setRefMap(attribute, key, replacement, ref.getAttributes());
          }
        }
      }
    }
    return this;
  }
  get(attribute) {
    return this[$attributes][attribute];
  }
  set(attribute, value) {
    this[$attributes][attribute] = value;
    return this.dispatchEvent({
      type: "change",
      attribute
    });
  }
  getRef(attribute) {
    const ref = this[$attributes][attribute];
    return ref ? ref.getChild() : null;
  }
  setRef(attribute, value, attributes) {
    if (this[$immutableKeys].has(attribute)) {
      throw new Error(`Cannot overwrite immutable attribute, "${attribute}".`);
    }
    const prevRef = this[$attributes][attribute];
    if (prevRef)
      prevRef.dispose();
    if (!value)
      return this;
    const ref = this.graph.createEdge(attribute, this, value, attributes);
    ref.addEventListener("dispose", () => {
      delete this[$attributes][attribute];
      this.dispatchEvent({
        type: "change",
        attribute
      });
    });
    this[$attributes][attribute] = ref;
    return this.dispatchEvent({
      type: "change",
      attribute
    });
  }
  listRefs(attribute) {
    const refs = this[$attributes][attribute];
    return refs.map((ref) => ref.getChild());
  }
  addRef(attribute, value, attributes) {
    const ref = this.graph.createEdge(attribute, this, value, attributes);
    const refs = this[$attributes][attribute];
    refs.push(ref);
    ref.addEventListener("dispose", () => {
      let index;
      while ((index = refs.indexOf(ref)) !== -1) {
        refs.splice(index, 1);
      }
      this.dispatchEvent({
        type: "change",
        attribute
      });
    });
    return this.dispatchEvent({
      type: "change",
      attribute
    });
  }
  removeRef(attribute, value) {
    const refs = this[$attributes][attribute];
    const pruned = refs.filter((ref) => ref.getChild() === value);
    pruned.forEach((ref) => ref.dispose());
    return this;
  }
  listRefMapKeys(key) {
    return Object.keys(this[$attributes][key]);
  }
  listRefMapValues(key) {
    return Object.values(this[$attributes][key]).map((ref) => ref.getChild());
  }
  getRefMap(attribute, key) {
    const refMap = this[$attributes][attribute];
    return refMap[key] ? refMap[key].getChild() : null;
  }
  setRefMap(attribute, key, value, metadata) {
    const refMap = this[$attributes][attribute];
    const prevRef = refMap[key];
    if (prevRef)
      prevRef.dispose();
    if (!value)
      return this;
    metadata = Object.assign(metadata || {}, {
      key
    });
    const ref = this.graph.createEdge(attribute, this, value, _extends({}, metadata, {
      key
    }));
    ref.addEventListener("dispose", () => {
      delete refMap[key];
      this.dispatchEvent({
        type: "change",
        attribute,
        key
      });
    });
    refMap[key] = ref;
    return this.dispatchEvent({
      type: "change",
      attribute,
      key
    });
  }
  dispatchEvent(event) {
    super.dispatchEvent(_extends({}, event, {
      target: this
    }));
    this.graph.dispatchEvent(_extends({}, event, {
      target: this,
      type: `node:${event.type}`
    }));
    return this;
  }
};

// node_modules/@gltf-transform/core/dist/core.modern.js
var u = "v3.7.0";
var c = "@glb.bin";
var h;
var f;
var l;
var d;
var g;
!function(t) {
  t.ACCESSOR = "Accessor", t.ANIMATION = "Animation", t.ANIMATION_CHANNEL = "AnimationChannel", t.ANIMATION_SAMPLER = "AnimationSampler", t.BUFFER = "Buffer", t.CAMERA = "Camera", t.MATERIAL = "Material", t.MESH = "Mesh", t.PRIMITIVE = "Primitive", t.PRIMITIVE_TARGET = "PrimitiveTarget", t.NODE = "Node", t.ROOT = "Root", t.SCENE = "Scene", t.SKIN = "Skin", t.TEXTURE = "Texture", t.TEXTURE_INFO = "TextureInfo";
}(h || (h = {})), function(t) {
  t.INTERLEAVED = "interleaved", t.SEPARATE = "separate";
}(f || (f = {})), function(t) {
  t.ARRAY_BUFFER = "ARRAY_BUFFER", t.ELEMENT_ARRAY_BUFFER = "ELEMENT_ARRAY_BUFFER", t.INVERSE_BIND_MATRICES = "INVERSE_BIND_MATRICES", t.OTHER = "OTHER", t.SPARSE = "SPARSE";
}(l || (l = {})), function(t) {
  t[t.R = 4096] = "R", t[t.G = 256] = "G", t[t.B = 16] = "B", t[t.A = 1] = "A";
}(d || (d = {})), function(t) {
  t.GLTF = "GLTF", t.GLB = "GLB";
}(g || (g = {}));
var p = { 5120: Int8Array, 5121: Uint8Array, 5122: Int16Array, 5123: Uint16Array, 5125: Uint32Array, 5126: Float32Array };
var m;
var w = "undefined" != typeof Float32Array ? Float32Array : Array;
function y(t) {
  return Math.hypot(t[0], t[1], t[2]);
}
Math.hypot || (Math.hypot = function() {
  for (var t = 0, e = arguments.length; e--; )
    t += arguments[e] * arguments[e];
  return Math.sqrt(t);
}), m = new w(3), w != Float32Array && (m[0] = 0, m[1] = 0, m[2] = 0);
var E = class {
  static createBufferFromDataURI(t) {
    if ("undefined" == typeof Buffer) {
      const e = atob(t.split(",")[1]), r = new Uint8Array(e.length);
      for (let t2 = 0; t2 < e.length; t2++)
        r[t2] = e.charCodeAt(t2);
      return r;
    }
    {
      const e = t.split(",")[1], r = t.indexOf("base64") >= 0;
      return Buffer.from(e, r ? "base64" : "utf8");
    }
  }
  static encodeText(t) {
    return "undefined" != typeof TextEncoder ? new TextEncoder().encode(t) : Buffer.from(t);
  }
  static decodeText(t) {
    return "undefined" != typeof TextDecoder ? new TextDecoder().decode(t) : Buffer.from(t).toString("utf8");
  }
  static concat(t) {
    let e = 0;
    for (const r2 of t)
      e += r2.byteLength;
    const r = new Uint8Array(e);
    let s = 0;
    for (const e2 of t)
      r.set(e2, s), s += e2.byteLength;
    return r;
  }
  static pad(t, e = 0) {
    const r = this.padNumber(t.byteLength);
    if (r === t.byteLength)
      return t;
    const s = new Uint8Array(r);
    if (s.set(t), 0 !== e)
      for (let n = t.byteLength; n < r; n++)
        s[n] = e;
    return s;
  }
  static padNumber(t) {
    return 4 * Math.ceil(t / 4);
  }
  static equals(t, e) {
    if (t === e)
      return true;
    if (t.byteLength !== e.byteLength)
      return false;
    let r = t.byteLength;
    for (; r--; )
      if (t[r] !== e[r])
        return false;
    return true;
  }
  static toView(t, e = 0, r = Infinity) {
    return new Uint8Array(t.buffer, t.byteOffset + e, Math.min(t.byteLength, r));
  }
  static assertView(t) {
    if (t && !ArrayBuffer.isView(t))
      throw new Error(`Method requires Uint8Array parameter; received "${typeof t}".`);
    return t;
  }
};
var S = class {
  static hexToFactor(t, e) {
    t = Math.floor(t);
    const r = e;
    return r[0] = (t >> 16 & 255) / 255, r[1] = (t >> 8 & 255) / 255, r[2] = (255 & t) / 255, this.convertSRGBToLinear(e, e);
  }
  static factorToHex(t) {
    const e = [...t], [r, s, n] = this.convertLinearToSRGB(t, e);
    return 255 * r << 16 ^ 255 * s << 8 ^ 255 * n << 0;
  }
  static convertSRGBToLinear(t, e) {
    const r = t, s = e;
    for (let t2 = 0; t2 < 3; t2++)
      s[t2] = r[t2] < 0.04045 ? 0.0773993808 * r[t2] : Math.pow(0.9478672986 * r[t2] + 0.0521327014, 2.4);
    return e;
  }
  static convertLinearToSRGB(t, e) {
    const r = t, s = e;
    for (let t2 = 0; t2 < 3; t2++)
      s[t2] = r[t2] < 31308e-7 ? 12.92 * r[t2] : 1.055 * Math.pow(r[t2], 0.41666) - 0.055;
    return e;
  }
};
var M = class {
  match(t) {
    return t.length >= 8 && 137 === t[0] && 80 === t[1] && 78 === t[2] && 71 === t[3] && 13 === t[4] && 10 === t[5] && 26 === t[6] && 10 === t[7];
  }
  getSize(t) {
    const e = new DataView(t.buffer, t.byteOffset);
    return E.decodeText(t.slice(12, 16)) === M.PNG_FRIED_CHUNK_NAME ? [e.getUint32(32, false), e.getUint32(36, false)] : [e.getUint32(16, false), e.getUint32(20, false)];
  }
  getChannels(t) {
    return 4;
  }
};
M.PNG_FRIED_CHUNK_NAME = "CgBI";
var I = class {
  static registerFormat(t, e) {
    this.impls[t] = e;
  }
  static getMimeType(t) {
    for (const e in this.impls)
      if (this.impls[e].match(t))
        return e;
    return null;
  }
  static getSize(t, e) {
    return this.impls[e] ? this.impls[e].getSize(t) : null;
  }
  static getChannels(t, e) {
    return this.impls[e] ? this.impls[e].getChannels(t) : null;
  }
  static getVRAMByteLength(t, e) {
    if (!this.impls[e])
      return null;
    if (this.impls[e].getVRAMByteLength)
      return this.impls[e].getVRAMByteLength(t);
    let r = 0;
    const s = this.getSize(t, e);
    if (!s)
      return null;
    for (; s[0] > 1 || s[1] > 1; )
      r += s[0] * s[1] * 4, s[0] = Math.max(Math.floor(s[0] / 2), 1), s[1] = Math.max(Math.floor(s[1] / 2), 1);
    return r += 4, r;
  }
  static mimeTypeToExtension(t) {
    return "image/jpeg" === t ? "jpg" : t.split("/").pop();
  }
  static extensionToMimeType(t) {
    return "jpg" === t ? "image/jpeg" : t ? `image/${t}` : "";
  }
};
function R(t, e) {
  if (e > t.byteLength)
    throw new TypeError("Corrupt JPG, exceeded buffer limits");
  if (255 !== t.getUint8(e))
    throw new TypeError("Invalid JPG, marker table corrupted");
  return t;
}
I.impls = { "image/jpeg": new class {
  match(t) {
    return t.length >= 3 && 255 === t[0] && 216 === t[1] && 255 === t[2];
  }
  getSize(t) {
    let e, r, s = new DataView(t.buffer, t.byteOffset + 4);
    for (; s.byteLength; ) {
      if (e = s.getUint16(0, false), R(s, e), r = s.getUint8(e + 1), 192 === r || 193 === r || 194 === r)
        return [s.getUint16(e + 7, false), s.getUint16(e + 5, false)];
      s = new DataView(t.buffer, s.byteOffset + e + 2);
    }
    throw new TypeError("Invalid JPG, no size found");
  }
  getChannels(t) {
    return 3;
  }
}(), "image/png": new M() };
var N = class {
  static basename(t) {
    const e = t.split(/[\\/]/).pop();
    return e.substring(0, e.lastIndexOf("."));
  }
  static extension(t) {
    if (t.startsWith("data:image/")) {
      const e = t.match(/data:(image\/\w+)/)[1];
      return I.mimeTypeToExtension(e);
    }
    return t.startsWith("data:model/gltf+json") ? "gltf" : t.startsWith("data:model/gltf-binary") ? "glb" : t.startsWith("data:application/") ? "bin" : t.split(/[\\/]/).pop().split(/[.]/).pop();
  }
};
function O(t) {
  return "[object Object]" === Object.prototype.toString.call(t);
}
function C(t) {
  if (false === O(t))
    return false;
  const e = t.constructor;
  if (void 0 === e)
    return true;
  const r = e.prototype;
  return false !== O(r) && false !== Object.prototype.hasOwnProperty.call(r, "isPrototypeOf");
}
var F;
var U;
!function(t) {
  t[t.SILENT = 4] = "SILENT", t[t.ERROR = 3] = "ERROR", t[t.WARN = 2] = "WARN", t[t.INFO = 1] = "INFO", t[t.DEBUG = 0] = "DEBUG";
}(U || (U = {}));
var B = class {
  constructor(t) {
    this.verbosity = void 0, this.verbosity = t;
  }
  debug(t) {
    this.verbosity <= B.Verbosity.DEBUG && console.debug(t);
  }
  info(t) {
    this.verbosity <= B.Verbosity.INFO && console.info(t);
  }
  warn(t) {
    this.verbosity <= B.Verbosity.WARN && console.warn(t);
  }
  error(t) {
    this.verbosity <= B.Verbosity.ERROR && console.error(t);
  }
};
function P(t, e, r) {
  var s = e[0], n = e[1], i = e[2], o = e[3], a = e[4], u2 = e[5], c2 = e[6], h2 = e[7], f2 = e[8], l2 = e[9], d2 = e[10], g2 = e[11], p2 = e[12], m2 = e[13], w2 = e[14], y2 = e[15], v = r[0], T = r[1], b = r[2], x = r[3];
  return t[0] = v * s + T * a + b * f2 + x * p2, t[1] = v * n + T * u2 + b * l2 + x * m2, t[2] = v * i + T * c2 + b * d2 + x * w2, t[3] = v * o + T * h2 + b * g2 + x * y2, t[4] = (v = r[4]) * s + (T = r[5]) * a + (b = r[6]) * f2 + (x = r[7]) * p2, t[5] = v * n + T * u2 + b * l2 + x * m2, t[6] = v * i + T * c2 + b * d2 + x * w2, t[7] = v * o + T * h2 + b * g2 + x * y2, t[8] = (v = r[8]) * s + (T = r[9]) * a + (b = r[10]) * f2 + (x = r[11]) * p2, t[9] = v * n + T * u2 + b * l2 + x * m2, t[10] = v * i + T * c2 + b * d2 + x * w2, t[11] = v * o + T * h2 + b * g2 + x * y2, t[12] = (v = r[12]) * s + (T = r[13]) * a + (b = r[14]) * f2 + (x = r[15]) * p2, t[13] = v * n + T * u2 + b * l2 + x * m2, t[14] = v * i + T * c2 + b * d2 + x * w2, t[15] = v * o + T * h2 + b * g2 + x * y2, t;
}
F = B, B.Verbosity = U, B.DEFAULT_INSTANCE = new F(F.Verbosity.INFO);
var L = class {
  static identity(t) {
    return t;
  }
  static eq(t, e, r = 1e-5) {
    if (t.length !== e.length)
      return false;
    for (let s = 0; s < t.length; s++)
      if (Math.abs(t[s] - e[s]) > r)
        return false;
    return true;
  }
  static decodeNormalizedInt(t, e) {
    switch (e) {
      case 5126:
        return t;
      case 5123:
        return t / 65535;
      case 5121:
        return t / 255;
      case 5122:
        return Math.max(t / 32767, -1);
      case 5120:
        return Math.max(t / 127, -1);
      default:
        throw new Error("Invalid component type.");
    }
  }
  static denormalize(t, e) {
    return L.decodeNormalizedInt(t, e);
  }
  static encodeNormalizedInt(t, e) {
    switch (e) {
      case 5126:
        return t;
      case 5123:
        return Math.round(65535 * t);
      case 5121:
        return Math.round(255 * t);
      case 5122:
        return Math.round(32767 * t);
      case 5120:
        return Math.round(127 * t);
      default:
        throw new Error("Invalid component type.");
    }
  }
  static normalize(t, e) {
    return L.encodeNormalizedInt(t, e);
  }
  static decompose(t, e, r, s) {
    let n = y([t[0], t[1], t[2]]);
    const i = y([t[4], t[5], t[6]]), o = y([t[8], t[9], t[10]]);
    var a, u2, c2, h2, f2, l2, d2, g2, p2, m2, v, T, b, x, A, E2, S2;
    ((u2 = (a = t)[0]) * (d2 = a[5]) - (c2 = a[1]) * (l2 = a[4])) * ((T = a[10]) * (S2 = a[15]) - (b = a[11]) * (E2 = a[14])) - (u2 * (g2 = a[6]) - (h2 = a[2]) * l2) * ((v = a[9]) * S2 - b * (A = a[13])) + (u2 * (p2 = a[7]) - (f2 = a[3]) * l2) * (v * E2 - T * A) + (c2 * g2 - h2 * d2) * ((m2 = a[8]) * S2 - b * (x = a[12])) - (c2 * p2 - f2 * d2) * (m2 * E2 - T * x) + (h2 * p2 - f2 * g2) * (m2 * A - v * x) < 0 && (n = -n), e[0] = t[12], e[1] = t[13], e[2] = t[14];
    const M2 = t.slice(), I2 = 1 / n, R2 = 1 / i, N2 = 1 / o;
    M2[0] *= I2, M2[1] *= I2, M2[2] *= I2, M2[4] *= R2, M2[5] *= R2, M2[6] *= R2, M2[8] *= N2, M2[9] *= N2, M2[10] *= N2, function(t2, e2) {
      var r2 = new w(3);
      !function(t3, e3) {
        var r3 = e3[4], s3 = e3[5], n3 = e3[6], i3 = e3[8], o3 = e3[9], a3 = e3[10];
        t3[0] = Math.hypot(e3[0], e3[1], e3[2]), t3[1] = Math.hypot(r3, s3, n3), t3[2] = Math.hypot(i3, o3, a3);
      }(r2, e2);
      var s2 = 1 / r2[0], n2 = 1 / r2[1], i2 = 1 / r2[2], o2 = e2[0] * s2, a2 = e2[1] * n2, u3 = e2[2] * i2, c3 = e2[4] * s2, h3 = e2[5] * n2, f3 = e2[6] * i2, l3 = e2[8] * s2, d3 = e2[9] * n2, g3 = e2[10] * i2, p3 = o2 + h3 + g3, m3 = 0;
      p3 > 0 ? (m3 = 2 * Math.sqrt(p3 + 1), t2[3] = 0.25 * m3, t2[0] = (f3 - d3) / m3, t2[1] = (l3 - u3) / m3, t2[2] = (a2 - c3) / m3) : o2 > h3 && o2 > g3 ? (m3 = 2 * Math.sqrt(1 + o2 - h3 - g3), t2[3] = (f3 - d3) / m3, t2[0] = 0.25 * m3, t2[1] = (a2 + c3) / m3, t2[2] = (l3 + u3) / m3) : h3 > g3 ? (m3 = 2 * Math.sqrt(1 + h3 - o2 - g3), t2[3] = (l3 - u3) / m3, t2[0] = (a2 + c3) / m3, t2[1] = 0.25 * m3, t2[2] = (f3 + d3) / m3) : (m3 = 2 * Math.sqrt(1 + g3 - o2 - h3), t2[3] = (a2 - c3) / m3, t2[0] = (l3 + u3) / m3, t2[1] = (f3 + d3) / m3, t2[2] = 0.25 * m3);
    }(r, M2), s[0] = n, s[1] = i, s[2] = o;
  }
  static compose(t, e, r, s) {
    const n = s, i = e[0], o = e[1], a = e[2], u2 = e[3], c2 = i + i, h2 = o + o, f2 = a + a, l2 = i * c2, d2 = i * h2, g2 = i * f2, p2 = o * h2, m2 = o * f2, w2 = a * f2, y2 = u2 * c2, v = u2 * h2, T = u2 * f2, b = r[0], x = r[1], A = r[2];
    return n[0] = (1 - (p2 + w2)) * b, n[1] = (d2 + T) * b, n[2] = (g2 - v) * b, n[3] = 0, n[4] = (d2 - T) * x, n[5] = (1 - (l2 + w2)) * x, n[6] = (m2 + y2) * x, n[7] = 0, n[8] = (g2 + v) * A, n[9] = (m2 - y2) * A, n[10] = (1 - (l2 + p2)) * A, n[11] = 0, n[12] = t[0], n[13] = t[1], n[14] = t[2], n[15] = 1, n;
  }
};
function j(t, e) {
  if (!!t != !!e)
    return false;
  const r = t.getChild(), s = e.getChild();
  return r === s || r.equals(s);
}
function D(t, e) {
  if (!!t != !!e)
    return false;
  if (t.length !== e.length)
    return false;
  for (let r = 0; r < t.length; r++) {
    const s = t[r], n = e[r];
    if (s.getChild() !== n.getChild() && !s.getChild().equals(n.getChild()))
      return false;
  }
  return true;
}
function _(t, e) {
  if (!!t != !!e)
    return false;
  const r = Object.keys(t), s = Object.keys(e);
  if (r.length !== s.length)
    return false;
  for (const r2 in t) {
    const s2 = t[r2], n = e[r2];
    if (!!s2 != !!n)
      return false;
    const i = s2.getChild(), o = n.getChild();
    if (i !== o && !i.equals(o))
      return false;
  }
  return true;
}
function k(t, e) {
  if (t === e)
    return true;
  if (!!t != !!e || !t || !e)
    return false;
  if (t.length !== e.length)
    return false;
  for (let r = 0; r < t.length; r++)
    if (t[r] !== e[r])
      return false;
  return true;
}
function z(t, e) {
  if (t === e)
    return true;
  if (!!t != !!e)
    return false;
  if (!C(t) || !C(e))
    return t === e;
  const r = t, s = e;
  let n, i = 0, o = 0;
  for (n in r)
    i++;
  for (n in s)
    o++;
  if (i !== o)
    return false;
  for (n in r) {
    const t2 = r[n], e2 = s[n];
    if (G(t2) && G(e2)) {
      if (!k(t2, e2))
        return false;
    } else if (C(t2) && C(e2)) {
      if (!z(t2, e2))
        return false;
    } else if (t2 !== e2)
      return false;
  }
  return true;
}
function G(t) {
  return Array.isArray(t) || ArrayBuffer.isView(t);
}
var J = /* @__PURE__ */ new Set();
var $ = function() {
  let t = "";
  for (let e = 0; e < 6; e++)
    t += "23456789abdegjkmnpqrvwxyzABDEGJKMNPQRVWXYZ".charAt(Math.floor(42 * Math.random()));
  return t;
};
var V = function() {
  for (let t = 0; t < 999; t++) {
    const t2 = $();
    if (!J.has(t2))
      return J.add(t2), t2;
  }
  return "";
};
var W = "https://null.example";
var q = class {
  static dirname(t) {
    const e = t.lastIndexOf("/");
    return -1 === e ? "./" : t.substring(0, e + 1);
  }
  static basename(t) {
    return N.basename(new URL(t, W).pathname);
  }
  static extension(t) {
    return N.extension(new URL(t, W).pathname);
  }
  static resolve(t, e) {
    if (!this.isRelativePath(e))
      return e;
    const r = t.split("/"), s = e.split("/");
    r.pop();
    for (let t2 = 0; t2 < s.length; t2++)
      "." !== s[t2] && (".." === s[t2] ? r.pop() : r.push(s[t2]));
    return r.join("/");
  }
  static isAbsoluteURL(t) {
    return this.PROTOCOL_REGEXP.test(t);
  }
  static isRelativePath(t) {
    return !/^(?:[a-zA-Z]+:)?\//.test(t);
  }
};
q.DEFAULT_INIT = {}, q.PROTOCOL_REGEXP = /^[a-zA-Z]+:\/\//;
var H = (t) => t;
var Y = /* @__PURE__ */ new Set();
var Z = class extends GraphNode {
  constructor(t, r = "") {
    super(t), this[$attributes].name = r, this.init(), this.dispatchEvent({ type: "create" });
  }
  getGraph() {
    return this.graph;
  }
  getDefaults() {
    return Object.assign(super.getDefaults(), { name: "", extras: {} });
  }
  set(t, e) {
    return Array.isArray(e) && (e = e.slice()), super.set(t, e);
  }
  getName() {
    return this.get("name");
  }
  setName(t) {
    return this.set("name", t);
  }
  getExtras() {
    return this.get("extras");
  }
  setExtras(t) {
    return this.set("extras", t);
  }
  clone() {
    return new (0, this.constructor)(this.graph).copy(this, H);
  }
  copy(t, o = H) {
    for (const t2 in this[$attributes]) {
      const o2 = this[$attributes][t2];
      if (o2 instanceof GraphEdge)
        this[$immutableKeys].has(t2) || o2.dispose();
      else if (isRefList(o2))
        for (const t3 of o2)
          t3.dispose();
      else if (isRefMap(o2))
        for (const t3 in o2)
          o2[t3].dispose();
    }
    for (const a in t[$attributes]) {
      const u2 = this[$attributes][a], c2 = t[$attributes][a];
      if (c2 instanceof GraphEdge)
        this[$immutableKeys].has(a) ? u2.getChild().copy(o(c2.getChild()), o) : this.setRef(a, o(c2.getChild()), c2.getAttributes());
      else if (isRefList(c2))
        for (const t2 of c2)
          this.addRef(a, o(t2.getChild()), t2.getAttributes());
      else if (isRefMap(c2))
        for (const t2 in c2) {
          const e = c2[t2];
          this.setRefMap(a, t2, o(e.getChild()), e.getAttributes());
        }
      else
        this[$attributes][a] = C(c2) ? JSON.parse(JSON.stringify(c2)) : Array.isArray(c2) || c2 instanceof ArrayBuffer || ArrayBuffer.isView(c2) ? c2.slice() : c2;
    }
    return this;
  }
  equals(t, r = Y) {
    if (this === t)
      return true;
    if (this.propertyType !== t.propertyType)
      return false;
    for (const s in this[$attributes]) {
      if (r.has(s))
        continue;
      const a = this[$attributes][s], u2 = t[$attributes][s];
      if (isRef(a) || isRef(u2)) {
        if (!j(a, u2))
          return false;
      } else if (isRefList(a) || isRefList(u2)) {
        if (!D(a, u2))
          return false;
      } else if (isRefMap(a) || isRefMap(u2)) {
        if (!_(a, u2))
          return false;
      } else if (C(a) || C(u2)) {
        if (!z(a, u2))
          return false;
      } else if (G(a) || G(u2)) {
        if (!k(a, u2))
          return false;
      } else if (a !== u2)
        return false;
    }
    return true;
  }
  detach() {
    return this.graph.disconnectParents(this, (t) => "Root" !== t.propertyType), this;
  }
  listParents() {
    return this.graph.listParents(this);
  }
};
var K = class extends Z {
  getDefaults() {
    return Object.assign(super.getDefaults(), { extensions: {} });
  }
  getExtension(t) {
    return this.getRefMap("extensions", t);
  }
  setExtension(t, e) {
    return e && e.t(this), this.setRefMap("extensions", t, e);
  }
  listExtensions() {
    return this.listRefMapValues("extensions");
  }
};
var Q = class extends K {
  constructor(...t) {
    super(...t), this.i = L.identity, this.o = L.identity;
  }
  init() {
    this.propertyType = h.ACCESSOR;
  }
  getDefaults() {
    return Object.assign(super.getDefaults(), { array: null, type: Q.Type.SCALAR, componentType: Q.ComponentType.FLOAT, normalized: false, sparse: false, buffer: null });
  }
  copy(t, e = H) {
    return super.copy(t, e), this.i = t.i, this.o = t.o, this;
  }
  static getElementSize(t) {
    switch (t) {
      case Q.Type.SCALAR:
        return 1;
      case Q.Type.VEC2:
        return 2;
      case Q.Type.VEC3:
        return 3;
      case Q.Type.VEC4:
      case Q.Type.MAT2:
        return 4;
      case Q.Type.MAT3:
        return 9;
      case Q.Type.MAT4:
        return 16;
      default:
        throw new Error("Unexpected type: " + t);
    }
  }
  static getComponentSize(t) {
    switch (t) {
      case Q.ComponentType.BYTE:
      case Q.ComponentType.UNSIGNED_BYTE:
        return 1;
      case Q.ComponentType.SHORT:
      case Q.ComponentType.UNSIGNED_SHORT:
        return 2;
      case Q.ComponentType.UNSIGNED_INT:
      case Q.ComponentType.FLOAT:
        return 4;
      default:
        throw new Error("Unexpected component type: " + t);
    }
  }
  getMinNormalized(t) {
    const e = this.getElementSize();
    this.getMin(t);
    for (let r = 0; r < e; r++)
      t[r] = this.o(t[r]);
    return t;
  }
  getMin(t) {
    const e = this.get("array"), r = this.getCount(), s = this.getElementSize();
    for (let e2 = 0; e2 < s; e2++)
      t[e2] = Infinity;
    for (let n = 0; n < r * s; n += s)
      for (let r2 = 0; r2 < s; r2++) {
        const s2 = e[n + r2];
        Number.isFinite(s2) && (t[r2] = Math.min(t[r2], s2));
      }
    return t;
  }
  getMaxNormalized(t) {
    const e = this.getElementSize();
    this.getMax(t);
    for (let r = 0; r < e; r++)
      t[r] = this.o(t[r]);
    return t;
  }
  getMax(t) {
    const e = this.get("array"), r = this.getCount(), s = this.getElementSize();
    for (let e2 = 0; e2 < s; e2++)
      t[e2] = -Infinity;
    for (let n = 0; n < r * s; n += s)
      for (let r2 = 0; r2 < s; r2++) {
        const s2 = e[n + r2];
        Number.isFinite(s2) && (t[r2] = Math.max(t[r2], s2));
      }
    return t;
  }
  getCount() {
    const t = this.get("array");
    return t ? t.length / this.getElementSize() : 0;
  }
  getType() {
    return this.get("type");
  }
  setType(t) {
    return this.set("type", t);
  }
  getElementSize() {
    return Q.getElementSize(this.get("type"));
  }
  getComponentSize() {
    return this.get("array").BYTES_PER_ELEMENT;
  }
  getComponentType() {
    return this.get("componentType");
  }
  getNormalized() {
    return this.get("normalized");
  }
  setNormalized(t) {
    return this.set("normalized", t), t ? (this.o = (t2) => L.decodeNormalizedInt(t2, this.get("componentType")), this.i = (t2) => L.encodeNormalizedInt(t2, this.get("componentType"))) : (this.o = L.identity, this.i = L.identity), this;
  }
  getScalar(t) {
    const e = this.getElementSize();
    return this.o(this.get("array")[t * e]);
  }
  setScalar(t, e) {
    return this.get("array")[t * this.getElementSize()] = this.i(e), this;
  }
  getElement(t, e) {
    const r = this.getElementSize(), s = this.get("array");
    for (let n = 0; n < r; n++)
      e[n] = this.o(s[t * r + n]);
    return e;
  }
  setElement(t, e) {
    const r = this.getElementSize(), s = this.get("array");
    for (let n = 0; n < r; n++)
      s[t * r + n] = this.i(e[n]);
    return this;
  }
  getSparse() {
    return this.get("sparse");
  }
  setSparse(t) {
    return this.set("sparse", t);
  }
  getBuffer() {
    return this.getRef("buffer");
  }
  setBuffer(t) {
    return this.setRef("buffer", t);
  }
  getArray() {
    return this.get("array");
  }
  setArray(t) {
    return this.set("componentType", t ? function(t2) {
      switch (t2.constructor) {
        case Float32Array:
          return Q.ComponentType.FLOAT;
        case Uint32Array:
          return Q.ComponentType.UNSIGNED_INT;
        case Uint16Array:
          return Q.ComponentType.UNSIGNED_SHORT;
        case Uint8Array:
          return Q.ComponentType.UNSIGNED_BYTE;
        case Int16Array:
          return Q.ComponentType.SHORT;
        case Int8Array:
          return Q.ComponentType.BYTE;
        default:
          throw new Error("Unknown accessor componentType.");
      }
    }(t) : Q.ComponentType.FLOAT), this.set("array", t), this;
  }
  getByteLength() {
    const t = this.get("array");
    return t ? t.byteLength : 0;
  }
};
Q.Type = { SCALAR: "SCALAR", VEC2: "VEC2", VEC3: "VEC3", VEC4: "VEC4", MAT2: "MAT2", MAT3: "MAT3", MAT4: "MAT4" }, Q.ComponentType = { BYTE: 5120, UNSIGNED_BYTE: 5121, SHORT: 5122, UNSIGNED_SHORT: 5123, UNSIGNED_INT: 5125, FLOAT: 5126 };
var X = class extends K {
  init() {
    this.propertyType = h.ANIMATION;
  }
  getDefaults() {
    return Object.assign(super.getDefaults(), { channels: [], samplers: [] });
  }
  addChannel(t) {
    return this.addRef("channels", t);
  }
  removeChannel(t) {
    return this.removeRef("channels", t);
  }
  listChannels() {
    return this.listRefs("channels");
  }
  addSampler(t) {
    return this.addRef("samplers", t);
  }
  removeSampler(t) {
    return this.removeRef("samplers", t);
  }
  listSamplers() {
    return this.listRefs("samplers");
  }
};
var tt = class extends K {
  init() {
    this.propertyType = h.ANIMATION_CHANNEL;
  }
  getDefaults() {
    return Object.assign(super.getDefaults(), { targetPath: null, targetNode: null, sampler: null });
  }
  getTargetPath() {
    return this.get("targetPath");
  }
  setTargetPath(t) {
    return this.set("targetPath", t);
  }
  getTargetNode() {
    return this.getRef("targetNode");
  }
  setTargetNode(t) {
    return this.setRef("targetNode", t);
  }
  getSampler() {
    return this.getRef("sampler");
  }
  setSampler(t) {
    return this.setRef("sampler", t);
  }
};
tt.TargetPath = { TRANSLATION: "translation", ROTATION: "rotation", SCALE: "scale", WEIGHTS: "weights" };
var et = class extends K {
  init() {
    this.propertyType = h.ANIMATION_SAMPLER;
  }
  getDefaultAttributes() {
    return Object.assign(super.getDefaults(), { interpolation: et.Interpolation.LINEAR, input: null, output: null });
  }
  getInterpolation() {
    return this.get("interpolation");
  }
  setInterpolation(t) {
    return this.set("interpolation", t);
  }
  getInput() {
    return this.getRef("input");
  }
  setInput(t) {
    return this.setRef("input", t, { usage: l.OTHER });
  }
  getOutput() {
    return this.getRef("output");
  }
  setOutput(t) {
    return this.setRef("output", t, { usage: l.OTHER });
  }
};
et.Interpolation = { LINEAR: "LINEAR", STEP: "STEP", CUBICSPLINE: "CUBICSPLINE" };
var rt = class extends K {
  init() {
    this.propertyType = h.BUFFER;
  }
  getDefaults() {
    return Object.assign(super.getDefaults(), { uri: "" });
  }
  getURI() {
    return this.get("uri");
  }
  setURI(t) {
    return this.set("uri", t);
  }
};
var st = class extends K {
  init() {
    this.propertyType = h.CAMERA;
  }
  getDefaults() {
    return Object.assign(super.getDefaults(), { type: st.Type.PERSPECTIVE, znear: 0.1, zfar: 100, aspectRatio: null, yfov: 2 * Math.PI * 50 / 360, xmag: 1, ymag: 1 });
  }
  getType() {
    return this.get("type");
  }
  setType(t) {
    return this.set("type", t);
  }
  getZNear() {
    return this.get("znear");
  }
  setZNear(t) {
    return this.set("znear", t);
  }
  getZFar() {
    return this.get("zfar");
  }
  setZFar(t) {
    return this.set("zfar", t);
  }
  getAspectRatio() {
    return this.get("aspectRatio");
  }
  setAspectRatio(t) {
    return this.set("aspectRatio", t);
  }
  getYFov() {
    return this.get("yfov");
  }
  setYFov(t) {
    return this.set("yfov", t);
  }
  getXMag() {
    return this.get("xmag");
  }
  setXMag(t) {
    return this.set("xmag", t);
  }
  getYMag() {
    return this.get("ymag");
  }
  setYMag(t) {
    return this.set("ymag", t);
  }
};
st.Type = { PERSPECTIVE: "perspective", ORTHOGRAPHIC: "orthographic" };
var nt = class extends Z {
  t(t) {
    if (!this.parentTypes.includes(t.propertyType))
      throw new Error(`Parent "${t.propertyType}" invalid for child "${this.propertyType}".`);
  }
};
nt.EXTENSION_NAME = void 0;
var it = class extends K {
  init() {
    this.propertyType = h.TEXTURE_INFO;
  }
  getDefaults() {
    return Object.assign(super.getDefaults(), { texCoord: 0, magFilter: null, minFilter: null, wrapS: it.WrapMode.REPEAT, wrapT: it.WrapMode.REPEAT });
  }
  getTexCoord() {
    return this.get("texCoord");
  }
  setTexCoord(t) {
    return this.set("texCoord", t);
  }
  getMagFilter() {
    return this.get("magFilter");
  }
  setMagFilter(t) {
    return this.set("magFilter", t);
  }
  getMinFilter() {
    return this.get("minFilter");
  }
  setMinFilter(t) {
    return this.set("minFilter", t);
  }
  getWrapS() {
    return this.get("wrapS");
  }
  setWrapS(t) {
    return this.set("wrapS", t);
  }
  getWrapT() {
    return this.get("wrapT");
  }
  setWrapT(t) {
    return this.set("wrapT", t);
  }
};
it.WrapMode = { CLAMP_TO_EDGE: 33071, MIRRORED_REPEAT: 33648, REPEAT: 10497 }, it.MagFilter = { NEAREST: 9728, LINEAR: 9729 }, it.MinFilter = { NEAREST: 9728, LINEAR: 9729, NEAREST_MIPMAP_NEAREST: 9984, LINEAR_MIPMAP_NEAREST: 9985, NEAREST_MIPMAP_LINEAR: 9986, LINEAR_MIPMAP_LINEAR: 9987 };
var { R: ot, G: at, B: ut, A: ct } = d;
var ht = class extends K {
  init() {
    this.propertyType = h.MATERIAL;
  }
  getDefaults() {
    return Object.assign(super.getDefaults(), { alphaMode: ht.AlphaMode.OPAQUE, alphaCutoff: 0.5, doubleSided: false, baseColorFactor: [1, 1, 1, 1], baseColorTexture: null, baseColorTextureInfo: new it(this.graph, "baseColorTextureInfo"), emissiveFactor: [0, 0, 0], emissiveTexture: null, emissiveTextureInfo: new it(this.graph, "emissiveTextureInfo"), normalScale: 1, normalTexture: null, normalTextureInfo: new it(this.graph, "normalTextureInfo"), occlusionStrength: 1, occlusionTexture: null, occlusionTextureInfo: new it(this.graph, "occlusionTextureInfo"), roughnessFactor: 1, metallicFactor: 1, metallicRoughnessTexture: null, metallicRoughnessTextureInfo: new it(this.graph, "metallicRoughnessTextureInfo") });
  }
  getDoubleSided() {
    return this.get("doubleSided");
  }
  setDoubleSided(t) {
    return this.set("doubleSided", t);
  }
  getAlpha() {
    return this.get("baseColorFactor")[3];
  }
  setAlpha(t) {
    const e = this.get("baseColorFactor").slice();
    return e[3] = t, this.set("baseColorFactor", e);
  }
  getAlphaMode() {
    return this.get("alphaMode");
  }
  setAlphaMode(t) {
    return this.set("alphaMode", t);
  }
  getAlphaCutoff() {
    return this.get("alphaCutoff");
  }
  setAlphaCutoff(t) {
    return this.set("alphaCutoff", t);
  }
  getBaseColorFactor() {
    return this.get("baseColorFactor");
  }
  setBaseColorFactor(t) {
    return this.set("baseColorFactor", t);
  }
  getBaseColorHex() {
    return S.factorToHex(this.get("baseColorFactor"));
  }
  setBaseColorHex(t) {
    const e = this.get("baseColorFactor").slice();
    return this.set("baseColorFactor", S.hexToFactor(t, e));
  }
  getBaseColorTexture() {
    return this.getRef("baseColorTexture");
  }
  getBaseColorTextureInfo() {
    return this.getRef("baseColorTexture") ? this.getRef("baseColorTextureInfo") : null;
  }
  setBaseColorTexture(t) {
    return this.setRef("baseColorTexture", t, { channels: ot | at | ut | ct, isColor: true });
  }
  getEmissiveFactor() {
    return this.get("emissiveFactor");
  }
  setEmissiveFactor(t) {
    return this.set("emissiveFactor", t);
  }
  getEmissiveHex() {
    return S.factorToHex(this.get("emissiveFactor"));
  }
  setEmissiveHex(t) {
    const e = this.get("emissiveFactor").slice();
    return this.set("emissiveFactor", S.hexToFactor(t, e));
  }
  getEmissiveTexture() {
    return this.getRef("emissiveTexture");
  }
  getEmissiveTextureInfo() {
    return this.getRef("emissiveTexture") ? this.getRef("emissiveTextureInfo") : null;
  }
  setEmissiveTexture(t) {
    return this.setRef("emissiveTexture", t, { channels: ot | at | ut, isColor: true });
  }
  getNormalScale() {
    return this.get("normalScale");
  }
  setNormalScale(t) {
    return this.set("normalScale", t);
  }
  getNormalTexture() {
    return this.getRef("normalTexture");
  }
  getNormalTextureInfo() {
    return this.getRef("normalTexture") ? this.getRef("normalTextureInfo") : null;
  }
  setNormalTexture(t) {
    return this.setRef("normalTexture", t, { channels: ot | at | ut });
  }
  getOcclusionStrength() {
    return this.get("occlusionStrength");
  }
  setOcclusionStrength(t) {
    return this.set("occlusionStrength", t);
  }
  getOcclusionTexture() {
    return this.getRef("occlusionTexture");
  }
  getOcclusionTextureInfo() {
    return this.getRef("occlusionTexture") ? this.getRef("occlusionTextureInfo") : null;
  }
  setOcclusionTexture(t) {
    return this.setRef("occlusionTexture", t, { channels: ot });
  }
  getRoughnessFactor() {
    return this.get("roughnessFactor");
  }
  setRoughnessFactor(t) {
    return this.set("roughnessFactor", t);
  }
  getMetallicFactor() {
    return this.get("metallicFactor");
  }
  setMetallicFactor(t) {
    return this.set("metallicFactor", t);
  }
  getMetallicRoughnessTexture() {
    return this.getRef("metallicRoughnessTexture");
  }
  getMetallicRoughnessTextureInfo() {
    return this.getRef("metallicRoughnessTexture") ? this.getRef("metallicRoughnessTextureInfo") : null;
  }
  setMetallicRoughnessTexture(t) {
    return this.setRef("metallicRoughnessTexture", t, { channels: at | ut });
  }
};
ht.AlphaMode = { OPAQUE: "OPAQUE", MASK: "MASK", BLEND: "BLEND" };
var ft = class extends K {
  init() {
    this.propertyType = h.MESH;
  }
  getDefaults() {
    return Object.assign(super.getDefaults(), { weights: [], primitives: [] });
  }
  addPrimitive(t) {
    return this.addRef("primitives", t);
  }
  removePrimitive(t) {
    return this.removeRef("primitives", t);
  }
  listPrimitives() {
    return this.listRefs("primitives");
  }
  getWeights() {
    return this.get("weights");
  }
  setWeights(t) {
    return this.set("weights", t);
  }
};
var lt = class extends K {
  constructor(...t) {
    super(...t), this.u = null, this.h = /* @__PURE__ */ new Set();
  }
  init() {
    this.propertyType = h.NODE;
  }
  getDefaults() {
    return Object.assign(super.getDefaults(), { translation: [0, 0, 0], rotation: [0, 0, 0, 1], scale: [1, 1, 1], weights: [], camera: null, mesh: null, skin: null, children: [] });
  }
  copy(t, e = H) {
    if (e === H)
      throw new Error("Node cannot be copied.");
    return super.copy(t, e);
  }
  getTranslation() {
    return this.get("translation");
  }
  getRotation() {
    return this.get("rotation");
  }
  getScale() {
    return this.get("scale");
  }
  setTranslation(t) {
    return this.set("translation", t);
  }
  setRotation(t) {
    return this.set("rotation", t);
  }
  setScale(t) {
    return this.set("scale", t);
  }
  getMatrix() {
    return L.compose(this.get("translation"), this.get("rotation"), this.get("scale"), []);
  }
  setMatrix(t) {
    const e = this.get("translation").slice(), r = this.get("rotation").slice(), s = this.get("scale").slice();
    return L.decompose(t, e, r, s), this.set("translation", e).set("rotation", r).set("scale", s);
  }
  getWorldTranslation() {
    const t = [0, 0, 0];
    return L.decompose(this.getWorldMatrix(), t, [0, 0, 0, 1], [1, 1, 1]), t;
  }
  getWorldRotation() {
    const t = [0, 0, 0, 1];
    return L.decompose(this.getWorldMatrix(), [0, 0, 0], t, [1, 1, 1]), t;
  }
  getWorldScale() {
    const t = [1, 1, 1];
    return L.decompose(this.getWorldMatrix(), [0, 0, 0], [0, 0, 0, 1], t), t;
  }
  getWorldMatrix() {
    const t = [];
    for (let e2 = this; null != e2; e2 = e2.u)
      t.push(e2);
    let e;
    const r = t.pop().getMatrix();
    for (; e = t.pop(); )
      P(r, r, e.getMatrix());
    return r;
  }
  addChild(t) {
    if (t.u && t.u.removeChild(t), t.h.size)
      for (const e of t.h)
        e.removeChild(t);
    this.addRef("children", t), t.u = this;
    const r = this[$attributes].children;
    return r[r.length - 1].addEventListener("dispose", () => t.u = null), this;
  }
  removeChild(t) {
    return this.removeRef("children", t);
  }
  listChildren() {
    return this.listRefs("children");
  }
  getParent() {
    return this.u ? this.u : this.listParents().find((t) => t.propertyType === h.SCENE) || null;
  }
  getParentNode() {
    return this.u;
  }
  getMesh() {
    return this.getRef("mesh");
  }
  setMesh(t) {
    return this.setRef("mesh", t);
  }
  getCamera() {
    return this.getRef("camera");
  }
  setCamera(t) {
    return this.setRef("camera", t);
  }
  getSkin() {
    return this.getRef("skin");
  }
  setSkin(t) {
    return this.setRef("skin", t);
  }
  getWeights() {
    return this.get("weights");
  }
  setWeights(t) {
    return this.set("weights", t);
  }
  traverse(t) {
    t(this);
    for (const e of this.listChildren())
      e.traverse(t);
    return this;
  }
};
var dt = class extends K {
  init() {
    this.propertyType = h.PRIMITIVE;
  }
  getDefaults() {
    return Object.assign(super.getDefaults(), { mode: dt.Mode.TRIANGLES, material: null, indices: null, attributes: {}, targets: [] });
  }
  getIndices() {
    return this.getRef("indices");
  }
  setIndices(t) {
    return this.setRef("indices", t, { usage: l.ELEMENT_ARRAY_BUFFER });
  }
  getAttribute(t) {
    return this.getRefMap("attributes", t);
  }
  setAttribute(t, e) {
    return this.setRefMap("attributes", t, e, { usage: l.ARRAY_BUFFER });
  }
  listAttributes() {
    return this.listRefMapValues("attributes");
  }
  listSemantics() {
    return this.listRefMapKeys("attributes");
  }
  getMaterial() {
    return this.getRef("material");
  }
  setMaterial(t) {
    return this.setRef("material", t);
  }
  getMode() {
    return this.get("mode");
  }
  setMode(t) {
    return this.set("mode", t);
  }
  listTargets() {
    return this.listRefs("targets");
  }
  addTarget(t) {
    return this.addRef("targets", t);
  }
  removeTarget(t) {
    return this.removeRef("targets", t);
  }
};
dt.Mode = { POINTS: 0, LINES: 1, LINE_LOOP: 2, LINE_STRIP: 3, TRIANGLES: 4, TRIANGLE_STRIP: 5, TRIANGLE_FAN: 6 };
var gt = class extends Z {
  init() {
    this.propertyType = h.PRIMITIVE_TARGET;
  }
  getDefaults() {
    return Object.assign(super.getDefaults(), { attributes: {} });
  }
  getAttribute(t) {
    return this.getRefMap("attributes", t);
  }
  setAttribute(t, e) {
    return this.setRefMap("attributes", t, e, { usage: l.ARRAY_BUFFER });
  }
  listAttributes() {
    return this.listRefMapValues("attributes");
  }
  listSemantics() {
    return this.listRefMapKeys("attributes");
  }
};
function pt() {
  return pt = Object.assign ? Object.assign.bind() : function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var r = arguments[e];
      for (var s in r)
        Object.prototype.hasOwnProperty.call(r, s) && (t[s] = r[s]);
    }
    return t;
  }, pt.apply(this, arguments);
}
var mt = class extends K {
  init() {
    this.propertyType = h.SCENE;
  }
  getDefaults() {
    return Object.assign(super.getDefaults(), { children: [] });
  }
  copy(t, e = H) {
    if (e === H)
      throw new Error("Scene cannot be copied.");
    return super.copy(t, e);
  }
  addChild(t) {
    t.u && t.u.removeChild(t), this.addRef("children", t), t.h.add(this);
    const r = this[$attributes].children;
    return r[r.length - 1].addEventListener("dispose", () => t.h.delete(this)), this;
  }
  removeChild(t) {
    return this.removeRef("children", t);
  }
  listChildren() {
    return this.listRefs("children");
  }
  traverse(t) {
    for (const e of this.listChildren())
      e.traverse(t);
    return this;
  }
};
var wt = class extends K {
  init() {
    this.propertyType = h.SKIN;
  }
  getDefaults() {
    return Object.assign(super.getDefaults(), { skeleton: null, inverseBindMatrices: null, joints: [] });
  }
  getSkeleton() {
    return this.getRef("skeleton");
  }
  setSkeleton(t) {
    return this.setRef("skeleton", t);
  }
  getInverseBindMatrices() {
    return this.getRef("inverseBindMatrices");
  }
  setInverseBindMatrices(t) {
    return this.setRef("inverseBindMatrices", t, { usage: l.INVERSE_BIND_MATRICES });
  }
  addJoint(t) {
    return this.addRef("joints", t);
  }
  removeJoint(t) {
    return this.removeRef("joints", t);
  }
  listJoints() {
    return this.listRefs("joints");
  }
};
var yt = class extends K {
  init() {
    this.propertyType = h.TEXTURE;
  }
  getDefaults() {
    return Object.assign(super.getDefaults(), { image: null, mimeType: "", uri: "" });
  }
  getMimeType() {
    return this.get("mimeType") || I.extensionToMimeType(N.extension(this.get("uri")));
  }
  setMimeType(t) {
    return this.set("mimeType", t);
  }
  getURI() {
    return this.get("uri");
  }
  setURI(t) {
    this.set("uri", t);
    const e = I.extensionToMimeType(N.extension(t));
    return e && this.set("mimeType", e), this;
  }
  getImage() {
    return this.get("image");
  }
  setImage(t) {
    return this.set("image", E.assertView(t));
  }
  getSize() {
    const t = this.get("image");
    return t ? I.getSize(t, this.getMimeType()) : null;
  }
};
var vt = class extends K {
  init() {
    this.propertyType = h.ROOT;
  }
  getDefaults() {
    return Object.assign(super.getDefaults(), { asset: { generator: `glTF-Transform ${u}`, version: "2.0" }, defaultScene: null, accessors: [], animations: [], buffers: [], cameras: [], materials: [], meshes: [], nodes: [], scenes: [], skins: [], textures: [] });
  }
  constructor(t) {
    super(t), this.l = /* @__PURE__ */ new Set(), t.addEventListener("node:create", (t2) => {
      this.g(t2.target);
    });
  }
  clone() {
    throw new Error("Root cannot be cloned.");
  }
  copy(t, e = H) {
    if (e === H)
      throw new Error("Root cannot be copied.");
    this.set("asset", pt({}, t.get("asset"))), this.setName(t.getName()), this.setExtras(pt({}, t.getExtras())), this.setDefaultScene(t.getDefaultScene() ? e(t.getDefaultScene()) : null);
    for (const r of t.listRefMapKeys("extensions")) {
      const s = t.getExtension(r);
      this.setExtension(r, e(s));
    }
    return this;
  }
  g(t) {
    return t instanceof mt ? this.addRef("scenes", t) : t instanceof lt ? this.addRef("nodes", t) : t instanceof st ? this.addRef("cameras", t) : t instanceof wt ? this.addRef("skins", t) : t instanceof ft ? this.addRef("meshes", t) : t instanceof ht ? this.addRef("materials", t) : t instanceof yt ? this.addRef("textures", t) : t instanceof X ? this.addRef("animations", t) : t instanceof Q ? this.addRef("accessors", t) : t instanceof rt && this.addRef("buffers", t), this;
  }
  getAsset() {
    return this.get("asset");
  }
  listExtensionsUsed() {
    return Array.from(this.l);
  }
  listExtensionsRequired() {
    return this.listExtensionsUsed().filter((t) => t.isRequired());
  }
  p(t) {
    return this.l.add(t), this;
  }
  m(t) {
    return this.l.delete(t), this;
  }
  listScenes() {
    return this.listRefs("scenes");
  }
  setDefaultScene(t) {
    return this.setRef("defaultScene", t);
  }
  getDefaultScene() {
    return this.getRef("defaultScene");
  }
  listNodes() {
    return this.listRefs("nodes");
  }
  listCameras() {
    return this.listRefs("cameras");
  }
  listSkins() {
    return this.listRefs("skins");
  }
  listMeshes() {
    return this.listRefs("meshes");
  }
  listMaterials() {
    return this.listRefs("materials");
  }
  listTextures() {
    return this.listRefs("textures");
  }
  listAnimations() {
    return this.listRefs("animations");
  }
  listAccessors() {
    return this.listRefs("accessors");
  }
  listBuffers() {
    return this.listRefs("buffers");
  }
};
var Tt = class {
  static fromGraph(t) {
    return Tt.v.get(t) || null;
  }
  constructor() {
    this.T = new Graph(), this.S = new vt(this.T), this.M = B.DEFAULT_INSTANCE, Tt.v.set(this.T, this);
  }
  getRoot() {
    return this.S;
  }
  getGraph() {
    return this.T;
  }
  getLogger() {
    return this.M;
  }
  setLogger(t) {
    return this.M = t, this;
  }
  clone() {
    return new Tt().setLogger(this.M).merge(this);
  }
  merge(t) {
    for (const e2 of t.getRoot().listExtensionsUsed()) {
      const t2 = this.createExtension(e2.constructor);
      e2.isRequired() && t2.setRequired(true);
    }
    const e = /* @__PURE__ */ new Set(), r = /* @__PURE__ */ new Map();
    e.add(t.S), r.set(t.S, this.S);
    for (const s2 of t.T.listEdges())
      for (const t2 of [s2.getParent(), s2.getChild()]) {
        if (e.has(t2))
          continue;
        let s3;
        s3 = t2.propertyType === h.TEXTURE_INFO ? t2 : new (0, t2.constructor)(this.T), r.set(t2, s3), e.add(t2);
      }
    const s = (t2) => {
      const e2 = r.get(t2);
      if (!e2)
        throw new Error("Could resolve property.");
      return e2;
    };
    for (const t2 of e) {
      const e2 = r.get(t2);
      if (!e2)
        throw new Error("Could resolve property.");
      e2.propertyType !== h.TEXTURE_INFO && e2.copy(t2, s);
    }
    return this;
  }
  async transform(...t) {
    const e = t.map((t2) => t2.name);
    for (const r of t)
      await r(this, { stack: e });
    return this;
  }
  createExtension(t) {
    const e = t.EXTENSION_NAME;
    return this.getRoot().listExtensionsUsed().find((t2) => t2.extensionName === e) || new t(this);
  }
  createScene(t = "") {
    return new mt(this.T, t);
  }
  createNode(t = "") {
    return new lt(this.T, t);
  }
  createCamera(t = "") {
    return new st(this.T, t);
  }
  createSkin(t = "") {
    return new wt(this.T, t);
  }
  createMesh(t = "") {
    return new ft(this.T, t);
  }
  createPrimitive() {
    return new dt(this.T);
  }
  createPrimitiveTarget(t = "") {
    return new gt(this.T, t);
  }
  createMaterial(t = "") {
    return new ht(this.T, t);
  }
  createTexture(t = "") {
    return new yt(this.T, t);
  }
  createAnimation(t = "") {
    return new X(this.T, t);
  }
  createAnimationChannel(t = "") {
    return new tt(this.T, t);
  }
  createAnimationSampler(t = "") {
    return new et(this.T, t);
  }
  createAccessor(t = "", e = null) {
    return e || (e = this.getRoot().listBuffers()[0]), new Q(this.T, t).setBuffer(e);
  }
  createBuffer(t = "") {
    return new rt(this.T, t);
  }
};
Tt.v = /* @__PURE__ */ new WeakMap();
var bt = class {
  constructor(t) {
    this.extensionName = "", this.prereadTypes = [], this.prewriteTypes = [], this.readDependencies = [], this.writeDependencies = [], this.document = void 0, this.required = false, this.properties = /* @__PURE__ */ new Set(), this.I = void 0, this.document = t, t.getRoot().p(this), this.I = (t2) => {
      const e2 = t2, r = e2.target;
      r instanceof nt && r.extensionName === this.extensionName && ("node:create" === e2.type && this.N(r), "node:dispose" === e2.type && this.O(r));
    };
    const e = t.getGraph();
    e.addEventListener("node:create", this.I), e.addEventListener("node:dispose", this.I);
  }
  dispose() {
    this.document.getRoot().m(this);
    const t = this.document.getGraph();
    t.removeEventListener("node:create", this.I), t.removeEventListener("node:dispose", this.I);
    for (const t2 of this.properties)
      t2.dispose();
  }
  static register() {
  }
  isRequired() {
    return this.required;
  }
  setRequired(t) {
    return this.required = t, this;
  }
  listProperties() {
    return Array.from(this.properties);
  }
  N(t) {
    return this.properties.add(t), this;
  }
  O(t) {
    return this.properties.delete(t), this;
  }
  install(t, e) {
    return this;
  }
  preread(t, e) {
    return this;
  }
  prewrite(t, e) {
    return this;
  }
};
bt.EXTENSION_NAME = void 0;
var xt = class {
  constructor(t) {
    this.jsonDoc = void 0, this.buffers = [], this.bufferViews = [], this.bufferViewBuffers = [], this.accessors = [], this.textures = [], this.textureInfos = /* @__PURE__ */ new Map(), this.materials = [], this.meshes = [], this.cameras = [], this.nodes = [], this.skins = [], this.animations = [], this.scenes = [], this.jsonDoc = t;
  }
  setTextureInfo(t, e) {
    this.textureInfos.set(t, e), void 0 !== e.texCoord && t.setTexCoord(e.texCoord), void 0 !== e.extras && t.setExtras(e.extras);
    const r = this.jsonDoc.json.textures[e.index];
    if (void 0 === r.sampler)
      return;
    const s = this.jsonDoc.json.samplers[r.sampler];
    void 0 !== s.magFilter && t.setMagFilter(s.magFilter), void 0 !== s.minFilter && t.setMinFilter(s.minFilter), void 0 !== s.wrapS && t.setWrapS(s.wrapS), void 0 !== s.wrapT && t.setWrapT(s.wrapT);
  }
};
var At = { logger: B.DEFAULT_INSTANCE, extensions: [], dependencies: {} };
var Et = class {
  static read(t, e = At) {
    const r = pt({}, At, e), { json: s } = t, n = new Tt().setLogger(r.logger);
    this.validate(t, r);
    const i = new xt(t), o = s.asset, a = n.getRoot().getAsset();
    o.copyright && (a.copyright = o.copyright), o.extras && (a.extras = o.extras), void 0 !== s.extras && n.getRoot().setExtras(pt({}, s.extras));
    const u2 = s.extensionsUsed || [], f2 = s.extensionsRequired || [];
    for (const t2 of r.extensions)
      if (u2.includes(t2.EXTENSION_NAME)) {
        const e2 = n.createExtension(t2).setRequired(f2.includes(t2.EXTENSION_NAME));
        for (const t3 of e2.readDependencies)
          e2.install(t3, r.dependencies[t3]);
      }
    const l2 = s.buffers || [];
    n.getRoot().listExtensionsUsed().filter((t2) => t2.prereadTypes.includes(h.BUFFER)).forEach((t2) => t2.preread(i, h.BUFFER)), i.buffers = l2.map((t2) => {
      const e2 = n.createBuffer(t2.name);
      return t2.extras && e2.setExtras(t2.extras), t2.uri && 0 !== t2.uri.indexOf("__") && e2.setURI(t2.uri), e2;
    }), i.bufferViewBuffers = (s.bufferViews || []).map((e2, r2) => {
      if (!i.bufferViews[r2]) {
        const s2 = t.json.buffers[e2.buffer];
        i.bufferViews[r2] = E.toView(s2.uri ? t.resources[s2.uri] : t.resources[c], e2.byteOffset || 0, e2.byteLength);
      }
      return i.buffers[e2.buffer];
    });
    const d2 = s.accessors || [];
    i.accessors = d2.map((t2) => {
      const e2 = n.createAccessor(t2.name, i.bufferViewBuffers[t2.bufferView]).setType(t2.type);
      return t2.extras && e2.setExtras(t2.extras), void 0 !== t2.normalized && e2.setNormalized(t2.normalized), void 0 === t2.bufferView || e2.setArray(St(t2, i)), e2;
    });
    const g2 = s.images || [], m2 = s.textures || [];
    n.getRoot().listExtensionsUsed().filter((t2) => t2.prereadTypes.includes(h.TEXTURE)).forEach((t2) => t2.preread(i, h.TEXTURE)), i.textures = g2.map((e2) => {
      const r2 = n.createTexture(e2.name);
      if (e2.extras && r2.setExtras(e2.extras), void 0 !== e2.bufferView) {
        const n2 = s.bufferViews[e2.bufferView], i2 = t.json.buffers[n2.buffer], o2 = n2.byteOffset || 0, a2 = (i2.uri ? t.resources[i2.uri] : t.resources[c]).slice(o2, o2 + n2.byteLength);
        r2.setImage(a2);
      } else
        void 0 !== e2.uri && (r2.setImage(t.resources[e2.uri]), 0 !== e2.uri.indexOf("__") && r2.setURI(e2.uri));
      if (void 0 !== e2.mimeType)
        r2.setMimeType(e2.mimeType);
      else if (e2.uri) {
        const t2 = N.extension(e2.uri);
        r2.setMimeType(I.extensionToMimeType(t2));
      }
      return r2;
    }), i.materials = (s.materials || []).map((t2) => {
      const e2 = n.createMaterial(t2.name);
      t2.extras && e2.setExtras(t2.extras), void 0 !== t2.alphaMode && e2.setAlphaMode(t2.alphaMode), void 0 !== t2.alphaCutoff && e2.setAlphaCutoff(t2.alphaCutoff), void 0 !== t2.doubleSided && e2.setDoubleSided(t2.doubleSided);
      const r2 = t2.pbrMetallicRoughness || {};
      if (void 0 !== r2.baseColorFactor && e2.setBaseColorFactor(r2.baseColorFactor), void 0 !== t2.emissiveFactor && e2.setEmissiveFactor(t2.emissiveFactor), void 0 !== r2.metallicFactor && e2.setMetallicFactor(r2.metallicFactor), void 0 !== r2.roughnessFactor && e2.setRoughnessFactor(r2.roughnessFactor), void 0 !== r2.baseColorTexture) {
        const t3 = r2.baseColorTexture;
        e2.setBaseColorTexture(i.textures[m2[t3.index].source]), i.setTextureInfo(e2.getBaseColorTextureInfo(), t3);
      }
      if (void 0 !== t2.emissiveTexture) {
        const r3 = t2.emissiveTexture;
        e2.setEmissiveTexture(i.textures[m2[r3.index].source]), i.setTextureInfo(e2.getEmissiveTextureInfo(), r3);
      }
      if (void 0 !== t2.normalTexture) {
        const r3 = t2.normalTexture;
        e2.setNormalTexture(i.textures[m2[r3.index].source]), i.setTextureInfo(e2.getNormalTextureInfo(), r3), void 0 !== t2.normalTexture.scale && e2.setNormalScale(t2.normalTexture.scale);
      }
      if (void 0 !== t2.occlusionTexture) {
        const r3 = t2.occlusionTexture;
        e2.setOcclusionTexture(i.textures[m2[r3.index].source]), i.setTextureInfo(e2.getOcclusionTextureInfo(), r3), void 0 !== t2.occlusionTexture.strength && e2.setOcclusionStrength(t2.occlusionTexture.strength);
      }
      if (void 0 !== r2.metallicRoughnessTexture) {
        const t3 = r2.metallicRoughnessTexture;
        e2.setMetallicRoughnessTexture(i.textures[m2[t3.index].source]), i.setTextureInfo(e2.getMetallicRoughnessTextureInfo(), t3);
      }
      return e2;
    });
    const w2 = s.meshes || [];
    n.getRoot().listExtensionsUsed().filter((t2) => t2.prereadTypes.includes(h.PRIMITIVE)).forEach((t2) => t2.preread(i, h.PRIMITIVE)), i.meshes = w2.map((t2) => {
      const e2 = n.createMesh(t2.name);
      return t2.extras && e2.setExtras(t2.extras), void 0 !== t2.weights && e2.setWeights(t2.weights), (t2.primitives || []).forEach((r2) => {
        const s2 = n.createPrimitive();
        r2.extras && s2.setExtras(r2.extras), void 0 !== r2.material && s2.setMaterial(i.materials[r2.material]), void 0 !== r2.mode && s2.setMode(r2.mode);
        for (const [t3, e3] of Object.entries(r2.attributes || {}))
          s2.setAttribute(t3, i.accessors[e3]);
        void 0 !== r2.indices && s2.setIndices(i.accessors[r2.indices]);
        const o2 = t2.extras && t2.extras.targetNames || [];
        (r2.targets || []).forEach((t3, e3) => {
          const r3 = o2[e3] || e3.toString(), a2 = n.createPrimitiveTarget(r3);
          for (const [e4, r4] of Object.entries(t3))
            a2.setAttribute(e4, i.accessors[r4]);
          s2.addTarget(a2);
        }), e2.addPrimitive(s2);
      }), e2;
    }), i.cameras = (s.cameras || []).map((t2) => {
      const e2 = n.createCamera(t2.name).setType(t2.type);
      if (t2.extras && e2.setExtras(t2.extras), t2.type === st.Type.PERSPECTIVE) {
        const r2 = t2.perspective;
        e2.setYFov(r2.yfov), e2.setZNear(r2.znear), void 0 !== r2.zfar && e2.setZFar(r2.zfar), void 0 !== r2.aspectRatio && e2.setAspectRatio(r2.aspectRatio);
      } else {
        const r2 = t2.orthographic;
        e2.setZNear(r2.znear).setZFar(r2.zfar).setXMag(r2.xmag).setYMag(r2.ymag);
      }
      return e2;
    });
    const y2 = s.nodes || [];
    n.getRoot().listExtensionsUsed().filter((t2) => t2.prereadTypes.includes(h.NODE)).forEach((t2) => t2.preread(i, h.NODE)), i.nodes = y2.map((t2) => {
      const e2 = n.createNode(t2.name);
      if (t2.extras && e2.setExtras(t2.extras), void 0 !== t2.translation && e2.setTranslation(t2.translation), void 0 !== t2.rotation && e2.setRotation(t2.rotation), void 0 !== t2.scale && e2.setScale(t2.scale), void 0 !== t2.matrix) {
        const r2 = [0, 0, 0], s2 = [0, 0, 0, 1], n2 = [1, 1, 1];
        L.decompose(t2.matrix, r2, s2, n2), e2.setTranslation(r2), e2.setRotation(s2), e2.setScale(n2);
      }
      return void 0 !== t2.weights && e2.setWeights(t2.weights), e2;
    }), i.skins = (s.skins || []).map((t2) => {
      const e2 = n.createSkin(t2.name);
      t2.extras && e2.setExtras(t2.extras), void 0 !== t2.inverseBindMatrices && e2.setInverseBindMatrices(i.accessors[t2.inverseBindMatrices]), void 0 !== t2.skeleton && e2.setSkeleton(i.nodes[t2.skeleton]);
      for (const r2 of t2.joints)
        e2.addJoint(i.nodes[r2]);
      return e2;
    }), y2.map((t2, e2) => {
      const r2 = i.nodes[e2];
      (t2.children || []).forEach((t3) => r2.addChild(i.nodes[t3])), void 0 !== t2.mesh && r2.setMesh(i.meshes[t2.mesh]), void 0 !== t2.camera && r2.setCamera(i.cameras[t2.camera]), void 0 !== t2.skin && r2.setSkin(i.skins[t2.skin]);
    }), i.animations = (s.animations || []).map((t2) => {
      const e2 = n.createAnimation(t2.name);
      t2.extras && e2.setExtras(t2.extras);
      const r2 = (t2.samplers || []).map((t3) => {
        const r3 = n.createAnimationSampler().setInput(i.accessors[t3.input]).setOutput(i.accessors[t3.output]).setInterpolation(t3.interpolation || et.Interpolation.LINEAR);
        return t3.extras && r3.setExtras(t3.extras), e2.addSampler(r3), r3;
      });
      return (t2.channels || []).forEach((t3) => {
        const s2 = n.createAnimationChannel().setSampler(r2[t3.sampler]).setTargetPath(t3.target.path);
        void 0 !== t3.target.node && s2.setTargetNode(i.nodes[t3.target.node]), t3.extras && s2.setExtras(t3.extras), e2.addChannel(s2);
      }), e2;
    });
    const v = s.scenes || [];
    return n.getRoot().listExtensionsUsed().filter((t2) => t2.prereadTypes.includes(h.SCENE)).forEach((t2) => t2.preread(i, h.SCENE)), i.scenes = v.map((t2) => {
      const e2 = n.createScene(t2.name);
      return t2.extras && e2.setExtras(t2.extras), (t2.nodes || []).map((t3) => i.nodes[t3]).forEach((t3) => e2.addChild(t3)), e2;
    }), void 0 !== s.scene && n.getRoot().setDefaultScene(i.scenes[s.scene]), n.getRoot().listExtensionsUsed().forEach((t2) => t2.read(i)), d2.forEach((t2, e2) => {
      const r2 = i.accessors[e2], s2 = !!t2.sparse, n2 = !t2.bufferView && !r2.getArray();
      (s2 || n2) && r2.setSparse(true).setArray(function(t3, e3) {
        const r3 = p[t3.componentType], s3 = Q.getElementSize(t3.type);
        let n3;
        n3 = void 0 !== t3.bufferView ? St(t3, e3) : new r3(t3.count * s3);
        const i2 = t3.sparse;
        if (!i2)
          return n3;
        const o2 = i2.count, a2 = pt({}, t3, i2.indices, { count: o2, type: "SCALAR" }), u3 = pt({}, t3, i2.values, { count: o2 }), c2 = St(a2, e3), h2 = St(u3, e3);
        for (let t4 = 0; t4 < a2.count; t4++)
          for (let e4 = 0; e4 < s3; e4++)
            n3[c2[t4] * s3 + e4] = h2[t4 * s3 + e4];
        return n3;
      }(t2, i));
    }), n;
  }
  static validate(t, e) {
    const r = t.json;
    if ("2.0" !== r.asset.version)
      throw new Error(`Unsupported glTF version, "${r.asset.version}".`);
    if (r.extensionsRequired) {
      for (const t2 of r.extensionsRequired)
        if (!e.extensions.find((e2) => e2.EXTENSION_NAME === t2))
          throw new Error(`Missing required extension, "${t2}".`);
    }
    if (r.extensionsUsed)
      for (const t2 of r.extensionsUsed)
        e.extensions.find((e2) => e2.EXTENSION_NAME === t2) || e.logger.warn(`Missing optional extension, "${t2}".`);
  }
};
function St(t, e) {
  const r = e.bufferViews[t.bufferView], s = e.jsonDoc.json.bufferViews[t.bufferView], n = p[t.componentType], i = Q.getElementSize(t.type), o = n.BYTES_PER_ELEMENT;
  if (void 0 !== s.byteStride && s.byteStride !== i * o)
    return function(t2, e2) {
      const r2 = e2.bufferViews[t2.bufferView], s2 = e2.jsonDoc.json.bufferViews[t2.bufferView], n2 = p[t2.componentType], i2 = Q.getElementSize(t2.type), o2 = n2.BYTES_PER_ELEMENT, a2 = t2.byteOffset || 0, u2 = new n2(t2.count * i2), c2 = new DataView(r2.buffer, r2.byteOffset, r2.byteLength), h2 = s2.byteStride;
      for (let e3 = 0; e3 < t2.count; e3++)
        for (let r3 = 0; r3 < i2; r3++) {
          const s3 = a2 + e3 * h2 + r3 * o2;
          let n3;
          switch (t2.componentType) {
            case Q.ComponentType.FLOAT:
              n3 = c2.getFloat32(s3, true);
              break;
            case Q.ComponentType.UNSIGNED_INT:
              n3 = c2.getUint32(s3, true);
              break;
            case Q.ComponentType.UNSIGNED_SHORT:
              n3 = c2.getUint16(s3, true);
              break;
            case Q.ComponentType.UNSIGNED_BYTE:
              n3 = c2.getUint8(s3);
              break;
            case Q.ComponentType.SHORT:
              n3 = c2.getInt16(s3, true);
              break;
            case Q.ComponentType.BYTE:
              n3 = c2.getInt8(s3);
              break;
            default:
              throw new Error(`Unexpected componentType "${t2.componentType}".`);
          }
          u2[e3 * i2 + r3] = n3;
        }
      return u2;
    }(t, e);
  const a = r.byteOffset + (t.byteOffset || 0);
  return new n(r.buffer.slice(a, a + t.count * i * o));
}
var Mt;
!function(t) {
  t[t.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER", t[t.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER";
}(Mt || (Mt = {}));
var It = class {
  constructor(t, e, r) {
    this.C = void 0, this.jsonDoc = void 0, this.options = void 0, this.accessorIndexMap = /* @__PURE__ */ new Map(), this.animationIndexMap = /* @__PURE__ */ new Map(), this.bufferIndexMap = /* @__PURE__ */ new Map(), this.cameraIndexMap = /* @__PURE__ */ new Map(), this.skinIndexMap = /* @__PURE__ */ new Map(), this.materialIndexMap = /* @__PURE__ */ new Map(), this.meshIndexMap = /* @__PURE__ */ new Map(), this.nodeIndexMap = /* @__PURE__ */ new Map(), this.imageIndexMap = /* @__PURE__ */ new Map(), this.textureDefIndexMap = /* @__PURE__ */ new Map(), this.textureInfoDefMap = /* @__PURE__ */ new Map(), this.samplerDefIndexMap = /* @__PURE__ */ new Map(), this.sceneIndexMap = /* @__PURE__ */ new Map(), this.imageBufferViews = [], this.otherBufferViews = /* @__PURE__ */ new Map(), this.otherBufferViewsIndexMap = /* @__PURE__ */ new Map(), this.extensionData = {}, this.bufferURIGenerator = void 0, this.imageURIGenerator = void 0, this.logger = void 0, this.F = /* @__PURE__ */ new Map(), this.accessorUsageGroupedByParent = /* @__PURE__ */ new Set(["ARRAY_BUFFER"]), this.accessorParents = /* @__PURE__ */ new Map(), this.C = t, this.jsonDoc = e, this.options = r;
    const s = t.getRoot(), n = s.listBuffers().length, i = s.listTextures().length;
    this.bufferURIGenerator = new Rt(n > 1, () => r.basename || "buffer"), this.imageURIGenerator = new Rt(i > 1, (e2) => function(t2, e3) {
      const r2 = t2.getGraph().listParentEdges(e3).find((e4) => e4.getParent() !== t2.getRoot());
      return r2 ? r2.getName().replace(/texture$/i, "") : "";
    }(t, e2) || r.basename || "texture"), this.logger = t.getLogger();
  }
  createTextureInfoDef(t, e) {
    const r = { magFilter: e.getMagFilter() || void 0, minFilter: e.getMinFilter() || void 0, wrapS: e.getWrapS(), wrapT: e.getWrapT() }, s = JSON.stringify(r);
    this.samplerDefIndexMap.has(s) || (this.samplerDefIndexMap.set(s, this.jsonDoc.json.samplers.length), this.jsonDoc.json.samplers.push(r));
    const n = { source: this.imageIndexMap.get(t), sampler: this.samplerDefIndexMap.get(s) }, i = JSON.stringify(n);
    this.textureDefIndexMap.has(i) || (this.textureDefIndexMap.set(i, this.jsonDoc.json.textures.length), this.jsonDoc.json.textures.push(n));
    const o = { index: this.textureDefIndexMap.get(i) };
    return 0 !== e.getTexCoord() && (o.texCoord = e.getTexCoord()), Object.keys(e.getExtras()).length > 0 && (o.extras = e.getExtras()), this.textureInfoDefMap.set(e, o), o;
  }
  createPropertyDef(t) {
    const e = {};
    return t.getName() && (e.name = t.getName()), Object.keys(t.getExtras()).length > 0 && (e.extras = t.getExtras()), e;
  }
  createAccessorDef(t) {
    const e = this.createPropertyDef(t);
    return e.type = t.getType(), e.componentType = t.getComponentType(), e.count = t.getCount(), this.C.getGraph().listParentEdges(t).some((t2) => "attributes" === t2.getName() && "POSITION" === t2.getAttributes().key || "input" === t2.getName()) && (e.max = t.getMax([]).map(Math.fround), e.min = t.getMin([]).map(Math.fround)), t.getNormalized() && (e.normalized = t.getNormalized()), e;
  }
  createImageData(t, e, r) {
    if (this.options.format === g.GLB)
      this.imageBufferViews.push(e), t.bufferView = this.jsonDoc.json.bufferViews.length, this.jsonDoc.json.bufferViews.push({ buffer: 0, byteOffset: -1, byteLength: e.byteLength });
    else {
      const s = I.mimeTypeToExtension(r.getMimeType());
      t.uri = this.imageURIGenerator.createURI(r, s), this.jsonDoc.resources[t.uri] = e;
    }
  }
  getAccessorUsage(t) {
    const e = this.F.get(t);
    if (e)
      return e;
    if (t.getSparse())
      return l.SPARSE;
    for (const e2 of this.C.getGraph().listParentEdges(t)) {
      const { usage: t2 } = e2.getAttributes();
      if (t2)
        return t2;
      e2.getParent().propertyType !== h.ROOT && this.logger.warn(`Missing attribute ".usage" on edge, "${e2.getName()}".`);
    }
    return l.OTHER;
  }
  addAccessorToUsageGroup(t, e) {
    const r = this.F.get(t);
    if (r && r !== e)
      throw new Error(`Accessor with usage "${r}" cannot be reused as "${e}".`);
    return this.F.set(t, e), this;
  }
  listAccessorUsageGroups() {
    const t = {};
    for (const [e, r] of Array.from(this.F.entries()))
      t[r] = t[r] || [], t[r].push(e);
    return t;
  }
};
It.BufferViewTarget = Mt, It.BufferViewUsage = l, It.USAGE_TO_TARGET = { [l.ARRAY_BUFFER]: Mt.ARRAY_BUFFER, [l.ELEMENT_ARRAY_BUFFER]: Mt.ELEMENT_ARRAY_BUFFER };
var Rt = class {
  constructor(t, e) {
    this.multiple = void 0, this.basename = void 0, this.counter = {}, this.multiple = t, this.basename = e;
  }
  createURI(t, e) {
    if (t.getURI())
      return t.getURI();
    if (this.multiple) {
      const r = this.basename(t);
      return this.counter[r] = this.counter[r] || 1, `${r}_${this.counter[r]++}.${e}`;
    }
    return `${this.basename(t)}.${e}`;
  }
};
var { BufferViewUsage: Nt } = It;
var { UNSIGNED_INT: Ot, UNSIGNED_SHORT: Ct, UNSIGNED_BYTE: Ft } = Q.ComponentType;
var Ut = class {
  static write(t, e) {
    const r = t.getRoot(), s = { asset: pt({ generator: `glTF-Transform ${u}` }, r.getAsset()), extras: pt({}, r.getExtras()) }, n = { json: s, resources: {} }, i = new It(t, n, e), o = e.logger || B.DEFAULT_INSTANCE, a = new Set(e.extensions.map((t2) => t2.EXTENSION_NAME)), l2 = t.getRoot().listExtensionsUsed().filter((t2) => a.has(t2.extensionName)), d2 = t.getRoot().listExtensionsRequired().filter((t2) => a.has(t2.extensionName));
    l2.length < t.getRoot().listExtensionsUsed().length && o.warn("Some extensions were not registered for I/O, and will not be written.");
    for (const t2 of l2)
      for (const r2 of t2.writeDependencies)
        t2.install(r2, e.dependencies[r2]);
    function m2(t2, e2, r2, n2) {
      const o2 = [];
      let a2 = 0;
      for (const e3 of t2) {
        const t3 = i.createAccessorDef(e3);
        t3.bufferView = s.bufferViews.length;
        const r3 = e3.getArray(), n3 = E.pad(E.toView(r3));
        t3.byteOffset = a2, a2 += n3.byteLength, o2.push(n3), i.accessorIndexMap.set(e3, s.accessors.length), s.accessors.push(t3);
      }
      const u2 = { buffer: e2, byteOffset: r2, byteLength: E.concat(o2).byteLength };
      return n2 && (u2.target = n2), s.bufferViews.push(u2), { buffers: o2, byteLength: a2 };
    }
    function w2(t2, e2, r2) {
      const n2 = t2[0].getCount();
      let o2 = 0;
      for (const e3 of t2) {
        const t3 = i.createAccessorDef(e3);
        t3.bufferView = s.bufferViews.length, t3.byteOffset = o2;
        const r3 = e3.getElementSize(), n3 = e3.getComponentSize();
        o2 += E.padNumber(r3 * n3), i.accessorIndexMap.set(e3, s.accessors.length), s.accessors.push(t3);
      }
      const a2 = n2 * o2, u2 = new ArrayBuffer(a2), c2 = new DataView(u2);
      for (let e3 = 0; e3 < n2; e3++) {
        let r3 = 0;
        for (const s2 of t2) {
          const t3 = s2.getElementSize(), n3 = s2.getComponentSize(), i2 = s2.getComponentType(), a3 = s2.getArray();
          for (let s3 = 0; s3 < t3; s3++) {
            const u3 = e3 * o2 + r3 + s3 * n3, h2 = a3[e3 * t3 + s3];
            switch (i2) {
              case Q.ComponentType.FLOAT:
                c2.setFloat32(u3, h2, true);
                break;
              case Q.ComponentType.BYTE:
                c2.setInt8(u3, h2);
                break;
              case Q.ComponentType.SHORT:
                c2.setInt16(u3, h2, true);
                break;
              case Q.ComponentType.UNSIGNED_BYTE:
                c2.setUint8(u3, h2);
                break;
              case Q.ComponentType.UNSIGNED_SHORT:
                c2.setUint16(u3, h2, true);
                break;
              case Q.ComponentType.UNSIGNED_INT:
                c2.setUint32(u3, h2, true);
                break;
              default:
                throw new Error("Unexpected component type: " + i2);
            }
          }
          r3 += E.padNumber(t3 * n3);
        }
      }
      return s.bufferViews.push({ buffer: e2, byteOffset: r2, byteLength: a2, byteStride: o2, target: It.BufferViewTarget.ARRAY_BUFFER }), { byteLength: a2, buffers: [new Uint8Array(u2)] };
    }
    function y2(t2, e2, r2) {
      const n2 = [];
      let a2 = 0;
      const u2 = /* @__PURE__ */ new Map();
      let c2 = -Infinity;
      for (const e3 of t2) {
        const t3 = i.createAccessorDef(e3);
        s.accessors.push(t3), i.accessorIndexMap.set(e3, s.accessors.length - 1);
        const r3 = [], n3 = [], a3 = [], h3 = new Array(e3.getElementSize()).fill(0);
        for (let t4 = 0, s2 = e3.getCount(); t4 < s2; t4++)
          if (e3.getElement(t4, a3), !L.eq(a3, h3, 0)) {
            c2 = Math.max(t4, c2), r3.push(t4);
            for (let t5 = 0; t5 < a3.length; t5++)
              n3.push(a3[t5]);
          }
        const f3 = r3.length, l4 = { accessorDef: t3, count: f3 };
        if (u2.set(e3, l4), 0 === f3)
          continue;
        if (f3 > e3.getCount() / 3) {
          const t4 = (100 * r3.length / e3.getCount()).toFixed(1);
          o.warn(`Sparse accessor with many non-zero elements (${t4}%) may increase file size.`);
        }
        const d4 = p[e3.getComponentType()];
        l4.indices = r3, l4.values = new d4(n3);
      }
      if (!Number.isFinite(c2))
        return { buffers: n2, byteLength: a2 };
      const h2 = c2 < 255 ? Uint8Array : c2 < 65535 ? Uint16Array : Uint32Array, f2 = c2 < 255 ? Ft : c2 < 65535 ? Ct : Ot, l3 = { buffer: e2, byteOffset: r2 + a2, byteLength: 0 };
      for (const e3 of t2) {
        const t3 = u2.get(e3);
        if (0 === t3.count)
          continue;
        t3.indicesByteOffset = l3.byteLength;
        const r3 = E.pad(E.toView(new h2(t3.indices)));
        n2.push(r3), a2 += r3.byteLength, l3.byteLength += r3.byteLength;
      }
      s.bufferViews.push(l3);
      const d3 = s.bufferViews.length - 1, g2 = { buffer: e2, byteOffset: r2 + a2, byteLength: 0 };
      for (const e3 of t2) {
        const t3 = u2.get(e3);
        if (0 === t3.count)
          continue;
        t3.valuesByteOffset = g2.byteLength;
        const r3 = E.pad(E.toView(t3.values));
        n2.push(r3), a2 += r3.byteLength, g2.byteLength += r3.byteLength;
      }
      s.bufferViews.push(g2);
      const m3 = s.bufferViews.length - 1;
      for (const e3 of t2) {
        const t3 = u2.get(e3);
        0 !== t3.count && (t3.accessorDef.sparse = { count: t3.count, indices: { bufferView: d3, byteOffset: t3.indicesByteOffset, componentType: f2 }, values: { bufferView: m3, byteOffset: t3.valuesByteOffset } });
      }
      return { buffers: n2, byteLength: a2 };
    }
    const v = /* @__PURE__ */ new Map();
    for (const e2 of t.getGraph().listEdges()) {
      if (e2.getParent() === r)
        continue;
      const t2 = e2.getChild();
      if (t2 instanceof Q) {
        const r2 = v.get(t2) || [];
        r2.push(e2), v.set(t2, r2);
      }
    }
    if (s.accessors = [], s.bufferViews = [], s.samplers = [], s.textures = [], s.images = r.listTextures().map((t2, e2) => {
      const r2 = i.createPropertyDef(t2);
      t2.getMimeType() && (r2.mimeType = t2.getMimeType());
      const s2 = t2.getImage();
      return s2 && i.createImageData(r2, s2, t2), i.imageIndexMap.set(t2, e2), r2;
    }), l2.filter((t2) => t2.prewriteTypes.includes(h.ACCESSOR)).forEach((t2) => t2.prewrite(i, h.ACCESSOR)), r.listAccessors().forEach((t2) => {
      const e2 = i.accessorUsageGroupedByParent, r2 = i.accessorParents;
      if (i.accessorIndexMap.has(t2))
        return;
      const s2 = v.get(t2) || [], n2 = i.getAccessorUsage(t2);
      if (i.addAccessorToUsageGroup(t2, n2), e2.has(n2)) {
        const e3 = s2[0].getParent(), n3 = r2.get(e3) || /* @__PURE__ */ new Set();
        n3.add(t2), r2.set(e3, n3);
      }
    }), l2.filter((t2) => t2.prewriteTypes.includes(h.BUFFER)).forEach((t2) => t2.prewrite(i, h.BUFFER)), (r.listAccessors().length > 0 || r.listTextures().length > 0 || i.otherBufferViews.size > 0) && 0 === r.listBuffers().length)
      throw new Error("Buffer required for Document resources, but none was found.");
    s.buffers = [], r.listBuffers().forEach((t2, r2) => {
      const o2 = i.createPropertyDef(t2), a2 = i.accessorUsageGroupedByParent, u2 = i.accessorParents, h2 = t2.listParents().filter((t3) => t3 instanceof Q), l3 = new Set(h2), d3 = [], p2 = s.buffers.length;
      let v2 = 0;
      const T2 = i.listAccessorUsageGroups();
      for (const t3 in T2)
        if (a2.has(t3))
          for (const r3 of Array.from(u2.values())) {
            const s2 = Array.from(r3).filter((t4) => l3.has(t4)).filter((e2) => i.getAccessorUsage(e2) === t3);
            if (s2.length)
              if (t3 !== Nt.ARRAY_BUFFER || e.vertexLayout === f.INTERLEAVED) {
                const e2 = t3 === Nt.ARRAY_BUFFER ? w2(s2, p2, v2) : m2(s2, p2, v2);
                v2 += e2.byteLength, d3.push(...e2.buffers);
              } else
                for (const t4 of s2) {
                  const e2 = w2([t4], p2, v2);
                  v2 += e2.byteLength, d3.push(...e2.buffers);
                }
          }
        else {
          const e2 = T2[t3].filter((t4) => l3.has(t4));
          if (!e2.length)
            continue;
          const r3 = t3 === Nt.ELEMENT_ARRAY_BUFFER ? It.BufferViewTarget.ELEMENT_ARRAY_BUFFER : void 0, s2 = t3 === Nt.SPARSE ? y2(e2, p2, v2) : m2(e2, p2, v2, r3);
          v2 += s2.byteLength, d3.push(...s2.buffers);
        }
      if (i.imageBufferViews.length && 0 === r2) {
        for (let t3 = 0; t3 < i.imageBufferViews.length; t3++)
          if (s.bufferViews[s.images[t3].bufferView].byteOffset = v2, v2 += i.imageBufferViews[t3].byteLength, d3.push(i.imageBufferViews[t3]), v2 % 8) {
            const t4 = 8 - v2 % 8;
            v2 += t4, d3.push(new Uint8Array(t4));
          }
      }
      if (i.otherBufferViews.has(t2))
        for (const e2 of i.otherBufferViews.get(t2))
          s.bufferViews.push({ buffer: p2, byteOffset: v2, byteLength: e2.byteLength }), i.otherBufferViewsIndexMap.set(e2, s.bufferViews.length - 1), v2 += e2.byteLength, d3.push(e2);
      if (v2) {
        let r3;
        e.format === g.GLB ? r3 = c : (r3 = i.bufferURIGenerator.createURI(t2, "bin"), o2.uri = r3), o2.byteLength = v2, n.resources[r3] = E.concat(d3);
      }
      s.buffers.push(o2), i.bufferIndexMap.set(t2, r2);
    }), r.listAccessors().find((t2) => !t2.getBuffer()) && o.warn("Skipped writing one or more Accessors: no Buffer assigned."), s.materials = r.listMaterials().map((t2, e2) => {
      const r2 = i.createPropertyDef(t2);
      if (t2.getAlphaMode() !== ht.AlphaMode.OPAQUE && (r2.alphaMode = t2.getAlphaMode()), t2.getAlphaMode() === ht.AlphaMode.MASK && (r2.alphaCutoff = t2.getAlphaCutoff()), t2.getDoubleSided() && (r2.doubleSided = true), r2.pbrMetallicRoughness = {}, L.eq(t2.getBaseColorFactor(), [1, 1, 1, 1]) || (r2.pbrMetallicRoughness.baseColorFactor = t2.getBaseColorFactor()), L.eq(t2.getEmissiveFactor(), [0, 0, 0]) || (r2.emissiveFactor = t2.getEmissiveFactor()), 1 !== t2.getRoughnessFactor() && (r2.pbrMetallicRoughness.roughnessFactor = t2.getRoughnessFactor()), 1 !== t2.getMetallicFactor() && (r2.pbrMetallicRoughness.metallicFactor = t2.getMetallicFactor()), t2.getBaseColorTexture()) {
        const e3 = t2.getBaseColorTexture(), s2 = t2.getBaseColorTextureInfo();
        r2.pbrMetallicRoughness.baseColorTexture = i.createTextureInfoDef(e3, s2);
      }
      if (t2.getEmissiveTexture()) {
        const e3 = t2.getEmissiveTexture(), s2 = t2.getEmissiveTextureInfo();
        r2.emissiveTexture = i.createTextureInfoDef(e3, s2);
      }
      if (t2.getNormalTexture()) {
        const e3 = t2.getNormalTexture(), s2 = t2.getNormalTextureInfo(), n2 = i.createTextureInfoDef(e3, s2);
        1 !== t2.getNormalScale() && (n2.scale = t2.getNormalScale()), r2.normalTexture = n2;
      }
      if (t2.getOcclusionTexture()) {
        const e3 = t2.getOcclusionTexture(), s2 = t2.getOcclusionTextureInfo(), n2 = i.createTextureInfoDef(e3, s2);
        1 !== t2.getOcclusionStrength() && (n2.strength = t2.getOcclusionStrength()), r2.occlusionTexture = n2;
      }
      if (t2.getMetallicRoughnessTexture()) {
        const e3 = t2.getMetallicRoughnessTexture(), s2 = t2.getMetallicRoughnessTextureInfo();
        r2.pbrMetallicRoughness.metallicRoughnessTexture = i.createTextureInfoDef(e3, s2);
      }
      return i.materialIndexMap.set(t2, e2), r2;
    }), s.meshes = r.listMeshes().map((t2, e2) => {
      const r2 = i.createPropertyDef(t2);
      let s2 = null;
      return r2.primitives = t2.listPrimitives().map((t3) => {
        const e3 = { attributes: {} };
        e3.mode = t3.getMode();
        const r3 = t3.getMaterial();
        r3 && (e3.material = i.materialIndexMap.get(r3)), Object.keys(t3.getExtras()).length && (e3.extras = t3.getExtras());
        const n2 = t3.getIndices();
        n2 && (e3.indices = i.accessorIndexMap.get(n2));
        for (const r4 of t3.listSemantics())
          e3.attributes[r4] = i.accessorIndexMap.get(t3.getAttribute(r4));
        for (const r4 of t3.listTargets()) {
          const t4 = {};
          for (const e4 of r4.listSemantics())
            t4[e4] = i.accessorIndexMap.get(r4.getAttribute(e4));
          e3.targets = e3.targets || [], e3.targets.push(t4);
        }
        return t3.listTargets().length && !s2 && (s2 = t3.listTargets().map((t4) => t4.getName())), e3;
      }), t2.getWeights().length && (r2.weights = t2.getWeights()), s2 && (r2.extras = r2.extras || {}, r2.extras.targetNames = s2), i.meshIndexMap.set(t2, e2), r2;
    }), s.cameras = r.listCameras().map((t2, e2) => {
      const r2 = i.createPropertyDef(t2);
      if (r2.type = t2.getType(), r2.type === st.Type.PERSPECTIVE) {
        r2.perspective = { znear: t2.getZNear(), zfar: t2.getZFar(), yfov: t2.getYFov() };
        const e3 = t2.getAspectRatio();
        null !== e3 && (r2.perspective.aspectRatio = e3);
      } else
        r2.orthographic = { znear: t2.getZNear(), zfar: t2.getZFar(), xmag: t2.getXMag(), ymag: t2.getYMag() };
      return i.cameraIndexMap.set(t2, e2), r2;
    }), s.nodes = r.listNodes().map((t2, e2) => {
      const r2 = i.createPropertyDef(t2);
      return L.eq(t2.getTranslation(), [0, 0, 0]) || (r2.translation = t2.getTranslation()), L.eq(t2.getRotation(), [0, 0, 0, 1]) || (r2.rotation = t2.getRotation()), L.eq(t2.getScale(), [1, 1, 1]) || (r2.scale = t2.getScale()), t2.getWeights().length && (r2.weights = t2.getWeights()), i.nodeIndexMap.set(t2, e2), r2;
    }), s.skins = r.listSkins().map((t2, e2) => {
      const r2 = i.createPropertyDef(t2), s2 = t2.getInverseBindMatrices();
      s2 && (r2.inverseBindMatrices = i.accessorIndexMap.get(s2));
      const n2 = t2.getSkeleton();
      return n2 && (r2.skeleton = i.nodeIndexMap.get(n2)), r2.joints = t2.listJoints().map((t3) => i.nodeIndexMap.get(t3)), i.skinIndexMap.set(t2, e2), r2;
    }), r.listNodes().forEach((t2, e2) => {
      const r2 = s.nodes[e2], n2 = t2.getMesh();
      n2 && (r2.mesh = i.meshIndexMap.get(n2));
      const o2 = t2.getCamera();
      o2 && (r2.camera = i.cameraIndexMap.get(o2));
      const a2 = t2.getSkin();
      a2 && (r2.skin = i.skinIndexMap.get(a2)), t2.listChildren().length > 0 && (r2.children = t2.listChildren().map((t3) => i.nodeIndexMap.get(t3)));
    }), s.animations = r.listAnimations().map((t2, e2) => {
      const r2 = i.createPropertyDef(t2), s2 = /* @__PURE__ */ new Map();
      return r2.samplers = t2.listSamplers().map((t3, e3) => {
        const r3 = i.createPropertyDef(t3);
        return r3.input = i.accessorIndexMap.get(t3.getInput()), r3.output = i.accessorIndexMap.get(t3.getOutput()), r3.interpolation = t3.getInterpolation(), s2.set(t3, e3), r3;
      }), r2.channels = t2.listChannels().map((t3) => {
        const e3 = i.createPropertyDef(t3);
        return e3.sampler = s2.get(t3.getSampler()), e3.target = { node: i.nodeIndexMap.get(t3.getTargetNode()), path: t3.getTargetPath() }, e3;
      }), i.animationIndexMap.set(t2, e2), r2;
    }), s.scenes = r.listScenes().map((t2, e2) => {
      const r2 = i.createPropertyDef(t2);
      return r2.nodes = t2.listChildren().map((t3) => i.nodeIndexMap.get(t3)), i.sceneIndexMap.set(t2, e2), r2;
    });
    const T = r.getDefaultScene();
    return T && (s.scene = r.listScenes().indexOf(T)), s.extensionsUsed = l2.map((t2) => t2.extensionName), s.extensionsRequired = d2.map((t2) => t2.extensionName), l2.forEach((t2) => t2.write(i)), function(t2) {
      const e2 = [];
      for (const r2 in t2) {
        const s2 = t2[r2];
        (Array.isArray(s2) && 0 === s2.length || null === s2 || "" === s2 || s2 && "object" == typeof s2 && 0 === Object.keys(s2).length) && e2.push(r2);
      }
      for (const r2 of e2)
        delete t2[r2];
    }(s), n;
  }
};
var Bt;
!function(t) {
  t[t.JSON = 1313821514] = "JSON", t[t.BIN = 5130562] = "BIN";
}(Bt || (Bt = {}));
var Pt = class {
  constructor() {
    this.M = B.DEFAULT_INSTANCE, this.l = /* @__PURE__ */ new Set(), this.U = {}, this.P = f.INTERLEAVED, this.lastReadBytes = 0, this.lastWriteBytes = 0;
  }
  setLogger(t) {
    return this.M = t, this;
  }
  registerExtensions(t) {
    for (const e of t)
      this.l.add(e), e.register();
    return this;
  }
  registerDependencies(t) {
    return Object.assign(this.U, t), this;
  }
  setVertexLayout(t) {
    return this.P = t, this;
  }
  async read(t) {
    return await this.readJSON(await this.readAsJSON(t));
  }
  async readAsJSON(t) {
    const e = await this.readURI(t, "view");
    this.lastReadBytes = e.byteLength;
    const r = Lt(e) ? this.L(e) : { json: JSON.parse(E.decodeText(e)), resources: {} };
    return await this.j(r, this.dirname(t)), this.D(r), r;
  }
  async readJSON(t) {
    return t = this._(t), this.D(t), Et.read(t, { extensions: Array.from(this.l), dependencies: this.U, logger: this.M });
  }
  async binaryToJSON(t) {
    const e = this.L(E.assertView(t));
    this.D(e);
    const r = e.json;
    if (r.buffers && r.buffers.some((t2) => function(t3, e2) {
      return void 0 !== e2.uri && !(e2.uri in t3.resources);
    }(e, t2)))
      throw new Error("Cannot resolve external buffers with binaryToJSON().");
    if (r.images && r.images.some((t2) => function(t3, e2) {
      return void 0 !== e2.uri && !(e2.uri in t3.resources) && void 0 === e2.bufferView;
    }(e, t2)))
      throw new Error("Cannot resolve external images with binaryToJSON().");
    return e;
  }
  async readBinary(t) {
    return this.readJSON(await this.binaryToJSON(E.assertView(t)));
  }
  async writeJSON(t, e = {}) {
    if (e.format === g.GLB && t.getRoot().listBuffers().length > 1)
      throw new Error("GLB must have 0\u20131 buffers.");
    return Ut.write(t, { format: e.format || g.GLTF, basename: e.basename || "", logger: this.M, vertexLayout: this.P, dependencies: pt({}, this.U), extensions: Array.from(this.l) });
  }
  async writeBinary(t) {
    const { json: e, resources: r } = await this.writeJSON(t, { format: g.GLB }), s = new Uint32Array([1179937895, 2, 12]), n = JSON.stringify(e), i = E.pad(E.encodeText(n), 32), o = E.toView(new Uint32Array([i.byteLength, 1313821514])), a = E.concat([o, i]);
    s[s.length - 1] += a.byteLength;
    const u2 = Object.values(r)[0];
    if (!u2 || !u2.byteLength)
      return E.concat([E.toView(s), a]);
    const c2 = E.pad(u2, 0), h2 = E.toView(new Uint32Array([c2.byteLength, 5130562])), f2 = E.concat([h2, c2]);
    return s[s.length - 1] += f2.byteLength, E.concat([E.toView(s), a, f2]);
  }
  async j(t, e) {
    var r = this;
    const s = [...t.json.images || [], ...t.json.buffers || []].map(async function(s2) {
      const n = s2.uri;
      if (!n || n.match(/data:/))
        return Promise.resolve();
      t.resources[n] = await r.readURI(r.resolve(e, n), "view"), r.lastReadBytes += t.resources[n].byteLength;
    });
    await Promise.all(s);
  }
  D(t) {
    function e(e2) {
      if (e2.uri) {
        if (e2.uri in t.resources)
          E.assertView(t.resources[e2.uri]);
        else if (e2.uri.match(/data:/)) {
          const r = `__${V()}.${N.extension(e2.uri)}`;
          t.resources[r] = E.createBufferFromDataURI(e2.uri), e2.uri = r;
        }
      }
    }
    (t.json.images || []).forEach((t2) => {
      if (void 0 === t2.bufferView && void 0 === t2.uri)
        throw new Error("Missing resource URI or buffer view.");
      e(t2);
    }), (t.json.buffers || []).forEach(e);
  }
  _(t) {
    const { images: e, buffers: r } = t.json;
    return t = { json: pt({}, t.json), resources: pt({}, t.resources) }, e && (t.json.images = e.map((t2) => pt({}, t2))), r && (t.json.buffers = r.map((t2) => pt({}, t2))), t;
  }
  L(t) {
    if (!Lt(t))
      throw new Error("Invalid glTF 2.0 binary.");
    const e = new Uint32Array(t.buffer, t.byteOffset + 12, 2);
    if (e[1] !== Bt.JSON)
      throw new Error("Missing required GLB JSON chunk.");
    const r = e[0], s = E.decodeText(E.toView(t, 20, r)), n = JSON.parse(s), i = 20 + r;
    if (t.byteLength <= i)
      return { json: n, resources: {} };
    const o = new Uint32Array(t.buffer, t.byteOffset + i, 2);
    if (o[1] !== Bt.BIN)
      throw new Error("Expected GLB BIN in second chunk.");
    const a = E.toView(t, i + 8, o[0]);
    return { json: n, resources: { [c]: a } };
  }
};
function Lt(t) {
  if (t.byteLength < 3 * Uint32Array.BYTES_PER_ELEMENT)
    return false;
  const e = new Uint32Array(t.buffer, t.byteOffset, 3);
  return 1179937895 === e[0] && 2 === e[1];
}
var _t = class extends Pt {
  constructor(t = q.DEFAULT_INIT) {
    super(), this.J = void 0, this.J = t;
  }
  async readURI(t, e) {
    const r = await fetch(t, this.J);
    switch (e) {
      case "view":
        return new Uint8Array(await r.arrayBuffer());
      case "text":
        return r.text();
    }
  }
  resolve(t, e) {
    return q.resolve(t, e);
  }
  dirname(t) {
    return q.dirname(t);
  }
};

// node_modules/gophergfx/src/loaders/MeshLoader.ts
var MeshLoader = class {
  static loadGLTF(filename, callback = null, recursive = true) {
    GfxApp.getInstance().assetManager.requestedAssets.push(filename);
    const root = new Node3();
    const io = new _t();
    io.read(filename).then((document2) => {
      MeshParser.parseGLTF(document2, root);
      if (callback) {
        callback(root);
      }
      GfxApp.getInstance().assetManager.loadedAssets.push(filename);
    }).catch(() => {
      GfxApp.getInstance().assetManager.errorAssets.push(filename);
      console.error("Unable to fetch GLTF file: " + filename);
    });
    return root;
  }
  static loadOBJ(filename, callback = null) {
    GfxApp.getInstance().assetManager.requestedAssets.push(filename);
    const mesh = new Mesh3();
    fetch(filename).then((response) => {
      if (!response.ok)
        throw new Error();
      return response.blob();
    }).then((data) => {
      data.text().then((text) => {
        MeshParser.parseOBJ(text, mesh);
        if (callback) {
          callback(mesh);
        }
        GfxApp.getInstance().assetManager.loadedAssets.push(filename);
      });
    }).catch(() => {
      GfxApp.getInstance().assetManager.errorAssets.push(filename);
      console.error("Unable to load OBJ file: " + filename);
    });
    return mesh;
  }
  static loadPLY(filename, callback = null) {
    GfxApp.getInstance().assetManager.requestedAssets.push(filename);
    const mesh = new Mesh3();
    fetch(filename).then((response) => {
      if (!response.ok)
        throw new Error();
      return response.blob();
    }).then((data) => {
      data.arrayBuffer().then((buffer) => {
        MeshParser.parsePLY(buffer, mesh);
        if (callback) {
          callback(mesh);
        }
        GfxApp.getInstance().assetManager.loadedAssets.push(filename);
      });
    }).catch(() => {
      GfxApp.getInstance().assetManager.errorAssets.push(filename);
      console.error("Unable to load PLY file: " + filename);
    });
    return mesh;
  }
};

// node_modules/gophergfx/src/loaders/MeshWriter.ts
var MeshWriter = class {
  static saveOBJ(filename, mesh) {
    let output = "# Generated by GopherGfx\n";
    output += "# Vertices: " + mesh.vertexCount + "\n";
    output += "# Faces: " + mesh.triangleCount + "\n";
    output += "\n";
    const vertices = mesh.getVertices();
    const normals = mesh.getNormals();
    const uvs = mesh.getTextureCoordinates();
    const indices = mesh.getIndices();
    if (mesh.hasVertexColors) {
      const colors = mesh.getColors();
      for (let i = 0; i < mesh.vertexCount; i++) {
        output += "v " + vertices[i * 3].toFixed(6) + " " + vertices[i * 3 + 1].toFixed(6) + " " + vertices[i * 3 + 2].toFixed(6) + " " + colors[i * 4].toFixed(6) + " " + colors[i * 4 + 1].toFixed(6) + " " + colors[i * 4 + 2].toFixed(6) + "\n";
        output += "vn " + normals[i * 3].toFixed(6) + " " + normals[i * 3 + 1].toFixed(6) + " " + normals[i * 3 + 2].toFixed(6) + "\n";
        output += "vt " + uvs[i * 2].toFixed(6) + " " + uvs[i * 2 + 1].toFixed(6) + "\n";
      }
    } else {
      for (let i = 0; i < mesh.vertexCount; i++) {
        output += "v " + vertices[i * 3].toFixed(6) + " " + vertices[i * 3 + 1].toFixed(6) + " " + vertices[i * 3 + 2].toFixed(6) + "\n";
        output += "vn " + normals[i * 3].toFixed(6) + " " + normals[i * 3 + 1].toFixed(6) + " " + normals[i * 3 + 2].toFixed(6) + "\n";
        output += "vt " + uvs[i * 2].toFixed(6) + " " + uvs[i * 2 + 1].toFixed(6) + "\n";
      }
    }
    output += "\n";
    for (let i = 0; i < indices.length; i += 3) {
      output += "f " + (indices[i] + 1) + " " + (indices[i + 1] + 1) + " " + (indices[i + 2] + 1) + "\n";
    }
    FileWriter.saveAscii(filename, output);
  }
  static savePLY(filename, mesh, binary = true) {
    const vertices = mesh.getVertices();
    const normals = mesh.getNormals();
    const uvs = mesh.getTextureCoordinates();
    const indices = mesh.getIndices();
    let colors = [];
    if (mesh.hasVertexColors)
      colors = mesh.getColors();
    let header = "ply\n";
    if (binary) {
      header += "format binary_little_endian 1.0\n";
    } else {
      header += "format ascii 1.0\n";
    }
    header += "comment Generated by GopherGfx\n";
    header += "element vertex " + mesh.vertexCount + "\n";
    header += "property float x\n";
    header += "property float y\n";
    header += "property float z\n";
    header += "property float nx\n";
    header += "property float ny\n";
    header += "property float nz\n";
    header += "property float texture_u\n";
    header += "property float texture_v\n";
    if (mesh.hasVertexColors) {
      header += "property uchar red\n";
      header += "property uchar green\n";
      header += "property uchar blue\n";
      header += "property uchar alpha\n";
    }
    header += "element face " + mesh.triangleCount + "\n";
    header += "property list uchar int vertex_indices\n";
    header += "end_header\n";
    if (binary) {
      const encoder = new TextEncoder();
      const headerData = encoder.encode(header);
      const bytesPerVertex = 36;
      const bytesPerFace = 13;
      const buffer = new ArrayBuffer(headerData.length + mesh.vertexCount * bytesPerVertex + mesh.triangleCount * bytesPerFace);
      const output = new Uint8Array(buffer);
      output.set(headerData, 0);
      const view = new DataView(buffer);
      let byteCounter = headerData.length;
      for (let i = 0; i < mesh.vertexCount; i++) {
        view.setFloat32(byteCounter, vertices[i * 3], true);
        byteCounter += 4;
        view.setFloat32(byteCounter, vertices[i * 3 + 1], true);
        byteCounter += 4;
        view.setFloat32(byteCounter, vertices[i * 3 + 2], true);
        byteCounter += 4;
        view.setFloat32(byteCounter, normals[i * 3], true);
        byteCounter += 4;
        view.setFloat32(byteCounter, normals[i * 3 + 1], true);
        byteCounter += 4;
        view.setFloat32(byteCounter, normals[i * 3 + 2], true);
        byteCounter += 4;
        view.setFloat32(byteCounter, uvs[i * 2], true);
        byteCounter += 4;
        view.setFloat32(byteCounter, uvs[i * 2 + 1], true);
        byteCounter += 4;
        if (mesh.hasVertexColors) {
          view.setUint8(byteCounter, Math.floor(colors[i * 4] * 255));
          byteCounter += 1;
          view.setUint8(byteCounter, Math.floor(colors[i * 4 + 1] * 255));
          byteCounter += 1;
          view.setUint8(byteCounter, Math.floor(colors[i * 4 + 2] * 255));
          byteCounter += 1;
          view.setUint8(byteCounter, Math.floor(colors[i * 4 + 3] * 255));
          byteCounter += 1;
        }
      }
      for (let i = 0; i < mesh.triangleCount; i++) {
        view.setUint8(byteCounter, 3);
        byteCounter += 1;
        view.setInt32(byteCounter, indices[i * 3], true);
        byteCounter += 4;
        view.setInt32(byteCounter, indices[i * 3 + 1], true);
        byteCounter += 4;
        view.setInt32(byteCounter, indices[i * 3 + 2], true);
        byteCounter += 4;
      }
      FileWriter.saveBinary(filename, output);
    } else {
      let output = header;
      for (let i = 0; i < mesh.vertexCount; i++) {
        output += vertices[i * 3].toFixed(6) + " " + vertices[i * 3 + 1].toFixed(6) + " " + vertices[i * 3 + 2].toFixed(6);
        output += " " + normals[i * 3].toFixed(6) + " " + normals[i * 3 + 1].toFixed(6) + " " + normals[i * 3 + 2].toFixed(6);
        output += " " + uvs[i * 2].toFixed(6) + " " + uvs[i * 2 + 1].toFixed(6);
        if (mesh.hasVertexColors)
          output += " " + Math.floor(colors[i * 4] * 255) + " " + Math.floor(colors[i * 4 + 1] * 255) + " " + Math.floor(colors[i * 4 + 2] * 255) + " " + Math.floor(colors[i * 4 + 3] * 255);
        output += "\n";
      }
      for (let i = 0; i < indices.length; i += 3) {
        output += "3 " + indices[i] + " " + indices[i + 1] + " " + indices[i + 2] + "\n";
      }
      FileWriter.saveAscii(filename, output);
    }
  }
  static saveGLTF(filename, transform) {
    const doc = MeshWriter.createGLTF(transform);
    MeshWriter.writeJSON(filename, doc);
  }
  static saveGLB(filename, transform) {
    const doc = MeshWriter.createGLTF(transform);
    const io = new _t();
    io.writeBinary(doc).then((data) => {
      FileWriter.saveBinary(filename, data);
    });
  }
  static createGLTF(transform) {
    const doc = new Tt();
    const buffer = doc.createBuffer();
    const scene = doc.createScene();
    const node = doc.createNode();
    scene.addChild(node);
    MeshWriter.createGLTFRecursive(transform, doc, buffer, node);
    return doc;
  }
  static createGLTFRecursive(transform, doc, buffer, node) {
    const position = transform.position;
    const rotation = transform.rotation;
    const scale = transform.scale;
    node.setTranslation([position.x, position.y, position.z]);
    node.setRotation([rotation.x, rotation.y, rotation.z, rotation.w]);
    node.setScale([scale.x, scale.y, scale.z]);
    if (transform instanceof Mesh3) {
      const vertices = transform.getVertices();
      const normals = transform.getNormals();
      const uvs = transform.getTextureCoordinates();
      const indices = transform.getIndices();
      const mesh = doc.createMesh();
      node.setMesh(mesh);
      const primitive = doc.createPrimitive();
      const gltfPosition = doc.createAccessor().setArray(new Float32Array(vertices)).setType("VEC3").setBuffer(buffer);
      primitive.setAttribute("POSITION", gltfPosition);
      const gltfNormals = doc.createAccessor().setArray(new Float32Array(normals)).setType("VEC3").setBuffer(buffer);
      primitive.setAttribute("NORMAL", gltfNormals);
      if (transform.hasVertexColors) {
        const colors = transform.getColors();
        const gltfColors = doc.createAccessor().setArray(new Float32Array(colors)).setType("VEC4").setBuffer(buffer);
        primitive.setAttribute("COLOR_0", gltfColors);
      }
      const gltfUVs = doc.createAccessor().setArray(new Float32Array(uvs)).setType("VEC2").setBuffer(buffer);
      primitive.setAttribute("TEXCOORD_0", gltfUVs);
      const gltfIndices = doc.createAccessor().setArray(new Uint32Array(indices)).setType("SCALAR").setBuffer(buffer);
      primitive.setIndices(gltfIndices);
      const materialColor = transform.material.getColor();
      const material = doc.createMaterial().setBaseColorFactor([materialColor.r, materialColor.g, materialColor.b, materialColor.a]);
      primitive.setMaterial(material);
      mesh.addPrimitive(primitive);
    }
    for (let i = 0; i < transform.children.length; i++) {
      const child = doc.createNode();
      node.addChild(child);
      MeshWriter.createGLTFRecursive(transform.children[i], doc, buffer, child);
    }
  }
  static async writeJSON(filename, doc) {
    const io = new _t();
    const { json, resources } = await io.writeJSON(doc, { format: g.GLTF, basename: filename });
    const base64url = await new Promise((r) => {
      const reader = new FileReader();
      reader.onload = () => r(reader.result);
      reader.readAsDataURL(new Blob([resources[filename + ".bin"]]));
    });
    json.buffers[0].uri = base64url;
    FileWriter.saveAscii(filename, JSON.stringify(json, null, 2));
  }
};

// node_modules/gophergfx/src/shaders/phong.vert
var phong_default = "#version 300 es\n\nprecision mediump float;\n\nuniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 normalMatrix;\n\nin vec3 position;\nin vec3 normal;\nin vec4 color;\nin vec2 texCoord;\n\nout vec3 vertPosition;\nout vec3 vertNormal;\nout vec4 vertColor;\nout vec2 uv;\n\nvoid main() \n{\n    // Compute the final vertex position and normal\n    vertPosition = (modelMatrix * vec4(position, 1)).xyz;\n    vertNormal = normalize((normalMatrix * vec4(normal, 0)).xyz);\n    vertColor = color;\n    uv = texCoord.xy; \n    gl_Position = projectionMatrix * viewMatrix * vec4(vertPosition, 1);\n}";

// node_modules/gophergfx/src/shaders/phong.frag
var phong_default2 = "#version 300 es\n\nprecision mediump float;\n\n#define POINT_LIGHT 0\n#define DIRECTIONAL_LIGHT 1\n\nconst int MAX_LIGHTS = 8;\n\nuniform vec3 eyePosition;\n\nuniform int numLights;\nuniform int lightTypes[MAX_LIGHTS];\nuniform vec3 lightPositions[MAX_LIGHTS];\nuniform vec3 ambientIntensities[MAX_LIGHTS];\nuniform vec3 diffuseIntensities[MAX_LIGHTS];\nuniform vec3 specularIntensities[MAX_LIGHTS];\n\nuniform vec3 kAmbient;\nuniform vec3 kDiffuse;\nuniform vec3 kSpecular;\nuniform float shininess;\n\nuniform int useTexture;\nuniform sampler2D textureImage;\n\nin vec3 vertPosition;\nin vec3 vertNormal;\nin vec4 vertColor;\nin vec2 uv;\n\nout vec4 fragColor;\n\nvoid main() \n{\n    vec3 illumination = vec3(0, 0, 0);\n    for(int i=0; i < numLights; i++)\n    {\n        // Ambient component\n        illumination += kAmbient * ambientIntensities[i];\n\n        // Normalize the interpolated normal vector\n        vec3 n = normalize(vertNormal);\n\n        // Compute the vector from the vertex position to the light\n        vec3 l;\n        if(lightTypes[i] == DIRECTIONAL_LIGHT)\n            l = normalize(lightPositions[i]);\n        else\n            l = normalize(lightPositions[i] - vertPosition);\n\n        // Diffuse component\n        float diffuseComponent = max(dot(n, l), 0.0);\n        illumination += diffuseComponent * kDiffuse * diffuseIntensities[i];\n\n        // Compute the vector from the vertex to the eye\n        vec3 e = normalize(eyePosition - vertPosition);\n\n        // Compute the light vector reflected about the normal\n        vec3 r = reflect(-l, n);\n\n        // Specular component\n        float specularComponent = pow(max(dot(e, r), 0.0), shininess);\n        illumination += specularComponent * kSpecular * specularIntensities[i];\n    }\n\n    fragColor = vertColor;\n    fragColor.rgb *= illumination;\n\n    if(useTexture != 0)\n    {\n        fragColor *= texture(textureImage, uv);\n    }\n}";

// node_modules/gophergfx/src/materials/PhongMaterial.ts
var _PhongMaterial = class extends Material3 {
  constructor() {
    super();
    this.texture = null;
    this.ambientColor = new Color(1, 1, 1);
    this.diffuseColor = new Color(1, 1, 1);
    this.specularColor = new Color(0, 0, 0);
    this.shininess = 30;
    _PhongMaterial.shader.initialize(this.gl);
    this.kAmbientUniform = _PhongMaterial.shader.getUniform(this.gl, "kAmbient");
    this.kDiffuseUniform = _PhongMaterial.shader.getUniform(this.gl, "kDiffuse");
    this.kSpecularUniform = _PhongMaterial.shader.getUniform(this.gl, "kSpecular");
    this.shininessUniform = _PhongMaterial.shader.getUniform(this.gl, "shininess");
    this.textureUniform = _PhongMaterial.shader.getUniform(this.gl, "textureImage");
    this.useTextureUniform = _PhongMaterial.shader.getUniform(this.gl, "useTexture");
    this.eyePositionUniform = _PhongMaterial.shader.getUniform(this.gl, "eyePosition");
    this.viewUniform = _PhongMaterial.shader.getUniform(this.gl, "viewMatrix");
    this.modelUniform = _PhongMaterial.shader.getUniform(this.gl, "modelMatrix");
    this.projectionUniform = _PhongMaterial.shader.getUniform(this.gl, "projectionMatrix");
    this.normalUniform = _PhongMaterial.shader.getUniform(this.gl, "normalMatrix");
    this.numLightsUniform = _PhongMaterial.shader.getUniform(this.gl, "numLights");
    this.lightTypesUniform = _PhongMaterial.shader.getUniform(this.gl, "lightTypes");
    this.lightPositionsUniform = _PhongMaterial.shader.getUniform(this.gl, "lightPositions");
    this.ambientIntensitiesUniform = _PhongMaterial.shader.getUniform(this.gl, "ambientIntensities");
    this.diffuseIntensitiesUniform = _PhongMaterial.shader.getUniform(this.gl, "diffuseIntensities");
    this.specularIntensitiesUniform = _PhongMaterial.shader.getUniform(this.gl, "specularIntensities");
    this.positionAttribute = _PhongMaterial.shader.getAttribute(this.gl, "position");
    this.normalAttribute = _PhongMaterial.shader.getAttribute(this.gl, "normal");
    this.colorAttribute = _PhongMaterial.shader.getAttribute(this.gl, "color");
    this.texCoordAttribute = _PhongMaterial.shader.getAttribute(this.gl, "texCoord");
  }
  draw(mesh, camera, lightManager) {
    if (!this.visible || mesh.triangleCount == 0)
      return;
    this.initialize();
    this.gl.useProgram(_PhongMaterial.shader.getProgram());
    const worldMatrix = mesh.localToWorldMatrix;
    const cameraPosition = new Vector3();
    cameraPosition.transformPoint(camera.localToWorldMatrix);
    this.gl.uniform3f(this.eyePositionUniform, cameraPosition.x, cameraPosition.y, cameraPosition.z);
    this.gl.uniformMatrix4fv(this.modelUniform, false, worldMatrix.mat);
    this.gl.uniformMatrix4fv(this.viewUniform, false, camera.viewMatrix.mat);
    this.gl.uniformMatrix4fv(this.projectionUniform, false, camera.projectionMatrix.mat);
    this.gl.uniformMatrix4fv(this.normalUniform, false, worldMatrix.inverse().transpose().mat);
    this.gl.uniform3f(this.kAmbientUniform, this.ambientColor.r, this.ambientColor.g, this.ambientColor.b);
    this.gl.uniform3f(this.kDiffuseUniform, this.diffuseColor.r, this.diffuseColor.g, this.diffuseColor.b);
    this.gl.uniform3f(this.kSpecularUniform, this.specularColor.r, this.specularColor.g, this.specularColor.b);
    this.gl.uniform1f(this.shininessUniform, this.shininess);
    this.gl.uniform1i(this.numLightsUniform, lightManager.getNumLights());
    this.gl.uniform1iv(this.lightTypesUniform, lightManager.lightTypes);
    this.gl.uniform3fv(this.lightPositionsUniform, lightManager.lightPositions);
    this.gl.uniform3fv(this.ambientIntensitiesUniform, lightManager.ambientIntensities);
    this.gl.uniform3fv(this.diffuseIntensitiesUniform, lightManager.diffuseIntensities);
    this.gl.uniform3fv(this.specularIntensitiesUniform, lightManager.specularIntensities);
    this.gl.enableVertexAttribArray(this.positionAttribute);
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, mesh.positionBuffer);
    this.gl.vertexAttribPointer(this.positionAttribute, 3, this.gl.FLOAT, false, 0, 0);
    this.gl.enableVertexAttribArray(this.normalAttribute);
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, mesh.normalBuffer);
    this.gl.vertexAttribPointer(this.normalAttribute, 3, this.gl.FLOAT, false, 0, 0);
    if (mesh.hasVertexColors) {
      this.gl.enableVertexAttribArray(this.colorAttribute);
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, mesh.colorBuffer);
      this.gl.vertexAttribPointer(this.colorAttribute, 4, this.gl.FLOAT, false, 0, 0);
    } else {
      this.gl.disableVertexAttribArray(this.colorAttribute);
      this.gl.vertexAttrib4f(this.colorAttribute, 1, 1, 1, 1);
    }
    if (this.texture) {
      this.gl.uniform1i(this.useTextureUniform, 1);
      this.gl.activeTexture(this.gl.TEXTURE0 + this.texture.id);
      this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture.texture);
      this.gl.uniform1i(this.textureUniform, this.texture.id);
      this.gl.enableVertexAttribArray(this.texCoordAttribute);
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, mesh.texCoordBuffer);
      this.gl.vertexAttribPointer(this.texCoordAttribute, 2, this.gl.FLOAT, false, 0, 0);
    } else {
      this.gl.uniform1i(this.useTextureUniform, 0);
      this.gl.disableVertexAttribArray(this.texCoordAttribute);
    }
    this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, mesh.indexBuffer);
    this.gl.drawElements(this.gl.TRIANGLES, mesh.triangleCount * 3, this.gl.UNSIGNED_SHORT, 0);
  }
  setColor(color) {
    this.ambientColor.copy(color);
    this.diffuseColor.copy(color);
    this.specularColor.copy(color);
  }
  getColor() {
    return this.diffuseColor;
  }
};
var PhongMaterial = _PhongMaterial;
PhongMaterial.shader = new ShaderProgram(phong_default, phong_default2);

// node_modules/gophergfx/src/shaders/wireframe.vert
var wireframe_default = "#version 300 es\n\nprecision mediump float;\n\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\n\nin vec3 position;\n\nvoid main() \n{\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1);\n}";

// node_modules/gophergfx/src/shaders/wireframe.frag
var wireframe_default2 = "#version 300 es\n\nprecision mediump float;\n\nuniform vec4 color;\n\nout vec4 fragColor;\n\nvoid main() \n{\n    fragColor = color;\n}";

// node_modules/gophergfx/src/materials/WireframeMaterial.ts
var _WireframeMaterial = class extends Material3 {
  constructor() {
    super();
    this.color = new Color(1, 1, 1, 1);
    _WireframeMaterial.shader.initialize(this.gl);
    this.positionAttribute = _WireframeMaterial.shader.getAttribute(this.gl, "position");
    this.modelViewUniform = _WireframeMaterial.shader.getUniform(this.gl, "modelViewMatrix");
    this.projectionUniform = _WireframeMaterial.shader.getUniform(this.gl, "projectionMatrix");
    this.colorUniform = _WireframeMaterial.shader.getUniform(this.gl, "color");
  }
  draw(mesh, camera, lightManager) {
    if (!this.visible || mesh.triangleCount == 0)
      return;
    this.initialize();
    this.gl.useProgram(_WireframeMaterial.shader.getProgram());
    this.gl.uniformMatrix4fv(this.modelViewUniform, false, Matrix4.multiply(camera.viewMatrix, mesh.localToWorldMatrix).mat);
    this.gl.uniformMatrix4fv(this.projectionUniform, false, camera.projectionMatrix.mat);
    this.gl.uniform4f(this.colorUniform, this.color.r, this.color.g, this.color.b, this.color.a);
    this.gl.enableVertexAttribArray(this.positionAttribute);
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, mesh.positionBuffer);
    this.gl.vertexAttribPointer(this.positionAttribute, 3, this.gl.FLOAT, false, 0, 0);
    if (!_WireframeMaterial.wireframeBuffers.get(mesh)) {
      this.updateWireframeBuffer(mesh);
    }
    this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, _WireframeMaterial.wireframeBuffers.get(mesh));
    this.gl.drawElements(this.gl.LINES, mesh.triangleCount * 6, this.gl.UNSIGNED_SHORT, 0);
  }
  updateWireframeBuffer(mesh) {
    let wireframeBuffer;
    wireframeBuffer = _WireframeMaterial.wireframeBuffers.get(mesh);
    if (!wireframeBuffer) {
      wireframeBuffer = this.gl.createBuffer();
      if (wireframeBuffer)
        _WireframeMaterial.wireframeBuffers.set(mesh, wireframeBuffer);
    }
    const indexArray = new Uint16Array(mesh.triangleCount * 3);
    this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, mesh.indexBuffer);
    this.gl.getBufferSubData(this.gl.ELEMENT_ARRAY_BUFFER, 0, indexArray);
    const indices = [...indexArray];
    const wireframeIndices = [];
    for (let i = 0; i < mesh.triangleCount; i++) {
      wireframeIndices.push(indices[i * 3]);
      wireframeIndices.push(indices[i * 3 + 1]);
      wireframeIndices.push(indices[i * 3 + 1]);
      wireframeIndices.push(indices[i * 3 + 2]);
      wireframeIndices.push(indices[i * 3 + 2]);
      wireframeIndices.push(indices[i * 3]);
    }
    this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, wireframeBuffer);
    this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(wireframeIndices), this.gl.STATIC_DRAW);
  }
  setColor(color) {
    this.color.copy(color);
  }
  getColor() {
    return this.color;
  }
};
var WireframeMaterial = _WireframeMaterial;
WireframeMaterial.shader = new ShaderProgram(wireframe_default, wireframe_default2);
WireframeMaterial.wireframeBuffers = /* @__PURE__ */ new Map();

// node_modules/gophergfx/src/materials/BoundingVolumeMaterial.ts
var BoundingVolumeMode = /* @__PURE__ */ ((BoundingVolumeMode2) => {
  BoundingVolumeMode2[BoundingVolumeMode2["ORIENTED_BOUNDING_BOX"] = 0] = "ORIENTED_BOUNDING_BOX";
  BoundingVolumeMode2[BoundingVolumeMode2["AXIS_ALIGNED_BOUNDING_BOX"] = 1] = "AXIS_ALIGNED_BOUNDING_BOX";
  BoundingVolumeMode2[BoundingVolumeMode2["BOUNDING_SPHERE"] = 2] = "BOUNDING_SPHERE";
  return BoundingVolumeMode2;
})(BoundingVolumeMode || {});
var BoundingVolumeMaterial = class extends Material3 {
  constructor(mode = 0 /* ORIENTED_BOUNDING_BOX */, color = new Color(1, 1, 1, 1)) {
    super();
    this.mode = mode;
    this.color = Color.copy(color);
    this.sphere = Geometry3Factory.createSphere(1, 1);
    const boundingBox = new BoundingBox3();
    boundingBox.max.set(0.5, 0.5, 0.5);
    boundingBox.min.set(-0.5, -0.5, -0.5);
    this.box = new Line3();
    this.box.createFromBox(boundingBox);
    this.box.color = this.color;
    this.wireframeMaterial = new WireframeMaterial();
    this.wireframeMaterial.color = this.color;
    this.sphere.material = this.wireframeMaterial;
  }
  draw(object, camera, lightManager) {
    if (this.mode == 0 /* ORIENTED_BOUNDING_BOX */) {
      const boxPosition = Vector3.add(object.boundingBox.min, object.boundingBox.max);
      boxPosition.multiplyScalar(0.5);
      const boxScale = new Vector3(
        object.boundingBox.max.x - object.boundingBox.min.x,
        object.boundingBox.max.y - object.boundingBox.min.y,
        object.boundingBox.max.z - object.boundingBox.min.z
      );
      const boxMatrix = Matrix4.makeScale(boxScale);
      boxMatrix.mat[12] = boxPosition.x;
      boxMatrix.mat[13] = boxPosition.y;
      boxMatrix.mat[14] = boxPosition.z;
      this.box.localToWorldMatrix.copy(boxMatrix);
      this.box.localToWorldMatrix.premultiply(object.localToWorldMatrix);
      this.box.draw(object, camera, lightManager);
    } else if (this.mode == 1 /* AXIS_ALIGNED_BOUNDING_BOX */) {
      const abb = object.worldBoundingBox;
      const boxPosition = Vector3.add(abb.min, abb.max);
      boxPosition.multiplyScalar(0.5);
      const boxScale = new Vector3(
        abb.max.x - abb.min.x,
        abb.max.y - abb.min.y,
        abb.max.z - abb.min.z
      );
      const boxMatrix = Matrix4.makeScale(boxScale);
      boxMatrix.mat[12] = boxPosition.x;
      boxMatrix.mat[13] = boxPosition.y;
      boxMatrix.mat[14] = boxPosition.z;
      this.box.localToWorldMatrix.copy(boxMatrix);
      this.box.draw(object, camera, lightManager);
    } else if (this.mode == 2 /* BOUNDING_SPHERE */) {
      const sphereScale = new Vector3(object.boundingSphere.radius, object.boundingSphere.radius, object.boundingSphere.radius);
      const sphereMatrix = Matrix4.makeScale(sphereScale);
      sphereMatrix.mat[12] = object.boundingSphere.center.x;
      sphereMatrix.mat[13] = object.boundingSphere.center.y;
      sphereMatrix.mat[14] = object.boundingSphere.center.z;
      this.sphere.localToWorldMatrix.copy(sphereMatrix);
      this.sphere.localToWorldMatrix.premultiply(object.localToWorldMatrix);
      this.sphere.draw(object, camera, lightManager);
    }
  }
  setColor(color) {
    this.color.copy(color);
  }
  getColor() {
    return this.color;
  }
};

// node_modules/gophergfx/src/materials/Texture.ts
var _Texture = class {
  constructor(source = new ImageData(new Uint8ClampedArray([255, 0, 255, 255]), 1, 1)) {
    this.gl = GfxApp.getInstance().renderer.gl;
    this.texture = this.gl.createTexture();
    this.id = _Texture.numTextures;
    _Texture.numTextures++;
    this.gl.activeTexture(this.gl.TEXTURE0 + this.id);
    this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture);
    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.REPEAT);
    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.REPEAT);
    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.NEAREST_MIPMAP_LINEAR);
    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);
    if (source instanceof ImageData) {
      this.width = source.width;
      this.height = source.height;
      this.gl.texImage2D(
        this.gl.TEXTURE_2D,
        0,
        this.gl.RGBA,
        this.width,
        this.height,
        0,
        this.gl.RGBA,
        this.gl.UNSIGNED_BYTE,
        source.data
      );
    } else if (typeof source == "string") {
      this.width = void 0;
      this.height = void 0;
      this.load(source);
    } else {
      this.width = 1;
      this.height = 1;
      this.gl.texImage2D(
        this.gl.TEXTURE_2D,
        0,
        this.gl.RGBA,
        this.width,
        this.height,
        0,
        this.gl.RGBA,
        this.gl.UNSIGNED_BYTE,
        new Uint8Array([255, 0, 255, 255])
      );
    }
  }
  load(url) {
    GfxApp.getInstance().assetManager.requestedAssets.push(url);
    const image = new Image();
    image.addEventListener("load", (event) => {
      this.imageLoaded(image, url);
    }, false);
    image.addEventListener("error", (event) => {
      this.imageNotFound(url);
    }, false);
    image.src = url;
  }
  imageLoaded(image, url) {
    GfxApp.getInstance().assetManager.loadedAssets.push(url);
    this.width = image.width;
    this.height = image.height;
    this.gl.activeTexture(this.gl.TEXTURE0 + this.id);
    this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture);
    this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, image);
    this.gl.generateMipmap(this.gl.TEXTURE_2D);
  }
  setFullImageData(imageData) {
    this.gl.activeTexture(this.gl.TEXTURE0 + this.id);
    this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture);
    this.gl.texSubImage2D(this.gl.TEXTURE_2D, 0, 0, 0, imageData.width, imageData.height, this.gl.RGBA, this.gl.UNSIGNED_BYTE, imageData.data);
    this.gl.generateMipmap(this.gl.TEXTURE_2D);
  }
  setSubImageData(imageData, xOffset, yOffset) {
    this.gl.activeTexture(this.gl.TEXTURE0 + this.id);
    this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture);
    this.gl.texSubImage2D(this.gl.TEXTURE_2D, 0, xOffset, yOffset, imageData.width, imageData.height, this.gl.RGBA, this.gl.UNSIGNED_BYTE, imageData.data);
    this.gl.generateMipmap(this.gl.TEXTURE_2D);
  }
  imageNotFound(url) {
    GfxApp.getInstance().assetManager.errorAssets.push(url);
  }
  setMinFilter(linear, mipmap) {
    this.gl.activeTexture(this.gl.TEXTURE0 + this.id);
    if (linear) {
      if (mipmap)
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.NEAREST_MIPMAP_LINEAR);
      else
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);
    } else {
      if (mipmap)
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.NEAREST_MIPMAP_NEAREST);
      else
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.NEAREST);
    }
  }
  setMagFilter(linear) {
    this.gl.activeTexture(this.gl.TEXTURE0 + this.id);
    if (linear)
      this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);
    else
      this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.NEAREST);
  }
  setWrapping(repeat) {
    this.gl.activeTexture(this.gl.TEXTURE0 + this.id);
    if (repeat) {
      this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.REPEAT);
      this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.REPEAT);
    } else {
      this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
      this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);
    }
  }
};
var Texture = _Texture;
Texture.numTextures = 0;

// node_modules/gophergfx/src/materials/Text.ts
var Text = class extends Texture {
  constructor(text, width, height, font = "24px monospace", fillStyle = "black", backgroundStyle = "", strokeStyle = "", strokeWidth = 1, align = "center", baseline = "middle") {
    super();
    this.text = text;
    this.width = width;
    this.height = height;
    this.font = font;
    if (fillStyle instanceof Color) {
      this.fillStyleString = "rgb(" + fillStyle.r * 255 + " " + fillStyle.g * 255 + " " + fillStyle.b * 255 + " / " + fillStyle.a * 255 + ")";
    } else {
      this.fillStyleString = fillStyle;
    }
    if (backgroundStyle instanceof Color) {
      this.backgroundStyleString = "rgb(" + backgroundStyle.r * 255 + " " + backgroundStyle.g * 255 + " " + backgroundStyle.b * 255 + " / " + backgroundStyle.a * 255 + ")";
    } else {
      this.backgroundStyleString = backgroundStyle;
    }
    if (strokeStyle instanceof Color) {
      this.strokeStyleString = "rgb(" + strokeStyle.r * 255 + " " + strokeStyle.g * 255 + " " + strokeStyle.b * 255 + " / " + strokeStyle.a * 255 + ")";
    } else {
      this.strokeStyleString = strokeStyle;
    }
    this.strokeWidth = strokeWidth;
    this.align = align;
    this.baseline = baseline;
    this.textCanvas = document.createElement("canvas").getContext("2d");
    this.updateTextureImage();
  }
  updateTextureImage() {
    if (this.textCanvas) {
      this.textCanvas.canvas.width = this.width;
      this.textCanvas.canvas.height = this.height;
      this.textCanvas.font = this.font;
      this.textCanvas.textAlign = this.align;
      this.textCanvas.textBaseline = this.baseline;
      this.textCanvas.clearRect(0, 0, this.width, this.height);
      if (this.backgroundStyleString != "") {
        this.textCanvas.fillStyle = this.backgroundStyleString;
        this.textCanvas.fillRect(0, 0, this.width, this.height);
      }
      if (this.fillStyleString != "") {
        this.textCanvas.fillStyle = this.fillStyleString;
        this.textCanvas.fillText(this.text, this.width / 2, this.height / 2);
      }
      if (this.strokeStyleString != "" && this.strokeWidth > 0) {
        this.textCanvas.strokeStyle = this.strokeStyleString;
        this.textCanvas.lineWidth = this.strokeWidth;
        this.textCanvas.strokeText(this.text, this.width / 2, this.height / 2);
      }
      this.gl.activeTexture(this.gl.TEXTURE0 + this.id);
      this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture);
      this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, this.textCanvas.canvas);
      this.gl.generateMipmap(this.gl.TEXTURE_2D);
    }
  }
};

// node_modules/gophergfx/src/math/LinearPath3.ts
var LinearPath3 = class {
  constructor() {
    this.controlPoints = [];
  }
  getPoint(segment, t) {
    if (segment < this.controlPoints.length - 1) {
      return Vector3.lerp(this.controlPoints[segment], this.controlPoints[segment + 1], MathUtils.clamp(t, 0, 1));
    } else {
      return null;
    }
  }
};

// node_modules/gophergfx/src/math/CurvePath3.ts
var CurvePath3 = class {
  constructor(alpha = 0.5, tension = 0) {
    this.controlPoints = [];
    this.alpha = alpha;
    this.tension = tension;
  }
  getPoint(segment, t) {
    if (segment == 0) {
      const v = Vector3.subtract(this.controlPoints[segment + 1], this.controlPoints[segment]);
      const firstPoint = Vector3.subtract(this.controlPoints[segment], v);
      return this.computePoint(
        firstPoint,
        this.controlPoints[segment],
        this.controlPoints[segment + 1],
        this.controlPoints[segment + 2],
        MathUtils.clamp(t, 0, 1)
      );
    }
    if (segment < this.controlPoints.length - 2) {
      return this.computePoint(
        this.controlPoints[segment - 1],
        this.controlPoints[segment],
        this.controlPoints[segment + 1],
        this.controlPoints[segment + 2],
        MathUtils.clamp(t, 0, 1)
      );
    } else if (segment == this.controlPoints.length - 2) {
      const v = Vector3.subtract(this.controlPoints[segment + 1], this.controlPoints[segment]);
      const lastPoint = Vector3.add(this.controlPoints[segment + 1], v);
      return this.computePoint(
        this.controlPoints[segment - 1],
        this.controlPoints[segment],
        this.controlPoints[segment + 1],
        lastPoint,
        MathUtils.clamp(t, 0, 1)
      );
    } else if (segment == this.controlPoints.length - 1) {
      const v = Vector3.subtract(this.controlPoints[segment], this.controlPoints[segment - 1]);
      const secondToLastPoint = Vector3.add(this.controlPoints[segment], v);
      const lastPoint = Vector3.add(secondToLastPoint, v);
      return this.computePoint(
        this.controlPoints[segment - 1],
        this.controlPoints[segment],
        secondToLastPoint,
        lastPoint,
        MathUtils.clamp(t, 0, 1)
      );
    } else {
      return null;
    }
  }
  computePoint(p0, p1, p2, p3, t) {
    const t01 = Math.pow(p0.distanceTo(p1), this.alpha);
    const t12 = Math.pow(p1.distanceTo(p2), this.alpha);
    const t23 = Math.pow(p2.distanceTo(p3), this.alpha);
    const p1p0 = Vector3.subtract(p1, p0);
    const p1p2 = Vector3.subtract(p1, p2);
    const p2p0 = Vector3.subtract(p2, p0);
    const p2p1 = Vector3.subtract(p2, p1);
    const p3p1 = Vector3.subtract(p3, p1);
    const p3p2 = Vector3.subtract(p3, p2);
    const m1 = Vector3.multiplyScalar(p1p0, 1 / t01);
    m1.subtract(Vector3.multiplyScalar(p2p0, 1 / (t01 + t12)));
    m1.multiplyScalar(t12);
    m1.add(p2p1);
    m1.multiplyScalar(1 - this.tension);
    const m2 = Vector3.multiplyScalar(p3p2, 1 / t23);
    m2.subtract(Vector3.multiplyScalar(p3p1, 1 / (t12 + t23)));
    m2.multiplyScalar(t12);
    m2.add(p2p1);
    m2.multiplyScalar(1 - this.tension);
    const a = Vector3.multiplyScalar(p1p2, 2);
    a.add(m1);
    a.add(m2);
    const b = Vector3.multiplyScalar(p1p2, -3);
    b.subtract(m1);
    b.subtract(m1);
    b.subtract(m2);
    const c2 = m1;
    const d2 = p1;
    const result = Vector3.multiplyScalar(a, t * t * t);
    result.add(Vector3.multiplyScalar(b, t * t));
    result.add(Vector3.multiplyScalar(c2, t));
    result.add(d2);
    return result;
  }
};

// node_modules/gophergfx/src/math/LinearPath2.ts
var LinearPath2 = class {
  constructor() {
    this.controlPoints = [];
  }
  getPoint(segment, t) {
    if (segment < this.controlPoints.length - 1) {
      return Vector2.lerp(this.controlPoints[segment], this.controlPoints[segment + 1], MathUtils.clamp(t, 0, 1));
    } else {
      return null;
    }
  }
};

// node_modules/gophergfx/src/math/CurvePath2.ts
var CurvePath2 = class {
  constructor(alpha = 0.5, tension = 0) {
    this.controlPoints = [];
    this.alpha = alpha;
    this.tension = tension;
  }
  getPoint(segment, t) {
    if (segment == 0) {
      const v = Vector2.subtract(this.controlPoints[segment + 1], this.controlPoints[segment]);
      const firstPoint = Vector2.subtract(this.controlPoints[segment], v);
      return this.computePoint(
        firstPoint,
        this.controlPoints[segment],
        this.controlPoints[segment + 1],
        this.controlPoints[segment + 2],
        MathUtils.clamp(t, 0, 1)
      );
    }
    if (segment < this.controlPoints.length - 2) {
      return this.computePoint(
        this.controlPoints[segment - 1],
        this.controlPoints[segment],
        this.controlPoints[segment + 1],
        this.controlPoints[segment + 2],
        MathUtils.clamp(t, 0, 1)
      );
    } else if (segment == this.controlPoints.length - 2) {
      const v = Vector2.subtract(this.controlPoints[segment + 1], this.controlPoints[segment]);
      const lastPoint = Vector2.add(this.controlPoints[segment + 1], v);
      return this.computePoint(
        this.controlPoints[segment - 1],
        this.controlPoints[segment],
        this.controlPoints[segment + 1],
        lastPoint,
        MathUtils.clamp(t, 0, 1)
      );
    } else if (segment == this.controlPoints.length - 1) {
      const v = Vector2.subtract(this.controlPoints[segment], this.controlPoints[segment - 1]);
      const secondToLastPoint = Vector2.add(this.controlPoints[segment], v);
      const lastPoint = Vector2.add(secondToLastPoint, v);
      return this.computePoint(
        this.controlPoints[segment - 1],
        this.controlPoints[segment],
        secondToLastPoint,
        lastPoint,
        MathUtils.clamp(t, 0, 1)
      );
    } else {
      return null;
    }
  }
  computePoint(p0, p1, p2, p3, t) {
    const t01 = Math.pow(p0.distanceTo(p1), this.alpha);
    const t12 = Math.pow(p1.distanceTo(p2), this.alpha);
    const t23 = Math.pow(p2.distanceTo(p3), this.alpha);
    const p1p0 = Vector2.subtract(p1, p0);
    const p1p2 = Vector2.subtract(p1, p2);
    const p2p0 = Vector2.subtract(p2, p0);
    const p2p1 = Vector2.subtract(p2, p1);
    const p3p1 = Vector2.subtract(p3, p1);
    const p3p2 = Vector2.subtract(p3, p2);
    const m1 = Vector2.multiplyScalar(p1p0, 1 / t01);
    m1.subtract(Vector2.multiplyScalar(p2p0, 1 / (t01 + t12)));
    m1.multiplyScalar(t12);
    m1.add(p2p1);
    m1.multiplyScalar(1 - this.tension);
    const m2 = Vector2.multiplyScalar(p3p2, 1 / t23);
    m2.subtract(Vector2.multiplyScalar(p3p1, 1 / (t12 + t23)));
    m2.multiplyScalar(t12);
    m2.add(p2p1);
    m2.multiplyScalar(1 - this.tension);
    const a = Vector2.multiplyScalar(p1p2, 2);
    a.add(m1);
    a.add(m2);
    const b = Vector2.multiplyScalar(p1p2, -3);
    b.subtract(m1);
    b.subtract(m1);
    b.subtract(m2);
    const c2 = m1;
    const d2 = p1;
    const result = Vector2.multiplyScalar(a, t * t * t);
    result.add(Vector2.multiplyScalar(b, t * t));
    result.add(Vector2.multiplyScalar(c2, t));
    result.add(d2);
    return result;
  }
};
export {
  AmbientLight,
  AssetManager,
  BoundingBox2,
  BoundingBox3,
  BoundingCircle,
  BoundingSphere,
  BoundingVolumeMaterial,
  BoundingVolumeMode,
  Camera,
  Color,
  CoordinateSpace2,
  CoordinateSpace3,
  CurvePath2,
  CurvePath3,
  DirectionalLight,
  FileWriter,
  FirstPersonControls,
  Geometry2Factory,
  Geometry3Factory,
  GfxApp,
  GouraudMaterial,
  IntersectionMode2,
  IntersectionMode3,
  Light,
  LightManager,
  LightType,
  Line2,
  Line3,
  LineMode2,
  LineMode3,
  LinearPath2,
  LinearPath3,
  Material2,
  Material3,
  MathUtils,
  Matrix3,
  Matrix4,
  Mesh2,
  Mesh3,
  MeshLoader,
  MeshParser,
  MeshWriter,
  MorphMaterial,
  MorphMesh3,
  Node2,
  Node3,
  OrbitControls,
  Particles2,
  PhongMaterial,
  Plane3,
  PointLight,
  Quaternion,
  Ray3,
  Renderer,
  Scene,
  ShaderProgram,
  Side,
  StringParser,
  Text,
  TextFile,
  TextFileLoader,
  Texture,
  TransformWidget,
  UnlitMaterial,
  Vector2,
  Vector3,
  Viewport,
  WireframeMaterial
};
//# sourceMappingURL=gophergfx.js.map
